The market smart contract is used for performing energy transactions, in exactly the same manner as the Market Python class. There are 3 main non-view functions/transactions (functions that actually mutate the state of the blockchain) on the contract:

- `offer()`: Places an energy offer to the market. Needs the offered energy and the offer price as arguments. The smart contract generates an offer id and stores the offer in its 'offers' mapping, similar to its Python counterpart. Emits a `NewOffer` event on success, which will notify the listeners of the contract about the new offer that was created.
- `cancel()`: Removes a previously created offer from the market. Needs the offer id in bytes as argument. This function removes the offer id from the 'offers' mapping. Emits a `CancelOffer` event to notify the listeners about the deleted offer. 
- `trade()`: Performs an energy trade. Needs the selected offer id and the desired traded energy as arguments. Similar to the `accept_offer` Python function, it checks whether the selected offer is eligible for this trade and performs the actual trade. In case the desired energy is less than the offer energy, a partial trade is performed and a new residual offer is generated. The listeners get notified for the offer change by an `OfferChanged` event that gets emitted, which notifies the listeners about the new and the old offer ids, along with the new offer energy and price. On a successful trade, a `NewTrade` event is also emitted, which notifies the listeners about the trade that was performed. 

This contract is also responsible for the energy and token balance of the devices registered in it. For the energy balance, it is stored directly on the market contract ('balances' mapping). As for the token balance, a separate smart contract is responsible (`ClearingToken`) which is invoked via an external function during the trade function, in order to update the price/token balances of the buyer and the seller of the trade. 