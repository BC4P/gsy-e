{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"alternative-pricing-schemes/","text":"Alternative Pricing Schemes \u00b6 How to configure Alternative Pricing To enable comparison of 4 different pricing schemes: (0) D3A pricing (trading according the D3A hierarchical market model) (1) no-scheme pricing ( GridAgent buys at 0 ct/kWh and sells for market_maker_rate ) (2) feed-in-tariff pricing ( GridAgent buys at feed_in_tariff_percentage * market_maker_rate and sells for market_maker_rate ) (3) net metering pricing ( GridAgent buys at market_maker_rate and sells for market_maker_rate ) set the command line flag --compare-alt-pricing . This will run separate d3a-simulation s with all 4 alternative pricing schemes in parallel for the selected setup file. The results of each simulation are stored in separate subfolders in the export-path . If you want to run a simulation only for one specific pricing scheme, set it via a ConstSetting in the setup file in which you are configuring your grid, e.g. by adding the following line: ConstSettings.IAASettings.AlternativePricing.PRICING_SCHEME = 1 (You should not set this parameter and use the --compare-alt-pricing cli parameter combined) The feed-in-tariff (FIT) is a percentage that is set in the ConstSetting s as well, the default is 50%. Set this parameter yourself via a ConstSetting in the setup file in which you are configuring your grid, by adding the following line (e.g. FIT = 60% of market_maker_rate ): ConstSettings.IAASettings.AlternativePricing.FEED_IN_TARIFF_PERCENTAGE = 60 For more information we refer to Alternative Pricing Mechanisms. Alternative Pricing Mechanisms \u00b6 In the D3A, the D3A pricing mechanism (determined through the D3A market structure) can be compared to other pricing mechanisms that are currently being used by utilities and grid providers. By setting one of the three pricing schemes below, the user can calculate the energy bills from a simulation according to that scheme. This is done by adjusting the feed-in-tariff (FIT). Many energy markets have a FIT that fits one of the three scenarios that can each be configured and run in the D3A. The cost to buy electricity from the utility is known in the D3A as the market maker rate (MMR). This is because in grid connected scenarios, a community or local grid is connected to the utility grid which is modeled as an infinite power plant and sells power at the utility rate. This rate is called the market maker rate because it sets the price basis for the other buyers and sellers in the market. There are three alternative pricing schemes: No Pricing scheme : In this scheme, the households or grid customers have a 0% FIT and cannot sell any surplus energy they produce to the grid for additional income. They buy energy from the grid at the utility rate (MMR). Feed In Tariff (FIT) : In this scheme, the households or grid customers have 50% FIT (50% is the default value; it is configurable) at which they can sell surplus energy to the grid for 50% of the MMR. They buy energy from the grid at the utility rate (MMR). Net Metering (NM) : In this scheme, the households or grid customers have a 100% FIT, which is also known as net metering. This means that they can sell surplus energy to the utility at the same rate that they must pay to buy. In many implementations this means that the customer simply rolls back their meter when supplying the grid with energy and pays the net energy they have consumed each paying period times the utility rate (MMR). (In the case of 100% FIT, the customer could actually make a net income if they produce more than they consume under a flat MMR.) How the D3A engine simulates these alternative pricing schemes: All areas at the lowest level (with their own meter) are disconnected. Areas that contain children/devices are considered \"households\" or \"grid customers\". These households are allowed to trade internally; this way, household PV's are still able to supply to that respective household load, just as you would expect. The surplus PV energy is \"sold\" to the IAA of the household; the IAA does not connect to the higher level market as would be the case in D3A trading, but connects directly to a \" GridAgent \". This GridAgent reimburses the household IAA according to the FIT. Any energy bought, for instance when a household PV (if any) does not supply enough energy, is provided by the GridAgent at the MMR. See picture; in case of --compare-alt-price is flagged; the D3A grid is isolated according to the red dotted lines; and IAA are connected to the DSO/Utility grid.","title":"Alternative Pricing Schemes"},{"location":"alternative-pricing-schemes/#alternative-pricing-schemes","text":"How to configure Alternative Pricing To enable comparison of 4 different pricing schemes: (0) D3A pricing (trading according the D3A hierarchical market model) (1) no-scheme pricing ( GridAgent buys at 0 ct/kWh and sells for market_maker_rate ) (2) feed-in-tariff pricing ( GridAgent buys at feed_in_tariff_percentage * market_maker_rate and sells for market_maker_rate ) (3) net metering pricing ( GridAgent buys at market_maker_rate and sells for market_maker_rate ) set the command line flag --compare-alt-pricing . This will run separate d3a-simulation s with all 4 alternative pricing schemes in parallel for the selected setup file. The results of each simulation are stored in separate subfolders in the export-path . If you want to run a simulation only for one specific pricing scheme, set it via a ConstSetting in the setup file in which you are configuring your grid, e.g. by adding the following line: ConstSettings.IAASettings.AlternativePricing.PRICING_SCHEME = 1 (You should not set this parameter and use the --compare-alt-pricing cli parameter combined) The feed-in-tariff (FIT) is a percentage that is set in the ConstSetting s as well, the default is 50%. Set this parameter yourself via a ConstSetting in the setup file in which you are configuring your grid, by adding the following line (e.g. FIT = 60% of market_maker_rate ): ConstSettings.IAASettings.AlternativePricing.FEED_IN_TARIFF_PERCENTAGE = 60 For more information we refer to Alternative Pricing Mechanisms.","title":"Alternative Pricing Schemes"},{"location":"alternative-pricing-schemes/#alternative-pricing-mechanisms","text":"In the D3A, the D3A pricing mechanism (determined through the D3A market structure) can be compared to other pricing mechanisms that are currently being used by utilities and grid providers. By setting one of the three pricing schemes below, the user can calculate the energy bills from a simulation according to that scheme. This is done by adjusting the feed-in-tariff (FIT). Many energy markets have a FIT that fits one of the three scenarios that can each be configured and run in the D3A. The cost to buy electricity from the utility is known in the D3A as the market maker rate (MMR). This is because in grid connected scenarios, a community or local grid is connected to the utility grid which is modeled as an infinite power plant and sells power at the utility rate. This rate is called the market maker rate because it sets the price basis for the other buyers and sellers in the market. There are three alternative pricing schemes: No Pricing scheme : In this scheme, the households or grid customers have a 0% FIT and cannot sell any surplus energy they produce to the grid for additional income. They buy energy from the grid at the utility rate (MMR). Feed In Tariff (FIT) : In this scheme, the households or grid customers have 50% FIT (50% is the default value; it is configurable) at which they can sell surplus energy to the grid for 50% of the MMR. They buy energy from the grid at the utility rate (MMR). Net Metering (NM) : In this scheme, the households or grid customers have a 100% FIT, which is also known as net metering. This means that they can sell surplus energy to the utility at the same rate that they must pay to buy. In many implementations this means that the customer simply rolls back their meter when supplying the grid with energy and pays the net energy they have consumed each paying period times the utility rate (MMR). (In the case of 100% FIT, the customer could actually make a net income if they produce more than they consume under a flat MMR.) How the D3A engine simulates these alternative pricing schemes: All areas at the lowest level (with their own meter) are disconnected. Areas that contain children/devices are considered \"households\" or \"grid customers\". These households are allowed to trade internally; this way, household PV's are still able to supply to that respective household load, just as you would expect. The surplus PV energy is \"sold\" to the IAA of the household; the IAA does not connect to the higher level market as would be the case in D3A trading, but connects directly to a \" GridAgent \". This GridAgent reimburses the household IAA according to the FIT. Any energy bought, for instance when a household PV (if any) does not supply enough energy, is provided by the GridAgent at the MMR. See picture; in case of --compare-alt-price is flagged; the D3A grid is isolated according to the red dotted lines; and IAA are connected to the DSO/Utility grid.","title":"Alternative Pricing Mechanisms"},{"location":"areas/","text":"Areas contain sub-areas and devices. Areas are interconnected by inter-area agents in a hierarchical network. Each area has a market on which inter-area agents (representing other markets) and devices can post bids and offers. For further information about the markets, see the backend manual: Markets .","title":"Areas"},{"location":"backend-codebase/","text":"For general usage of the D3A software please consult the README . Constants, limits and validators live in the d3a-interface repository . It gets installed automatically if one runs \" fab sync \" in the d3a folder.","title":"Backend Codebase Overview"},{"location":"balancing-market/","text":"Device Registry \u00b6 Any device first has to get registered before actually placing offers in balancing market. HOW TO REGISTER A DEVICE IN THE REGISTRY IN THE SETUP FILE: The balancing device registry is a dictionary that contains the names of the devices as keys and the balancing rates as the tuple values: (demand balancing rate, supply balancing rate). device_registry_dict = { \"H1 General Load\": (33, 35), \"H2 General Load\": (33, 35), \"H1 Storage1\": (33, 35), \"H1 Storage2\": (33, 35), } Devices \u00b6 Currently, Load Strategy / Storage Strategy / Infinite Power Plant (Commercial Producer) can place balancing offers only if they are registered in \"Device Registry\". Balancing Market \u00b6 It is a single sided Pay-as-Ask market, accepts balancing_offers from devices and connected hierarchies of balancing_market . balancing_offers could be positive or negative. It also facilitates the balancing_trade . Balancing Agent \u00b6 It listens to the spot_market_trade of its lower hierarchy. Whenever there is a trade in lower hierarchy of spot_market , it will to try secure a percentage of spot market trades in balancing market. Constant Parameters \u00b6 Following are the constant parameters related to balancing market ENABLE_BALANCING_MARKET \u2192 (Default: False) : enables the simulation with Balancing Market BALANCING_SPOT_TRADE_RATIO \u2192 (Default: 0.2) : dictates the ratio of spot_market_energy to be traded in balancing market BALANCING_OFFER_DEMAND_RATIO \u2192 (Default: 0.1) : dictates the ratio of spot_market_energy to be offered in balancing market as demand_balancing_offer BALANCING_OFFER_SUPPLY_RATIO \u2192 (Default: 0.1) : dictates the ratio of spot_market_energy to be offered in balancing market as supply_balancing_offer BALANCING_FLEXIBLE_LOADS_SUPPORT \u2192 (Default: True) : It enables Load Strategy to place supply_balancing_offer (effectively curtailing it's load)","title":"Balancing Market"},{"location":"balancing-market/#device-registry","text":"Any device first has to get registered before actually placing offers in balancing market. HOW TO REGISTER A DEVICE IN THE REGISTRY IN THE SETUP FILE: The balancing device registry is a dictionary that contains the names of the devices as keys and the balancing rates as the tuple values: (demand balancing rate, supply balancing rate). device_registry_dict = { \"H1 General Load\": (33, 35), \"H2 General Load\": (33, 35), \"H1 Storage1\": (33, 35), \"H1 Storage2\": (33, 35), }","title":"Device Registry"},{"location":"balancing-market/#devices","text":"Currently, Load Strategy / Storage Strategy / Infinite Power Plant (Commercial Producer) can place balancing offers only if they are registered in \"Device Registry\".","title":"Devices"},{"location":"balancing-market/#balancing-market","text":"It is a single sided Pay-as-Ask market, accepts balancing_offers from devices and connected hierarchies of balancing_market . balancing_offers could be positive or negative. It also facilitates the balancing_trade .","title":"Balancing Market"},{"location":"balancing-market/#balancing-agent","text":"It listens to the spot_market_trade of its lower hierarchy. Whenever there is a trade in lower hierarchy of spot_market , it will to try secure a percentage of spot market trades in balancing market.","title":"Balancing Agent"},{"location":"balancing-market/#constant-parameters","text":"Following are the constant parameters related to balancing market ENABLE_BALANCING_MARKET \u2192 (Default: False) : enables the simulation with Balancing Market BALANCING_SPOT_TRADE_RATIO \u2192 (Default: 0.2) : dictates the ratio of spot_market_energy to be traded in balancing market BALANCING_OFFER_DEMAND_RATIO \u2192 (Default: 0.1) : dictates the ratio of spot_market_energy to be offered in balancing market as demand_balancing_offer BALANCING_OFFER_SUPPLY_RATIO \u2192 (Default: 0.1) : dictates the ratio of spot_market_energy to be offered in balancing market as supply_balancing_offer BALANCING_FLEXIBLE_LOADS_SUPPORT \u2192 (Default: True) : It enables Load Strategy to place supply_balancing_offer (effectively curtailing it's load)","title":"Constant Parameters"},{"location":"bills/","text":"All the cumulated bills of each area and device is reported in the JSON file \u201cbills.json\u201d at the end of the simulation. The bills are reported according to the various markets' point of view. In order to have a visual example, let\u2019s take this configuration : In this example we will simulate this configuration for one day using the Pay as Bid market type and the load only have to buy some energy at 12:00. Let\u2019s now see more precisely the only trade of the day and the propagation of the bid of the load and the offer of the DSO until they are matched : The bid and the offer is forwarded to the upper market (for more information on this process, please read the grid fees documentation ) and are matched in the Grid market with a clearing price (and trade price) of 0.45 \u20ac. In the bills.json file, bills will be reported multiple times according to the different market point of view.For each bill we will have the following structure : \u201cParent area\u201c: { \"Agent\": { \"bought\": Energy that has been bought during the simulation [kWh], \"sold\": Energy that has been sold during the simulation [kWh], \"spent\": Amount of money that has been spent in trades during the simulation [\u20ac] , \"earned\": Amount of money that has been earned in trades during the simulation [\u20ac], \"total_energy\": energy bought - energy sold [kWh], \"total_cost\": money spent in trades - money earned in trades [\u20ac], \"market_fee\": Money spent to the \u201cParent area\u201c as grid fees [\u20ac] , \"type\": Type of the agent. Can either be an Area or the name of the device strategy }, }, Now we will look at the results of our previous example. The first point of view is the highest market and in our case the Grid market : From the point of view of the Grid, the House 1 area has bought 1 kWh from the DSO and spent 0.375\u20ac in this trade. House 1 also pays the market fee that the Grid is charging : 0.075\u20ac. After that we go down in the hierarchy and look from the House 1 market : The House 1 market has no information on the other markets and this why from its point of view the Load has spent 0.45\u20ac (0.0375+0.075) for 1 kWh and no fees are added up because this market has no fee. At the very end of the results we have the bills of each device (from their point of view): With this we see that the Load, from his point of view has bought 1 kWh for 0.45\u20ac. From the point of view of the DSO, this latter only received 0.375\u20ac for 1 kWh.","title":"Bills"},{"location":"change-global-sim-settings/","text":"Editing Configuration Parameters \u00b6 There are default values (global constants) for configuration parameters, they can be set in the following way: There are two ways of changing global constants and settings via: setup-file (best option) d3a-settings.json 1. setup-file (best option): \u00b6 For the global update of configuration please see Setting Global Configuration Parameters section below. For setting the grid fee please consult How to configure grid transfer fee . The user can overwrite the configuration settings by changing the wanted variables of the ConstSettings class in the setup-file . For instance, if the user wants to set the market type to double-sided-market, and set the default min and max energy rate for all loads the following lines have to be added to the get_setup function: from d3a_interface.constants_limits import ConstSettings def get_setup(config): ConstSettings.IAASettings.MARKET_TYPE = 2 ConstSettings.LoadSettings.MIN_ENERGY_RATE = 0 ConstSettings.LoadSettings.MAX_ENERGY_RATE = 35 2. d3a-settings.json \u00b6 These global settings can also be parsed via a settings file in JSON format, that contains all constants in the advanced_settings branch. An example can be found here: src/d3a/setup/d3a-settings.json The settings JSON file can be parsed via the --settings-file keyword Setting Global Configuration Parameters \u00b6 Following parameters are part of SimualtionConfig and are initialised even before updating any ConstSettings : sim_duration slot_length tick_length market_count cloud_coverage * market_maker_rate * transfer_fee_pct * transfer_fee_const * pv_user_profile * max_panel_power_W In order to update the some of these parameters (starred in list above), please use update_config_parameters method to update the global config parameters in the setup file: def get_setup(config): config.update_config_parameters(transfer_fee_pct=5, transfer_fee_const=35, cloud_coverage=2, pv_user_profile=\"<path>/<profile_name>\", market_maker_rate=30) area = Area( 'Grid', [ Area('General Load', strategy=LoadHoursStrategy(avg_power_W=200, hrs_per_day=4, hrs_of_day=list(range(12, 16)), final_buying_rate=35), appliance=SwitchableAppliance()), Area('PV', strategy=PVStrategy(4, 80), appliance=PVAppliance()), ], config=config ) return area","title":"How to Change Global Simulation Settings"},{"location":"change-global-sim-settings/#editing-configuration-parameters","text":"There are default values (global constants) for configuration parameters, they can be set in the following way: There are two ways of changing global constants and settings via: setup-file (best option) d3a-settings.json","title":"Editing Configuration Parameters"},{"location":"change-global-sim-settings/#1-setup-file-best-option","text":"For the global update of configuration please see Setting Global Configuration Parameters section below. For setting the grid fee please consult How to configure grid transfer fee . The user can overwrite the configuration settings by changing the wanted variables of the ConstSettings class in the setup-file . For instance, if the user wants to set the market type to double-sided-market, and set the default min and max energy rate for all loads the following lines have to be added to the get_setup function: from d3a_interface.constants_limits import ConstSettings def get_setup(config): ConstSettings.IAASettings.MARKET_TYPE = 2 ConstSettings.LoadSettings.MIN_ENERGY_RATE = 0 ConstSettings.LoadSettings.MAX_ENERGY_RATE = 35","title":"1. setup-file (best option):"},{"location":"change-global-sim-settings/#2-d3a-settingsjson","text":"These global settings can also be parsed via a settings file in JSON format, that contains all constants in the advanced_settings branch. An example can be found here: src/d3a/setup/d3a-settings.json The settings JSON file can be parsed via the --settings-file keyword","title":"2. d3a-settings.json"},{"location":"change-global-sim-settings/#setting-global-configuration-parameters","text":"Following parameters are part of SimualtionConfig and are initialised even before updating any ConstSettings : sim_duration slot_length tick_length market_count cloud_coverage * market_maker_rate * transfer_fee_pct * transfer_fee_const * pv_user_profile * max_panel_power_W In order to update the some of these parameters (starred in list above), please use update_config_parameters method to update the global config parameters in the setup file: def get_setup(config): config.update_config_parameters(transfer_fee_pct=5, transfer_fee_const=35, cloud_coverage=2, pv_user_profile=\"<path>/<profile_name>\", market_maker_rate=30) area = Area( 'Grid', [ Area('General Load', strategy=LoadHoursStrategy(avg_power_W=200, hrs_per_day=4, hrs_of_day=list(range(12, 16)), final_buying_rate=35), appliance=SwitchableAppliance()), Area('PV', strategy=PVStrategy(4, 80), appliance=PVAppliance()), ], config=config ) return area","title":"Setting Global Configuration Parameters"},{"location":"clearingtoken-smart-contract/","text":"The ClearingToken smart contract is responsible for keeping and updating the token balance for every user of the blockchain. The idea behind this contract is that every market that wants to perform energy trading needs to be approved first by a central authority. There are 2 main non-view functions that this smart contract exposes: globallyApprove() : Is used for approving one clearing member (market). This needs to be executed before a market starts trading, otherwise the trade function of the Market smart contract will always fail. A subsequent event will be emitted ( ApproveClearingMember event) which will notify the listeners of this contract about the market being approved. clearingTransfer() : Is used for transferring tokens from the buyer to the seller, keeping and updating the token balance amongst all simulation participants. Validates that the market that called this function is an approved clearing member, and if yes, performs the token exchange, if not nothing happens and the caller gets notified about the failed token transfer.","title":"ClearingToken Smart Contract"},{"location":"configure-transfer-fee/","text":"There are two fees that can be added to every trade in the grid: percentage transfer fee (in %) constant transfer fee (in cents/kWh) The formula for the increased trade price is: offer/bid_price * (1 + transfer_fee_pct/100 ) + transfer_fee_const A percentage transfer fee (in %) and the constant transfer fee (in cents/kWh) can be configured for each area individually in the setup file with the keyword transfer_fee_pct and transfer_fee_const : Area( 'House 1', [ Area('H1 General Load', strategy=LoadHoursStrategy(avg_power_W=200, hrs_per_day=6, final_buying_rate=35), appliance=SwitchableAppliance()), Area('H1 Storage1', strategy=StorageStrategy(initial_capacity_kWh=0.6), appliance=SwitchableAppliance()), ], transfer_fee_pct=1, transfer_fee_const=2, ), If no transfer_fee_pct or transfer_fee_const is provided, the global values of transfer_fee_pct or transfer_fee_const is used (set via the update_config_parameters function, see Setting Global Configuration Parameters ) If none of these is set, the const.IAASettings.FEE_PERCENTAGE or const.IAASettings.FEE_CONSTANT values are applied to all areas.","title":"How to Configure Grid Transfer Fee"},{"location":"create-setup-file/","text":"The user parses the grid architecture and settings to the d3a simulation via a setup-file. In this setup-file, global and strategy related settings can be set. Examples can be found in: d3a/src/d3a/setup/ This is the most basic skeleton for a setup-file: from d3a.models.area import Area def get_setup(config): area = Area('Grid', []) return area Now the user can ad more sub areas recursively by adding more instances of area to the second parameter (list) of the Area class. If the strategy parameter is set in the Area class, the area is converted to a leaf node, e.g. a load. The following grid architecture is given: Grid House 1 H1 General Load H1 Storage 1 H1 Storage 2 House 2 H2 General Load Cell Tower ( Bold instances are areas, not devices. For each of these non-device areas, an inter-area-agent is created in the background that deals with offer/bid forwarding and matching.) In the following, the corresponding setup-file is shown. from d3a.models.appliance.switchable import SwitchableAppliance from d3a.models.area import Area from d3a.models.strategy.storage import StorageStrategy from d3a.models.strategy.load_hours import CellTowerLoadHoursStrategy, LoadHoursStrategy from d3a.models.appliance.pv import PVAppliance from d3a.models.strategy.pv import PVStrategy def get_setup(config): area = Area( 'Grid', [ Area( 'House 1', [ Area('H1 General Load', strategy=LoadHoursStrategy(avg_power_W=200, hrs_per_day=6, hrs_of_day=list( range(12, 18)), final_buying_rate=35), appliance=SwitchableAppliance()), Area('H1 Storage1', strategy=StorageStrategy(initial_soc=50), appliance=SwitchableAppliance()), Area('H1 Storage2', strategy=StorageStrategy(initial_soc=50), appliance=SwitchableAppliance()), ], transfer_fee_pct=0, transfer_fee_const=0, ), Area( 'House 2', [ Area('H2 General Load', strategy=LoadHoursStrategy(avg_power_W=200, hrs_per_day=4, hrs_of_day=list( range(12, 16)), final_buying_rate=35), appliance=SwitchableAppliance()), Area('H2 PV', strategy=PVStrategy(panel_count=4, initial_selling_rate=30, final_selling_rate=5), appliance=PVAppliance()), ], transfer_fee_pct=0, transfer_fee_const=0, ), Area('Cell Tower', strategy=CellTowerLoadHoursStrategy(avg_power_W=100, hrs_per_day=24, hrs_of_day=list(range(0, 24)), final_buying_rate=35), appliance=SwitchableAppliance()), ], config=config ) return area","title":"How to Create a setup-file"},{"location":"custom-load-strategy/","text":"Instead of configuring the demand behaviour of a load through through avg_power_W , hrs_of_day and hrs_per_day (as described in \" Load Strategy \"), the user can also upload their own load profile in Watts in the backend. The user can do this by uploading a .csv file or inputing the profile directly in the grid configuration (setup) file. There are two demonstration setup files to show this feature: user_profile_load_csv.py In this setup file, the csv file is connected to the configuration via a pathway : user_profile_path = os.path.join(d3a_path,\"resources/LOAD_DATA_1.csv\") Comma or semicolon separated values are allowed. The timestamp can be provided in two formats: HH:mm , YYYY-MM-DDTHH:mm . For more information on what format is accepted by the D3A, see \" Upload File Formats \". user_profile_load_dict.py In this setup file, the user profile is inserted directly into the configuration: user_profile = { 8: 100, 9: 200, 10: 50, 11: 80, 12: 120, 13: 20, 14: 70, 15: 15, 16: 45, 17: 100 } Corresponding code: /src/3a/models/strategy/predefined_load.py How to add a load device with custom profile to the setup-file: user_profile = { 8: 100, 9: 200, 10: 50, 11: 80, 12: 120, 13: 20, 14: 70, 15: 15, 16: 45, 17: 100 } Area('DefinedLoad', strategy=DefinedLoadStrategy(daily_load_profile=user_profile, max_energy_rate=35), appliance=SwitchableAppliance()),","title":"Custom Load Strategy"},{"location":"custom-pv-strategy/","text":"Instead of a pre-configured file, the user can also upload their own PV profile in Watts in the backend. The user can do this by uploading a csv file or inputing the profile directly in the grid configuration (setup) file. There are two demonstration setup files to show this feature: user_profile_pv_csv.py In this setup file, the csv file is connected to the configuration via a pathway: user_profile_path = os.path.join(d3a_path,\"resources/Solar_Curve_W_sunny.csv\") Comma or semicolon separated values are allowed. The timestamp can be provided in two formats: HH:mm , YYYY-MM-DDTHH:mm . For more information on what format is accepted by the D3A, see \" Upload File Formats \". user_profile_pv_dict.py In this setup file, the user profile is inserted directly into the configuration: user_profile = { 8: 100, 9: 200, 10: 50, 11: 80, 12: 120, 13: 20, 14: 70, 15: 15, 16: 45, 17: 100 } Corresponding code: src/d3a/models/strategy/predefined_pv.py How to add a PV device with custom profile to the setup-file: user_profile_path = os.path.join(d3a_path, \"resources/Solar_Curve_W_sunny.csv\") Area('H1 PV', strategy=PVUserProfileStrategy(power_profile=user_profile_path, panel_count=), appliance=PVAppliance()),","title":"Custom PV Strategy"},{"location":"d3a-blockchain-support/","text":"Currently D3A has optional blockchain support, meaning that instead of the Python-simulated blockchain, a private blockchain can be used instead. Currently ganache-cli is used by default, and it is installed when d3a is installed (via fab sync command), but it is also possible to use your own blockchain that is running on your local machine or on a remote machine. The Solidity version that is used for the smart contracts is 0.4.25, which is also installed automatically with fab sync. There are 3 configuration parameters that control whether D3A is using blockchain, and which blockchain it uses (the default D3A blockchain, your own local blockchain, or a remote one). The most important one is the command-line option --enable-bc . This starts a simulation using a real blockchain, instead of using the simulated blockchain. Besides the command line option, there are 2 more configuration parameters that control the blockchain behavior, both of which are located in const.py (and are configurable for the end user via the advanced settings configuration file). First one is BLOCKCHAIN_START_LOCAL_CHAIN , which, if set to True , starts automatically a local chain (using ganache-cli) on the background when D3A starts. If it is desirable to circumvent this behavior, and use a different blockchain, then this option should be set to False . The second configuration setting is BLOCKCHAIN_URL , which defines the URL of the blockchain that is used by D3A. The default value is \" http://127.0.0.1:8545 \", which is the URL of a ganache-cli blockchain installed on localhost. In case the blockchain account that is going to be used requires a password in order to unlock, the password can be provided using the environment variable BLOCKCHAIN_ACCOUNT_PASSWORD , otherwise a default password of \" testgsy \" will be used if this variable is not set.","title":"D3A Blockchain Overview"},{"location":"d3a-documentation/","text":"This is the wiki of the D3A (Decentralized Autonomous Area Agent) which is being developed by Grid Singularity as an interface and codebase to model, simulate, optimize and (coming soon) download and deploy a custom energy exchange. The wiki is divided into three parts: User Interface (d3a.io) which concerns the usage and behavior of the browser app at d3a.io (front-end) Backend Codebase which is the master wiki for the open source backend code that can be downloaded here: https://github.com/gridsingularity/d3a FAQ for commonly asked questions","title":"Overview"},{"location":"ess-strategy/","text":"The ESS can buy or sell energy. For all cases the initial parameters of the battery can be defined: initial_soc : Initial battery SOC (State of Charge) in %. min_allowed_soc: It is the minimum SOC level in % below which the storage bank is never drawn battery_capacity_kWh : size of the battery (default value: 1.2 kWh) max_abs_battery_power_kW : maximum power rating for battery charge/discharge, (default value: 5 kW) Rate settings: update_interval : time after which the rate should be updated (type: pendulum duration object) initial_selling_rate : The maximum starting point of offer rate (ct/kWh) final_selling_rate : The minimum ending point of offer rate (ct/kWh) initial_buying_rate : The minimum starting point of bid rate (ct/kWh) final_buying_rate : The maximum ending point of bid rate (ct/kWh) energy_rate_decrease_per_update : configured as the cents/kWh decrease per update (default value: 1 cent/kWh per update). fit_to_limit: derive bidding behaviour from a linear fitted curve of a buying rate between initial_buying_rate and final_buying_rate (boolean value) within the bidding interval. If activated, energy_rate_increase_per_update = (final_buying_rate - initial_buying_rate) / (market_interval_length / update_interval) . cap_price_strategy : the ESS can trade energy based on a capacity dependent sell price (Default: False , set to True to activate). See Addendum on this page for more information. In order to enable ESS to participate in balancing market, a prerequisite is to add the ESS device in \" Device Registry \" and set the following parameters: balancing_energy_ratio : the first value dictates the ratio of energy to be charged from balancing market. The second value dictates the ratio of energy to be discharge to balancing market (default value: tuple(0.1, 0.1)) Corresponding code: src/3a/models/strategy/storage.py How to add a Storage device to the setup-file: Area('Storage', strategy=StorageStrategy(initial_soc=50, energy_rate_decrease_per_update=3, battery_capacity_kWh=1.2, max_abs_battery_power_kW=5, final_buying_rate=16.99, final_selling_rate= 17.01)), appliance=SwitchableAppliance()), Addendum: ESS Capacity Based Method \u00b6 This method was created to sell energy at lower prices during high SOC (when the battery has more energy stored) and at higher prices during low SOC (when the battery can afford to sell its stores less). If the cap_price_strategy is true, the offer price for the ESS is calculated according to: offer_rate = initial_selling_rate - ((initial_selling_rate - final_selling_rate)\\*soc/100) As an example, considering an initial_selling_rate of 30 cents/kWh and a final_selling_rate price of 20 cents/kWh, an ESS with an SOC of 1% would sell its energy at 29.9 cents/kWh, and a battery at 100% SOC would sell its energy at 20 cents/kWh. General Behaviour \u00b6 In general all offers and bids follow the physical constraint of the set max_abs_battery_power_kW Value. The accumulated energy per market slot can not exceed this power value. Here selling and buying cancel each other out meaning that if 2kWh are both sold and bought in the same market slot, the relative power is still 0. For the buying rate increase and selling rate decrease behaviour, please see: How the Strategies Adjust the Prices of Offers and Bids . Buying Energy \u00b6 One Sided Market \u00b6 On every tick, the storage scans the connected market for affordable offers* if there is storage space to be filled (if the current SOC is lower than 100%). Once an offer is found, it is either fully or partially accepted, depending on the demand. The storage always seeks for 100% SOC when buying energy. * = affordable offers are offers that have a price lower or equal the current acceptable energy rate. The acceptable energy rate changes in the frame of one market slot depending on the initial_buying_rate , final_buying_rate , energy_rate_decrease_per_update and update_interval setting . Two Sided Market \u00b6 On every tick, the storage either places a bid for the energy portion it needs to reach 100% SOC or updates the price of an existing bid in the market where the bid price is depending on the initial_buying_rate , final_buying_rate , energy_rate_decrease_per_update and update_interval setting . Selling Energy \u00b6 At the beginning of each slot market, the storage places an offer on the market offering all the energy it has stored (not including the energy that is needed to keep the storage at least at min_allowed_soc ). This offer gets updated on every tick following the rate decrease settings. This applies to both one and two sided market types. Consequently, it is possible for the storage to have both an offer and a bid placed in the same market.","title":"Energy Storage System (ESS) Strategy"},{"location":"ess-strategy/#addendum-ess-capacity-based-method","text":"This method was created to sell energy at lower prices during high SOC (when the battery has more energy stored) and at higher prices during low SOC (when the battery can afford to sell its stores less). If the cap_price_strategy is true, the offer price for the ESS is calculated according to: offer_rate = initial_selling_rate - ((initial_selling_rate - final_selling_rate)\\*soc/100) As an example, considering an initial_selling_rate of 30 cents/kWh and a final_selling_rate price of 20 cents/kWh, an ESS with an SOC of 1% would sell its energy at 29.9 cents/kWh, and a battery at 100% SOC would sell its energy at 20 cents/kWh.","title":"Addendum: ESS Capacity Based Method"},{"location":"ess-strategy/#general-behaviour","text":"In general all offers and bids follow the physical constraint of the set max_abs_battery_power_kW Value. The accumulated energy per market slot can not exceed this power value. Here selling and buying cancel each other out meaning that if 2kWh are both sold and bought in the same market slot, the relative power is still 0. For the buying rate increase and selling rate decrease behaviour, please see: How the Strategies Adjust the Prices of Offers and Bids .","title":"General Behaviour"},{"location":"ess-strategy/#buying-energy","text":"","title":"Buying Energy"},{"location":"ess-strategy/#one-sided-market","text":"On every tick, the storage scans the connected market for affordable offers* if there is storage space to be filled (if the current SOC is lower than 100%). Once an offer is found, it is either fully or partially accepted, depending on the demand. The storage always seeks for 100% SOC when buying energy. * = affordable offers are offers that have a price lower or equal the current acceptable energy rate. The acceptable energy rate changes in the frame of one market slot depending on the initial_buying_rate , final_buying_rate , energy_rate_decrease_per_update and update_interval setting .","title":"One Sided Market"},{"location":"ess-strategy/#two-sided-market","text":"On every tick, the storage either places a bid for the energy portion it needs to reach 100% SOC or updates the price of an existing bid in the market where the bid price is depending on the initial_buying_rate , final_buying_rate , energy_rate_decrease_per_update and update_interval setting .","title":"Two Sided Market"},{"location":"ess-strategy/#selling-energy","text":"At the beginning of each slot market, the storage places an offer on the market offering all the energy it has stored (not including the energy that is needed to keep the storage at least at min_allowed_soc ). This offer gets updated on every tick following the rate decrease settings. This applies to both one and two sided market types. Consequently, it is possible for the storage to have both an offer and a bid placed in the same market.","title":"Selling Energy"},{"location":"faq/","text":"This list of frequently asked questions (faq) is updated gradually, by adding the questions that come up on our gitter community chat D3A Functionality \u00b6 What is the D3A ? \u00b6 The D3A is an energy exchange engine. It is an open source software, enabling users to model, simulate, optimise, download, and deploy their own energy exchanges. The D3A is designed to build \u201cdigital twin\u201d representations of physical energy systems and energy markets. It aims to build open energy exchanges, extending access for new energy players, a class which is growing due to increased investments in distributed energy resources and smart devices. By creating energy exchanges from bottom to top, smart, local, and flexible devices as well as distributed renewable generation can be monetised for a faster transition to 100% renewable energy. The D3A simulation engine is currently available in two formats - the open source backend code , and the user friendly frontend User Interface (UI) . What are the possible use cases to simulate with the D3A ? \u00b6 The D3A is an energy exchange engine capable of simulating (and after further development facilitating) power flows and energy transactions in local marketplaces. The D3A showcases and harnesses the potential of transactive grids, renewable energy sources (RES) and peer to peer (P2P) energy trading for all stakeholders in the energy transition and can have multiple applications, including the following use cases. Community as a Service . Creates a local energy market within the grid-tied community and allows all energy assets (e.g. residential rooftop solar) equal access to market alongside traditional energy providers. This enables prosumers to participate actively in the energy market by trading locally before buying from or selling to the grid provider. Energy Access . Creates a local energy market within an islanded microgrid energy community . This allows for a more optimal microgrid configuration. To see an example of use case of \u201cCommunity as a Service\u201d with the D3A engine, please read our Medium article and watch our presentation from Event Horizon 2019 here . Both the \u201cCommunity as a Service\u201d and \u201cEnergy Access\u201d use cases are available as public projects at d3a.io . Do the D3A frontend and the backend have the same functionalities ? \u00b6 The backend code offers the full functionality of the active version of the D3A. The frontend User Interface (UI) offers a user friendly interface to the majority of features found in the backend. New features are typically developed in the backend first and are made available in the UI after internal testing for usability and accuracy. Frontend / User Interface at d3a.io \u00b6 How do I setup a simulation in the frontend ? \u00b6 To start using the D3A you need to register your account. The D3A team will approve accounts in one business day. You will then be asked to confirm your email to enable login. You can design your own project by clicking on \u201cnew project\u201d and then create a new simulation in it. The first step in setting up a simulation is to define the simulation settings. You can set the simulation duration, the solar profile type, the market type, and other relevant parameters. In the D3A you can choose one of the 3 market types available : single-sided pay as offer, two-sided pay as bid and two-sided pay as clear (for more information on the simulation settings please follow this link ). The next step is to design your grid. Once you arrive in the grid setup, the first thing that you will have to do is to define the market maker. Its goal is to represent a static or fluctuating base market price which will serve as a reference point for the selected device strategies. After creating this market maker, you can start building the digital twin of your grid. The D3A works by creating area markets. In each of these areas you can put devices or other grid areas. The devices can be loads, PV, storage, etc. The setup is intended to represent the physical architecture of the real energy market (country, region, neighbourhood, house, etc.). Importantly, each area contains a spot market where trades can occur. Each device places a bid/offer in their home market. When bids/offers are not matched in their own area, they are forwarded to the upper market in the upper area and so on. After your grid setup is complete, you can run your simulation. When it is finished you can view multiple scrollable plots and tables on the results page (for more on how to use these visuals, please see this link ) and you can also download the results file on your computer. For a step-by-step explanation on how to setup your simulation, please watch our tutorial . You can also see a video explaining the new release features implemented on the frontend here . If you have any other problems, please visit our documentation wiki page for the frontend and the backend D3A versions. Are there any limitations concerning the size of the simulation ? \u00b6 For smoother simulations and smaller queue, we have set some boundaries. First, the simulations are limited in their duration. You can currently set the duration from 1 to 7 days. Furthermore, the number of agents allowed per simulation is limited. Each device and area is considered as an agent and you can define up to 250 of these. Backend Codebase \u00b6 How do I setup a simulation in the backend ? \u00b6 There is no need to login to set up a simulation in the backend. You just need to follow the steps bellow : Download the code from our GitHub Repository . Please follow the technical instructions here to correctly install the D3A on your computer. To design a grid setup, please create a python file and follow our tips on how to setup file and global settings . You can also review our setup examples located at d3a/src/d3a/setup/ . To run a setup file you need to place it in the directory d3a/src/d3a/setup/ , or change the path yourself in the ConstSettings.py file. To launch the simulation in the command line interface, follow our technical instructions . Why do my results keep changing when I rerun the same setup ? \u00b6 This is caused by the random seed number. This number controls the randomness of the market, the bids, offers and the trades. If you have not defined this number, at each simulation a new random seed number will be generated and therefore you will keep observing different results (for example the trades between the areas and the storage SOC can vary). To set the random seed number you have to add this in the simulation launch command line interface --seed TEXT. By doing so, the randomness of the simulation will be frozen and your results won\u2019t change anymore. I am creating a long simulation (week/month/year) and would like to establish my spot market in the day ahead. Is this possible or is it frozen/strictly at 15 minutes ahead ? \u00b6 No, for now you cannot establish your spot market in the day ahead, but you can choose the number of tradable market slots into the future. This will allow your devices to trade in multiple future spot markets. To enable this functionality, you have to add to your simulation a launch command -m number_of_tradable_markets. The size of the market slot is configurable. You can change the market slot length of 15 minutes to be any integer between 2 minutes and 60 minutes. I am using the energy storage system (ESS) to represent a compressed air storage (with an electric-to-electric efficiency of 50%). How can I implement the efficiency in the ESS component ? \u00b6 For the time being, the storage component has a 100% electric-to-electric efficiency by default. Changing this characteristic is not possible at the moment but it will be possible in the near future. Users are welcome to add additional features to our open source code base on GitHub. I have created a setup with 2 identical areas. I would like to know how the d3a works if one area is prioritised over the other during clearing. Does it change when I change the random seed number ? \u00b6 If two areas are completely identical i.e post the same offer/bid, the market will randomly choose one of them. You can control this randomness by changing the random seed number in the launch CLI by adding --seed TEXT. I would like to study a structure with multiple microgrids exchanging energy based on a two sided market pay as clear. Furthermore, I would like that the exchanges inside microgrids (between houses) be based on a two sided market pay as bid. Can I setup such a structure with multiple market types inside one simulation ? \u00b6 No, for now that is not possible. You can only have one market type per simulation. In my simulations results, sometimes an area/device is both a seller and a buyer at the same time. Why does this happen ? \u00b6 Sometimes areas can be both a seller and a buyer at the same time. This is explained by the open market. It happens that loads in the area are not fast enough to place bids to buy their own generation. This also happens because of the device\u2019s strategy. If other loads (outside of the area) have the same buying rate as the load inside the area (and there are no grid fees), they can possibly \u201csteal\u201d the offers. To avoid this, you have to change the strategies and/or add grid fees in your simulation. This will help to prioritise self consumption inside each area. I am creating a simulation with one load and one generation and I am using the two sided market pay as clear. Sometimes, when my generation is lower than my demand, there are no trades at all. What is the reason for that ? \u00b6 The two sided market pay as clear is cleared if at least one bid is satisfied. For example in your case, since your only bid is not entirely satisfied, the market will not clear and therefore there won\u2019t be any trades. Can I configure all types of grid topography from meshed to radial under the same voltage level ? \u00b6 The D3A is designed for radial and hierarchical grid structures. Other topography types might be possible as long as they do not contain \"cycles\" (essentially closed loops in the grid structure). What you cannot currently simulate are loop networks, like rings. If I have a use case that has both residential consumers at 240V and industrial customers at 415V or higher, how can I set this up ? \u00b6 For now, voltage level is irrelevant, meaning that the D3A only simulate the amounts of energy transferred between each node (this will become important once we implement imbalances, differences between consumption and generation, which impact the frequency and the voltage of the grid). You can now simulate a grid that contains both residential and industrial consumers ignoring voltage limitations by taking for granted that the step-up transformers and transmission lines power rating will not be violated (since D3A does not check this for now). This will change once the power flows feature is implemented. By adding this new functionality, the electrical properties of the grid will be represented and used in the simulations. We recommend that each level of the D3A is tied to a specific grid voltage, so that each voltage level has its own market. How are the grid fees applied ? How do I set them up ? \u00b6 The grid fees represent the cost of the grid, taxes and other fees that are paid to another entity in exchange for using the grid. You can look at this page to see how you can set this up. When you define grid fees, it is applied inside of the specific area. These fees will be applied on the offers and bids, by raising or lowering their prices. Consequently, when an offer is published, its selling price will be the one defined by the seller plus the relevant grid fees. For trades to occur, the bid price minus the expected grid fees should be higher than the selling price plus the expected grid fees (for the two sided markets). Use of Blockchain \u00b6 Does D3A use blockchain technology ? \u00b6 The D3A has been designed so that it does not require blockchain technology but that it can benefit from this technology to provide enhanced functionality. Namely, if D3A-enabled deployment of energy markets is implemented via blockchain smart contracts there is full transparency of transactions, placing full trust in fair collaboration of energy actors rather than one actor having a market advantage. What are the current technological limitations for D3A\u2019s blockchain implementation and possible solutions ? \u00b6 The main limitation relates to scale or transactions throughput per second. We have tested the D3A on the ganache\u2019s private blockchain and it works only with increased simulation time as the processing is slower than when using the Python interpreter. The Energy Web Chain , designed especially for energy sector, is more efficient and less costly (in terms of transaction fees) than any other available public platform and hence would be the current blockchain of choice. As one single blockchain may never be able to handle the number and size of transactions of a large electrical grid, one solution to the problem lies in the interoperability of blockchains, with each responsible for one grid/area. This solution is proposed by the Polkadot Network , which will be launched and tested in 2020. In this scenario, the Energy Web Chain 2.0 could act as the relay chain for parachains for specific domains i.e. grid areas. Considering the hierarchical nature of the D3A market structure, do you look for special features on the blockchain for D3A to work more efficiently ? \u00b6 As D3A is hierarchical in design, there is a need of hierarchies of blockchain that specifically handle their own local grid/area. The Polkadot Network is therefore well suited for future D3A implementation. Grid Singularity\u2019s Approach \u00b6 Why is the D3A open source ? \u00b6 We believe that disruptive innovation that will lead us to new solutions to bring about the energy transition can not be achieved with private projects but rather with an open source community where everyone can contribute value, opportunities and challenges. The GPLv.3 license protects our code in a way that anyone who wishes to pursue proprietary commercialisation of the software would need to apply for a license, while open source applications continue to be free. What is the link between Grid Singularity and Energy Web Foundation ? \u00b6 Grid Singularity, an energy technology startup, and the Rocky Mountain Institute, a nonprofit clean technology organisation, jointly founded the Energy Web Foundation (EWF) in January 2017. EWF is a nonprofit foundation gathering an ecosystem of over 100 energy corporates and startups with a shared, public blockchain platform, the Energy Web Chain. While Grid Singularity has significantly contributed to EWF development and the launch of the Energy Web Chain, its role today is supervisory and advisory, with two Grid Singularity representatives serving on the EWF\u2019s Foundation Council. The Energy Web Chain is the blockchain of choice for D3A\u2019s future blockchain implementation. What are the future development plans ? \u00b6 We have partnered with innovative energy companies to facilitate further D3A development in the framework of the Odyssey 2020 Energy Singularity Track led by Grid Singularity. We will also work on some specific market simulation studies with partners to demonstrate the value of local energy markets. Following Odyssey Hackathon in April, we plan to deploy the D3A engine on real smart-meters to allow trades in a neighbourhood by the end of 2020 as part of a pilot project. If I have questions regarding the D3A use, how can I contact you ? \u00b6 Please first review our wiki page documentation on the UI and the backend code. The best way to engage with us is via the D3A community/ecosystem channel on Gitter . For any additional comments/feedback you can also send us an email at d3a@gridsingularity.com .","title":"FAQ"},{"location":"faq/#d3a-functionality","text":"","title":"D3A Functionality"},{"location":"faq/#what-is-the-d3a","text":"The D3A is an energy exchange engine. It is an open source software, enabling users to model, simulate, optimise, download, and deploy their own energy exchanges. The D3A is designed to build \u201cdigital twin\u201d representations of physical energy systems and energy markets. It aims to build open energy exchanges, extending access for new energy players, a class which is growing due to increased investments in distributed energy resources and smart devices. By creating energy exchanges from bottom to top, smart, local, and flexible devices as well as distributed renewable generation can be monetised for a faster transition to 100% renewable energy. The D3A simulation engine is currently available in two formats - the open source backend code , and the user friendly frontend User Interface (UI) .","title":"What is the D3A ?"},{"location":"faq/#what-are-the-possible-use-cases-to-simulate-with-the-d3a","text":"The D3A is an energy exchange engine capable of simulating (and after further development facilitating) power flows and energy transactions in local marketplaces. The D3A showcases and harnesses the potential of transactive grids, renewable energy sources (RES) and peer to peer (P2P) energy trading for all stakeholders in the energy transition and can have multiple applications, including the following use cases. Community as a Service . Creates a local energy market within the grid-tied community and allows all energy assets (e.g. residential rooftop solar) equal access to market alongside traditional energy providers. This enables prosumers to participate actively in the energy market by trading locally before buying from or selling to the grid provider. Energy Access . Creates a local energy market within an islanded microgrid energy community . This allows for a more optimal microgrid configuration. To see an example of use case of \u201cCommunity as a Service\u201d with the D3A engine, please read our Medium article and watch our presentation from Event Horizon 2019 here . Both the \u201cCommunity as a Service\u201d and \u201cEnergy Access\u201d use cases are available as public projects at d3a.io .","title":"What are the possible use cases to simulate with the D3A ?"},{"location":"faq/#do-the-d3a-frontend-and-the-backend-have-the-same-functionalities","text":"The backend code offers the full functionality of the active version of the D3A. The frontend User Interface (UI) offers a user friendly interface to the majority of features found in the backend. New features are typically developed in the backend first and are made available in the UI after internal testing for usability and accuracy.","title":"Do the D3A frontend and the backend have the same functionalities ?"},{"location":"faq/#frontend-user-interface-at-d3aio","text":"","title":"Frontend / User Interface at d3a.io"},{"location":"faq/#how-do-i-setup-a-simulation-in-the-frontend","text":"To start using the D3A you need to register your account. The D3A team will approve accounts in one business day. You will then be asked to confirm your email to enable login. You can design your own project by clicking on \u201cnew project\u201d and then create a new simulation in it. The first step in setting up a simulation is to define the simulation settings. You can set the simulation duration, the solar profile type, the market type, and other relevant parameters. In the D3A you can choose one of the 3 market types available : single-sided pay as offer, two-sided pay as bid and two-sided pay as clear (for more information on the simulation settings please follow this link ). The next step is to design your grid. Once you arrive in the grid setup, the first thing that you will have to do is to define the market maker. Its goal is to represent a static or fluctuating base market price which will serve as a reference point for the selected device strategies. After creating this market maker, you can start building the digital twin of your grid. The D3A works by creating area markets. In each of these areas you can put devices or other grid areas. The devices can be loads, PV, storage, etc. The setup is intended to represent the physical architecture of the real energy market (country, region, neighbourhood, house, etc.). Importantly, each area contains a spot market where trades can occur. Each device places a bid/offer in their home market. When bids/offers are not matched in their own area, they are forwarded to the upper market in the upper area and so on. After your grid setup is complete, you can run your simulation. When it is finished you can view multiple scrollable plots and tables on the results page (for more on how to use these visuals, please see this link ) and you can also download the results file on your computer. For a step-by-step explanation on how to setup your simulation, please watch our tutorial . You can also see a video explaining the new release features implemented on the frontend here . If you have any other problems, please visit our documentation wiki page for the frontend and the backend D3A versions.","title":"How do I setup a simulation in the frontend ?"},{"location":"faq/#are-there-any-limitations-concerning-the-size-of-the-simulation","text":"For smoother simulations and smaller queue, we have set some boundaries. First, the simulations are limited in their duration. You can currently set the duration from 1 to 7 days. Furthermore, the number of agents allowed per simulation is limited. Each device and area is considered as an agent and you can define up to 250 of these.","title":"Are there any limitations concerning the size of the simulation ?"},{"location":"faq/#backend-codebase","text":"","title":"Backend Codebase"},{"location":"faq/#how-do-i-setup-a-simulation-in-the-backend","text":"There is no need to login to set up a simulation in the backend. You just need to follow the steps bellow : Download the code from our GitHub Repository . Please follow the technical instructions here to correctly install the D3A on your computer. To design a grid setup, please create a python file and follow our tips on how to setup file and global settings . You can also review our setup examples located at d3a/src/d3a/setup/ . To run a setup file you need to place it in the directory d3a/src/d3a/setup/ , or change the path yourself in the ConstSettings.py file. To launch the simulation in the command line interface, follow our technical instructions .","title":"How do I setup a simulation in the backend ?"},{"location":"faq/#why-do-my-results-keep-changing-when-i-rerun-the-same-setup","text":"This is caused by the random seed number. This number controls the randomness of the market, the bids, offers and the trades. If you have not defined this number, at each simulation a new random seed number will be generated and therefore you will keep observing different results (for example the trades between the areas and the storage SOC can vary). To set the random seed number you have to add this in the simulation launch command line interface --seed TEXT. By doing so, the randomness of the simulation will be frozen and your results won\u2019t change anymore.","title":"Why do my results keep changing when I rerun the same setup ?"},{"location":"faq/#i-am-creating-a-long-simulation-weekmonthyear-and-would-like-to-establish-my-spot-market-in-the-day-ahead-is-this-possible-or-is-it-frozenstrictly-at-15-minutes-ahead","text":"No, for now you cannot establish your spot market in the day ahead, but you can choose the number of tradable market slots into the future. This will allow your devices to trade in multiple future spot markets. To enable this functionality, you have to add to your simulation a launch command -m number_of_tradable_markets. The size of the market slot is configurable. You can change the market slot length of 15 minutes to be any integer between 2 minutes and 60 minutes.","title":"I am creating a long simulation (week/month/year) and would like to establish my spot market in the day ahead. Is this possible or is it frozen/strictly at 15 minutes ahead ?"},{"location":"faq/#i-am-using-the-energy-storage-system-ess-to-represent-a-compressed-air-storage-with-an-electric-to-electric-efficiency-of-50-how-can-i-implement-the-efficiency-in-the-ess-component","text":"For the time being, the storage component has a 100% electric-to-electric efficiency by default. Changing this characteristic is not possible at the moment but it will be possible in the near future. Users are welcome to add additional features to our open source code base on GitHub.","title":"I am using the energy storage system (ESS) to represent a compressed air storage (with an electric-to-electric efficiency of 50%). How can I implement the efficiency in the ESS component ?"},{"location":"faq/#i-have-created-a-setup-with-2-identical-areas-i-would-like-to-know-how-the-d3a-works-if-one-area-is-prioritised-over-the-other-during-clearing-does-it-change-when-i-change-the-random-seed-number","text":"If two areas are completely identical i.e post the same offer/bid, the market will randomly choose one of them. You can control this randomness by changing the random seed number in the launch CLI by adding --seed TEXT.","title":"I have created a setup with 2 identical areas. I would like to know how the d3a works if one area is prioritised over the other during clearing. Does it change when I change the random seed number ?"},{"location":"faq/#i-would-like-to-study-a-structure-with-multiple-microgrids-exchanging-energy-based-on-a-two-sided-market-pay-as-clear-furthermore-i-would-like-that-the-exchanges-inside-microgrids-between-houses-be-based-on-a-two-sided-market-pay-as-bid-can-i-setup-such-a-structure-with-multiple-market-types-inside-one-simulation","text":"No, for now that is not possible. You can only have one market type per simulation.","title":"I would like to study a structure with multiple microgrids exchanging energy based on a two sided market pay as clear. Furthermore, I would like that the exchanges inside microgrids (between houses) be based on a two sided market pay as bid. Can I setup such a structure with multiple market types inside one simulation ?"},{"location":"faq/#in-my-simulations-results-sometimes-an-areadevice-is-both-a-seller-and-a-buyer-at-the-same-time-why-does-this-happen","text":"Sometimes areas can be both a seller and a buyer at the same time. This is explained by the open market. It happens that loads in the area are not fast enough to place bids to buy their own generation. This also happens because of the device\u2019s strategy. If other loads (outside of the area) have the same buying rate as the load inside the area (and there are no grid fees), they can possibly \u201csteal\u201d the offers. To avoid this, you have to change the strategies and/or add grid fees in your simulation. This will help to prioritise self consumption inside each area.","title":"In my simulations results, sometimes an area/device is both a seller and a buyer at the same time. Why does this happen ?"},{"location":"faq/#i-am-creating-a-simulation-with-one-load-and-one-generation-and-i-am-using-the-two-sided-market-pay-as-clear-sometimes-when-my-generation-is-lower-than-my-demand-there-are-no-trades-at-all-what-is-the-reason-for-that","text":"The two sided market pay as clear is cleared if at least one bid is satisfied. For example in your case, since your only bid is not entirely satisfied, the market will not clear and therefore there won\u2019t be any trades.","title":"I am creating a simulation with one load and one generation and I am using the two sided market pay as clear. Sometimes, when my generation is lower than my demand, there are no trades at all. What is the reason for that ?"},{"location":"faq/#can-i-configure-all-types-of-grid-topography-from-meshed-to-radial-under-the-same-voltage-level","text":"The D3A is designed for radial and hierarchical grid structures. Other topography types might be possible as long as they do not contain \"cycles\" (essentially closed loops in the grid structure). What you cannot currently simulate are loop networks, like rings.","title":"Can I configure all types of grid topography from meshed to radial under the same voltage level ?"},{"location":"faq/#if-i-have-a-use-case-that-has-both-residential-consumers-at-240v-and-industrial-customers-at-415v-or-higher-how-can-i-set-this-up","text":"For now, voltage level is irrelevant, meaning that the D3A only simulate the amounts of energy transferred between each node (this will become important once we implement imbalances, differences between consumption and generation, which impact the frequency and the voltage of the grid). You can now simulate a grid that contains both residential and industrial consumers ignoring voltage limitations by taking for granted that the step-up transformers and transmission lines power rating will not be violated (since D3A does not check this for now). This will change once the power flows feature is implemented. By adding this new functionality, the electrical properties of the grid will be represented and used in the simulations. We recommend that each level of the D3A is tied to a specific grid voltage, so that each voltage level has its own market.","title":"If I have a use case that has both residential consumers at 240V and industrial customers at 415V or higher, how can I set this up ?"},{"location":"faq/#how-are-the-grid-fees-applied-how-do-i-set-them-up","text":"The grid fees represent the cost of the grid, taxes and other fees that are paid to another entity in exchange for using the grid. You can look at this page to see how you can set this up. When you define grid fees, it is applied inside of the specific area. These fees will be applied on the offers and bids, by raising or lowering their prices. Consequently, when an offer is published, its selling price will be the one defined by the seller plus the relevant grid fees. For trades to occur, the bid price minus the expected grid fees should be higher than the selling price plus the expected grid fees (for the two sided markets).","title":"How are the grid fees applied ? How do I set them up ?"},{"location":"faq/#use-of-blockchain","text":"","title":"Use of Blockchain"},{"location":"faq/#does-d3a-use-blockchain-technology","text":"The D3A has been designed so that it does not require blockchain technology but that it can benefit from this technology to provide enhanced functionality. Namely, if D3A-enabled deployment of energy markets is implemented via blockchain smart contracts there is full transparency of transactions, placing full trust in fair collaboration of energy actors rather than one actor having a market advantage.","title":"Does D3A use blockchain technology ?"},{"location":"faq/#what-are-the-current-technological-limitations-for-d3as-blockchain-implementation-and-possible-solutions","text":"The main limitation relates to scale or transactions throughput per second. We have tested the D3A on the ganache\u2019s private blockchain and it works only with increased simulation time as the processing is slower than when using the Python interpreter. The Energy Web Chain , designed especially for energy sector, is more efficient and less costly (in terms of transaction fees) than any other available public platform and hence would be the current blockchain of choice. As one single blockchain may never be able to handle the number and size of transactions of a large electrical grid, one solution to the problem lies in the interoperability of blockchains, with each responsible for one grid/area. This solution is proposed by the Polkadot Network , which will be launched and tested in 2020. In this scenario, the Energy Web Chain 2.0 could act as the relay chain for parachains for specific domains i.e. grid areas.","title":"What are the current technological limitations for D3A\u2019s blockchain implementation and possible solutions ?"},{"location":"faq/#considering-the-hierarchical-nature-of-the-d3a-market-structure-do-you-look-for-special-features-on-the-blockchain-for-d3a-to-work-more-efficiently","text":"As D3A is hierarchical in design, there is a need of hierarchies of blockchain that specifically handle their own local grid/area. The Polkadot Network is therefore well suited for future D3A implementation.","title":"Considering the hierarchical nature of the D3A market structure, do you look for special features on the blockchain for D3A to work more efficiently ?"},{"location":"faq/#grid-singularitys-approach","text":"","title":"Grid Singularity\u2019s Approach"},{"location":"faq/#why-is-the-d3a-open-source","text":"We believe that disruptive innovation that will lead us to new solutions to bring about the energy transition can not be achieved with private projects but rather with an open source community where everyone can contribute value, opportunities and challenges. The GPLv.3 license protects our code in a way that anyone who wishes to pursue proprietary commercialisation of the software would need to apply for a license, while open source applications continue to be free.","title":"Why is the D3A open source ?"},{"location":"faq/#what-is-the-link-between-grid-singularity-and-energy-web-foundation","text":"Grid Singularity, an energy technology startup, and the Rocky Mountain Institute, a nonprofit clean technology organisation, jointly founded the Energy Web Foundation (EWF) in January 2017. EWF is a nonprofit foundation gathering an ecosystem of over 100 energy corporates and startups with a shared, public blockchain platform, the Energy Web Chain. While Grid Singularity has significantly contributed to EWF development and the launch of the Energy Web Chain, its role today is supervisory and advisory, with two Grid Singularity representatives serving on the EWF\u2019s Foundation Council. The Energy Web Chain is the blockchain of choice for D3A\u2019s future blockchain implementation.","title":"What is the link between Grid Singularity and Energy Web Foundation ?"},{"location":"faq/#what-are-the-future-development-plans","text":"We have partnered with innovative energy companies to facilitate further D3A development in the framework of the Odyssey 2020 Energy Singularity Track led by Grid Singularity. We will also work on some specific market simulation studies with partners to demonstrate the value of local energy markets. Following Odyssey Hackathon in April, we plan to deploy the D3A engine on real smart-meters to allow trades in a neighbourhood by the end of 2020 as part of a pilot project.","title":"What are the future development plans ?"},{"location":"faq/#if-i-have-questions-regarding-the-d3a-use-how-can-i-contact-you","text":"Please first review our wiki page documentation on the UI and the backend code. The best way to engage with us is via the D3A community/ecosystem channel on Gitter . For any additional comments/feedback you can also send us an email at d3a@gridsingularity.com .","title":"If I have questions regarding the D3A use, how can I contact you ?"},{"location":"finite-power-plant-strategy/","text":"A finite power plant is an energy supplier that offers a configurable amount of power per time slot at a configured energy rate. energy_rate : the energy rate in cents/kWh. max_available_power_kW = maximum available power in kW, can also be a power profile. Corresponding code: src/3a/models/strategy/finite_power_plant.py How to add a finite power plant to the setup-file : profile_kW = { 0: 0.1, 8: 0.15, 12: 0.2, 19: 0.15, 22: 0.1 } Area('Finite Power Plant', strategy=FinitePowerPlant(energy_rate=31.3, max_available_power_kW=profile_kW), appliance=SwitchableAppliance()),","title":"Finite Power Plant Strategy"},{"location":"general-settings/","text":"General Settings is where the general simulation parameters are set. The configuration will influence all markets and all devices in the simulation The following general settings can be set when creating a simulation: Simulation name: Please provide an unique name. Description: Description of the simulation (optional). Project: The user can select a project folder in which this simulation is saved. Start date: Simulation start date (please make sure that the date-stamp of any uploaded data coincides with the start date \u2192 end date). End date: Simulation end date. The user can simulate up to 7 days. Solar profile : Sets the production curve for all PVs in the configuration that don't have individual production curves. Select one the following possible configurations: Sunny (generation profile with 250W panel) Cloudy (generation profile with 250W panel) Partially Cloudy (generation profile with 250W panel) Gaussian (the user can define the power output of the panel) Upload a profile (a custom default PV production curve can be uploaded as described in Upload File Formats ) Spot market type: The user can select one of 3 types of market: One sided pay as offer , Two sided pay as bid and Two sided pay as clear . Number of spot markets: Number of future spot markets in which the devices and agents can trade. Length of market slot: Duration of each spot market. Should be between 2 and 60 minutes. Tick length: Amount of time between two \"heartbeats\" of the simulation, influences e.g. the number of price updates. The interface for selecting general settings is shown below:","title":"General Settings"},{"location":"grid-fees/","text":"Configuration Model \u00b6 Introduction and definitions \u00b6 We will use the grid configuration example above to go into detail about how the grid fees in the D3A work. Grid fees can be configured as percentages or as euro cents (constant fees are not yet implemented). Please see how to configure the grid fee here . Fees are configured based on the clearing price of the trade. We have agreed that the buyer should pay all of the fees, at least for this implementation. Any fee that a seller has to pay is ultimately the burden of the buyer. A seller with additional operational costs or taxes will have to raise their prices in a competitive market. The fees are typically configured as percentages or euro cents in order to map the D3A fees in a way similar to the energy fees found on a customer's energy bill in the traditional/legacy electricity system. For example, in Germany the federal network agency charges 24% of the total bill as usage fees. Additional fees are subtracted for: Renewable energy surcharge (21%), Sales Tax (16%), Electricity Tax (7%), Concession levy (5%), Offshore liability levy (1.3%), Surcharge for combined heat and power plants (0.1%) and Levy for industry rebate on grid fees (1%). See Clean Energy Wire for more info. When running D3A simulations, we consider the current grid fees and propose which fees need to be added at which layers in the D3A. Configuring separate grid fees in separate markets or areas helps to accomplish this. The grid fee is a part of the energy trade price and is cumulative so that the fees in each market a trade passes through can be added cumulatively together to get the entire grid fee, often as a percentage of the clearing price. The Clearing Price is the price that the market clears at. The Trade Price is the price the buyer pays (revenue to the seller plus the grid fees). As seen in the examples below, the price of a bid or offer changes as it is propagated into different markets. The price of an offer increases to account for the added fees of the market. This helps an agent submitting an offer to receive equal or greater revenue than the value of the offer. The price of a bid decreases for the same reason. This helps an agent submitting a bid to pay equal or less than the value of the bid. This way, an agent making an offer will never receive less than their offer and an agent making a bid will never pay more than the bid. One Sided Pay as Offer \u00b6 In the One Sided Pay as Offer market, there are no bids and only offers exist. The offers are propagated throughout the markets in the hierarchy. The grid fees are taken into account when an offer is forwarded to the higher market, by the higher market itself. Therefore the agent is not responsible for adapting the offer price to include the grid fees. The grid fees' unit is a ratio of the original offer price, therefore the formula to calculate the new offer price when placing an offer to a market is the following: offer_price_after_fees = offer_price + original_offer_price * grid_fee_ratio If the offer is not purchased after one tick, it is moved into the next market. When entering a new market, the offer's price is increased according that that market's grid fee. The PV offer of \u20ac 0.10 is first placed into the House 2 Market where it gains zero fees. Then it moves into the Neighborhood 2 Market, gaining a fee of 5% of the original offer 0.10*0.05+0.10=0.105 to become \u20ac 0.105. Then if not purchased it moves into the Grid Market, gaining a fee of 10% of the original offer 0.10*0.10+0.105=0.115 to become \u20ac 0.115. Continuing into the Neighborhood 1 Market, the offer gains a fee of 5% 0.10*0.05+0.115=0.12 to become \u20ac 0.12. Continuing into the House 1 Market, the offer gains zero fees. The Load buys the offer in the House 1 Market at the Clearing Price of \u20ac 0.12. From the initial offer price, the total fees are calculated 0.10*(1+0.05+0.10+0.05) to yield the Trade Price of \u20ac 0.12. The Load pays the Trade Price of \u20ac 0.12, which includes \u20ac 0.10 revenue to the PV, \u20ac 0.005 fees to Neighborhood Market 1, \u20ac 0.01 fees to Grid Market, and \u20ac 0.005 fees to Neighborhood Market 2. Since the market is pay-as-offer, the offer prices are used as 'clearing' prices. On each market trade, the grid fee is calculated based on the original offer price (according to the accepted energy to cover partial trades) and subtracted from the offer price, in order to calculate the trade price after fees. However, the trade price includes the grid fees. The following formula is used: market_fees = grid_fee_ratio * original_price * energy_portion trade_price_after_fees = energy * trade_rate - market_fees trade_price = energy * trade_rate Two Sided Pay as Bid \u00b6 In the Two Sided Pay as Bid market, there are both bids and offers, which are both propagated throughout the markets in the hierarchy. If a bid or offer is not purchased after one tick, it is moved into the next market. In order to prevent the double accounting of a market's grid fee when a bid and an offer are matched in that market, market fees are added to offers when they enter that market ( target market ) and market fees are subtracted from bids when they leave that market and enter the another one ( source market ). The formula for propagating the offers is exactly the same as on the one-sided market : offer_price_after_fees = offer_price + original_offer_price * grid_fee_ratio The bids are not adapted by the market itself, but the area/IAA is responsible to subtract the fees from the bid before propagating the bid to the higher market. As mentioned above, the difference in behavior compared to offers is to avoid double accounting of the grid fee on one market. The formula for an area to update the bid to include grid fees is the following: bid_price_after_fees = bid_price - original_bid_price * grid_fee_ratio In the case of the Two Sided Pay as Bid market, the offer has moved into the Grid Market by the same mechanism as explained in the One Sided Pay as Offer market. The bid of \u20ac 0.30 follows a similar mechanism and is placed into the House 1 Market where there are zero fees. If the bid is not purchased after one tick, it is moved into the Neighborhood 1 Market. As explained above, only the fees from the source market are added, which are zero in this case. So the bid remains at \u20ac 0.30. Next the bid moves into the Grid Market, where it its value is lowered according to the fees of its source market, the Neighborhood 1 Market at 5%. With the Neighborhood 1 Market fee, the bid is lowered to 0.30-0.30*0.05=0.285 \u20ac 0.285 as it enters the Grid Market. In the example above, the bid and offer are matched in the Grid Market. However, when the offer entered the Grid Market, its price was immediately updated to account for the Grid Market's fees 0.10*0.10+0.105=0.115 . The bid on the other hand did not add the 10% fee. In the case that the bid was not matched in the Grid Market and moved into the Neighborhood 2 Market, the 10% fee from the Grid Market would be added. In this case the bid would become 0.285-0.30*0.10=0.255 \u20ac 0.255. The fees from the Neighborhood 2 Market would not be added to the bid unless it entered the House 2 Market (fees added according to the source market). In the Grid Market, the Load bid is listed as \u20ac 0.285 and the PV offer is listed as \u20ac 0.115. As the bid is greater than the offer a trade can be scheduled. The trade clears at the bid price, giving a Clearing Price of \u20ac 0.285. There is a separate algorithm that calculates the grid fee according to the clearing price. This allows the markets to act more independently and in a decentralized manner, without having to share information regarding their fees with other markets. In order to calculate the fee correctly based on the original price, the algorithm needs to be able to calculate the supply side and demand side tax. It is easy to calculate this, since the original bid/offer prices are available: demand_side_tax = 1 - (forwarded_bid_rate / original_bid_rate) supply_side_tax = (forwarded_offer_rate / original_offer_rate) - 1 For the example, we have the following values: supply_side_tax=(0.115/0.1)-1=0.15 , demand_side_tax=1-(0.285/0.3)=0.05 . After calculating the supply and demand side tax, we can calculate the revenue of the trade. Note the original_trade_rate is the amount that the original buyer (in our case the Load) will need to pay, therefore for pay as bid this is the original bid price. The calculation is the following: total_tax_ratio = supply_side_tax + demand_side_tax revenue = original_trade_rate / (1 + total_tax_ratio) For the example, the revenue will be: revenue = 0.30/(1+0.15+0.05)=0.25 The grid fees are then calculated based on the revenue and the individual market fees. fees = revenue * grid_fee_ratio For the case of the Grid Market in our example, the fees are 0.25*0.1=0.025 , and for each Neighborhood market, the fees are 0.25*0.05=0.0125 . Finally, the trade rate is adapted according to the supply side tax, in order to include the fees of the current market: trade_rate = revenue * (1 + supply_side_tax) trade_price = energy * trade_rate For our example, the trade price for each market is: Grid Market = 0.25 * (1 + 0.15) = 0.2875 Neighborhood 2 Market = 0.25 * (1 + 0.05) = 0.2625 Neighborhood 1 Market = 0.25 * (1 + 0.2) = 0.3 House 1 Market = 0.25 * (1 + 0.2) = 0.3 House 2 Market = 0.25 * (1 + 0) = 0.25 The Load pays the Trade Price of \u20ac 0.30, which includes \u20ac 0.25 revenue to the PV, \u20ac 0.0125 fees to Neighborhood Market 1, \u20ac 0.025 fees to Grid Market, and \u20ac 0.0125 fees to Neighborhood Market 2. Two Sided Pay as Clear \u00b6 In construction...","title":"Grid Fees"},{"location":"grid-fees/#configuration-model","text":"","title":"Configuration Model"},{"location":"grid-fees/#introduction-and-definitions","text":"We will use the grid configuration example above to go into detail about how the grid fees in the D3A work. Grid fees can be configured as percentages or as euro cents (constant fees are not yet implemented). Please see how to configure the grid fee here . Fees are configured based on the clearing price of the trade. We have agreed that the buyer should pay all of the fees, at least for this implementation. Any fee that a seller has to pay is ultimately the burden of the buyer. A seller with additional operational costs or taxes will have to raise their prices in a competitive market. The fees are typically configured as percentages or euro cents in order to map the D3A fees in a way similar to the energy fees found on a customer's energy bill in the traditional/legacy electricity system. For example, in Germany the federal network agency charges 24% of the total bill as usage fees. Additional fees are subtracted for: Renewable energy surcharge (21%), Sales Tax (16%), Electricity Tax (7%), Concession levy (5%), Offshore liability levy (1.3%), Surcharge for combined heat and power plants (0.1%) and Levy for industry rebate on grid fees (1%). See Clean Energy Wire for more info. When running D3A simulations, we consider the current grid fees and propose which fees need to be added at which layers in the D3A. Configuring separate grid fees in separate markets or areas helps to accomplish this. The grid fee is a part of the energy trade price and is cumulative so that the fees in each market a trade passes through can be added cumulatively together to get the entire grid fee, often as a percentage of the clearing price. The Clearing Price is the price that the market clears at. The Trade Price is the price the buyer pays (revenue to the seller plus the grid fees). As seen in the examples below, the price of a bid or offer changes as it is propagated into different markets. The price of an offer increases to account for the added fees of the market. This helps an agent submitting an offer to receive equal or greater revenue than the value of the offer. The price of a bid decreases for the same reason. This helps an agent submitting a bid to pay equal or less than the value of the bid. This way, an agent making an offer will never receive less than their offer and an agent making a bid will never pay more than the bid.","title":"Introduction and definitions"},{"location":"grid-fees/#one-sided-pay-as-offer","text":"In the One Sided Pay as Offer market, there are no bids and only offers exist. The offers are propagated throughout the markets in the hierarchy. The grid fees are taken into account when an offer is forwarded to the higher market, by the higher market itself. Therefore the agent is not responsible for adapting the offer price to include the grid fees. The grid fees' unit is a ratio of the original offer price, therefore the formula to calculate the new offer price when placing an offer to a market is the following: offer_price_after_fees = offer_price + original_offer_price * grid_fee_ratio If the offer is not purchased after one tick, it is moved into the next market. When entering a new market, the offer's price is increased according that that market's grid fee. The PV offer of \u20ac 0.10 is first placed into the House 2 Market where it gains zero fees. Then it moves into the Neighborhood 2 Market, gaining a fee of 5% of the original offer 0.10*0.05+0.10=0.105 to become \u20ac 0.105. Then if not purchased it moves into the Grid Market, gaining a fee of 10% of the original offer 0.10*0.10+0.105=0.115 to become \u20ac 0.115. Continuing into the Neighborhood 1 Market, the offer gains a fee of 5% 0.10*0.05+0.115=0.12 to become \u20ac 0.12. Continuing into the House 1 Market, the offer gains zero fees. The Load buys the offer in the House 1 Market at the Clearing Price of \u20ac 0.12. From the initial offer price, the total fees are calculated 0.10*(1+0.05+0.10+0.05) to yield the Trade Price of \u20ac 0.12. The Load pays the Trade Price of \u20ac 0.12, which includes \u20ac 0.10 revenue to the PV, \u20ac 0.005 fees to Neighborhood Market 1, \u20ac 0.01 fees to Grid Market, and \u20ac 0.005 fees to Neighborhood Market 2. Since the market is pay-as-offer, the offer prices are used as 'clearing' prices. On each market trade, the grid fee is calculated based on the original offer price (according to the accepted energy to cover partial trades) and subtracted from the offer price, in order to calculate the trade price after fees. However, the trade price includes the grid fees. The following formula is used: market_fees = grid_fee_ratio * original_price * energy_portion trade_price_after_fees = energy * trade_rate - market_fees trade_price = energy * trade_rate","title":"One Sided Pay as Offer"},{"location":"grid-fees/#two-sided-pay-as-bid","text":"In the Two Sided Pay as Bid market, there are both bids and offers, which are both propagated throughout the markets in the hierarchy. If a bid or offer is not purchased after one tick, it is moved into the next market. In order to prevent the double accounting of a market's grid fee when a bid and an offer are matched in that market, market fees are added to offers when they enter that market ( target market ) and market fees are subtracted from bids when they leave that market and enter the another one ( source market ). The formula for propagating the offers is exactly the same as on the one-sided market : offer_price_after_fees = offer_price + original_offer_price * grid_fee_ratio The bids are not adapted by the market itself, but the area/IAA is responsible to subtract the fees from the bid before propagating the bid to the higher market. As mentioned above, the difference in behavior compared to offers is to avoid double accounting of the grid fee on one market. The formula for an area to update the bid to include grid fees is the following: bid_price_after_fees = bid_price - original_bid_price * grid_fee_ratio In the case of the Two Sided Pay as Bid market, the offer has moved into the Grid Market by the same mechanism as explained in the One Sided Pay as Offer market. The bid of \u20ac 0.30 follows a similar mechanism and is placed into the House 1 Market where there are zero fees. If the bid is not purchased after one tick, it is moved into the Neighborhood 1 Market. As explained above, only the fees from the source market are added, which are zero in this case. So the bid remains at \u20ac 0.30. Next the bid moves into the Grid Market, where it its value is lowered according to the fees of its source market, the Neighborhood 1 Market at 5%. With the Neighborhood 1 Market fee, the bid is lowered to 0.30-0.30*0.05=0.285 \u20ac 0.285 as it enters the Grid Market. In the example above, the bid and offer are matched in the Grid Market. However, when the offer entered the Grid Market, its price was immediately updated to account for the Grid Market's fees 0.10*0.10+0.105=0.115 . The bid on the other hand did not add the 10% fee. In the case that the bid was not matched in the Grid Market and moved into the Neighborhood 2 Market, the 10% fee from the Grid Market would be added. In this case the bid would become 0.285-0.30*0.10=0.255 \u20ac 0.255. The fees from the Neighborhood 2 Market would not be added to the bid unless it entered the House 2 Market (fees added according to the source market). In the Grid Market, the Load bid is listed as \u20ac 0.285 and the PV offer is listed as \u20ac 0.115. As the bid is greater than the offer a trade can be scheduled. The trade clears at the bid price, giving a Clearing Price of \u20ac 0.285. There is a separate algorithm that calculates the grid fee according to the clearing price. This allows the markets to act more independently and in a decentralized manner, without having to share information regarding their fees with other markets. In order to calculate the fee correctly based on the original price, the algorithm needs to be able to calculate the supply side and demand side tax. It is easy to calculate this, since the original bid/offer prices are available: demand_side_tax = 1 - (forwarded_bid_rate / original_bid_rate) supply_side_tax = (forwarded_offer_rate / original_offer_rate) - 1 For the example, we have the following values: supply_side_tax=(0.115/0.1)-1=0.15 , demand_side_tax=1-(0.285/0.3)=0.05 . After calculating the supply and demand side tax, we can calculate the revenue of the trade. Note the original_trade_rate is the amount that the original buyer (in our case the Load) will need to pay, therefore for pay as bid this is the original bid price. The calculation is the following: total_tax_ratio = supply_side_tax + demand_side_tax revenue = original_trade_rate / (1 + total_tax_ratio) For the example, the revenue will be: revenue = 0.30/(1+0.15+0.05)=0.25 The grid fees are then calculated based on the revenue and the individual market fees. fees = revenue * grid_fee_ratio For the case of the Grid Market in our example, the fees are 0.25*0.1=0.025 , and for each Neighborhood market, the fees are 0.25*0.05=0.0125 . Finally, the trade rate is adapted according to the supply side tax, in order to include the fees of the current market: trade_rate = revenue * (1 + supply_side_tax) trade_price = energy * trade_rate For our example, the trade price for each market is: Grid Market = 0.25 * (1 + 0.15) = 0.2875 Neighborhood 2 Market = 0.25 * (1 + 0.05) = 0.2625 Neighborhood 1 Market = 0.25 * (1 + 0.2) = 0.3 House 1 Market = 0.25 * (1 + 0.2) = 0.3 House 2 Market = 0.25 * (1 + 0) = 0.25 The Load pays the Trade Price of \u20ac 0.30, which includes \u20ac 0.25 revenue to the PV, \u20ac 0.0125 fees to Neighborhood Market 1, \u20ac 0.025 fees to Grid Market, and \u20ac 0.0125 fees to Neighborhood Market 2.","title":"Two Sided Pay as Bid"},{"location":"grid-fees/#two-sided-pay-as-clear","text":"In construction...","title":"Two Sided Pay as Clear"},{"location":"grid-setup/","text":"On this page the user can set up the architecture of the grid by adding Areas and Devices. You can define up to 250 nodes. Each area or device is considered as 1 node. Areas are made up of a spot market in which all connected devices, sub-areas and parent areas trade energy. Areas can potentially house multiple markets of different market types. This feature will be available in the future. After creating the first area the user has to define a Market Maker . There are 4 different types of basic Devices available (for detailed settings descriptions follow the individual links): PV Storage Load Power Plant The user can also insert Libraries , which are customized devices available from the D3A community. A list of these devices with a search function appears when clicking on \"LIBRARY\" on the upper right corner. Once ready, the user can run the simulation by clicking on the button shown below and will be redirected to the Results . The user can duplicate the number of Areas or Devices by clicking on the +/- buttons shown below (device or area settings view).","title":"Initial Grid Setup"},{"location":"how-implement-custom-device-strategies/","text":"It is possible for the user to overwrite some of the functionalities of the three basic strategies ( PVStrategy , StorageStrategy , LoadHoursStrategy ). In order to implement the custom strategies: Go to the desired python file: d3a/models/strategy/custom_.py Change the code of the desired functions accordingly by replacing pass with the desired functionality. There are example files in d3a/setup/jira/ named test_strategy_custom_<device>.py that are also used for integration tests. CustomPvStrategy \u00b6 The user can change the functionality of the following function of the PVStrategy in d3a/models/strategy/custom_pv.py : produced_energy_forecast_kWh Overwrites d3a.models.strategy.pv.produced_energy_forecast_kWh and returns the energy production of the custom PV for each market slot. Is called on every ACTIVATE event. Returns dictionary that describes energy production in kWh for each market slot: self.energy_production_forecast_kW . Note that the dictionary should have as many entries as the number of market slots. calculate_initial_sell_rate Overrides d3a.models.strategy.update_frequency.calculate_initial_sell_rate . Is called on every MARKET_CYCLE event. Returns the initial value of the sell energy rate for each hour of the simulation. Parameter: current_time_h : slot time in hours (e.g. market.time_slot.hour). decrease_energy_price_over_ticks Overrides d3a.models.strategy.update_frequency.decrease_energy_price_over_ticks . Is called on every EVENT_TICK event. Should be used to modify the price decrease over the ticks for the selected market. CustomStorageStrategy \u00b6 The user can change the functionality of the following functions of the StorageStrategy in d3a/setup/jira/test_strategy_custom_storage.py : calculate_energy_to_buy Overrides d3a.models.strategy.storage.calculate_energy_to_buy . Is called by StorageStrategy.buy_energy and runs on every EVENT_TICK event. Clamps to-buy energy to physical or market margins. Returns clamped energy in kWh. calculate_energy_to_sell Overrides d3a.models.strategy.storage.calculate_energy_to_sell . Is called by StorageStrategy.sell_energy and runs on every EVENT_MARKET_CYCLE event. Clamps to-sell energy to physical or market margins. Returns clamped energy in kWh. calculate_selling_rate Overrides d3a.models.strategy.storage.calculate_selling_rate . Is called by StorageStrategy.sell_energy and runs on every EVENT_MARKET_CYCLE event. Returns initial selling rate in ct./kWh. decrease_energy_price_over_ticks Overrides d3a.models.strategy.update_frequency.decrease_energy_price_over_ticks . Is called on every EVENT_TICK event. Should be used to modify the price decrease over the ticks for the selected market. select_market_to_sell Overrides d3a.models.strategy.storage.select_market_to_sell . Is called by StorageStrategy.sell_energy and runs on every EVENT_MARKET_CYCLE event. Returns target market object. update_posted_bids Overwrites d3a.models.strategy.load_hours_fb.update_posted_bids . Is called on every TICK event. Should be used to modify the price of the bids over the ticks for the selected market. In the default implementation, an increase of the energy over the ticks is implemented. CustomLoadStrategy \u00b6 The user can change the functionality of the following functions of the LoadHoursStrategy in d3a/models/strategy/custom_load.py : update_posted_bids Overwrites d3a.models.strategy.load_hours_fb.update_posted_bids . Is called on every TICK event. Should be used to modify the price of the bids over the ticks for the selected market. In the default implementation, an increase of the energy over the ticks is implemented.","title":"How to Implement Custom Device Strategies"},{"location":"how-implement-custom-device-strategies/#custompvstrategy","text":"The user can change the functionality of the following function of the PVStrategy in d3a/models/strategy/custom_pv.py : produced_energy_forecast_kWh Overwrites d3a.models.strategy.pv.produced_energy_forecast_kWh and returns the energy production of the custom PV for each market slot. Is called on every ACTIVATE event. Returns dictionary that describes energy production in kWh for each market slot: self.energy_production_forecast_kW . Note that the dictionary should have as many entries as the number of market slots. calculate_initial_sell_rate Overrides d3a.models.strategy.update_frequency.calculate_initial_sell_rate . Is called on every MARKET_CYCLE event. Returns the initial value of the sell energy rate for each hour of the simulation. Parameter: current_time_h : slot time in hours (e.g. market.time_slot.hour). decrease_energy_price_over_ticks Overrides d3a.models.strategy.update_frequency.decrease_energy_price_over_ticks . Is called on every EVENT_TICK event. Should be used to modify the price decrease over the ticks for the selected market.","title":"CustomPvStrategy"},{"location":"how-implement-custom-device-strategies/#customstoragestrategy","text":"The user can change the functionality of the following functions of the StorageStrategy in d3a/setup/jira/test_strategy_custom_storage.py : calculate_energy_to_buy Overrides d3a.models.strategy.storage.calculate_energy_to_buy . Is called by StorageStrategy.buy_energy and runs on every EVENT_TICK event. Clamps to-buy energy to physical or market margins. Returns clamped energy in kWh. calculate_energy_to_sell Overrides d3a.models.strategy.storage.calculate_energy_to_sell . Is called by StorageStrategy.sell_energy and runs on every EVENT_MARKET_CYCLE event. Clamps to-sell energy to physical or market margins. Returns clamped energy in kWh. calculate_selling_rate Overrides d3a.models.strategy.storage.calculate_selling_rate . Is called by StorageStrategy.sell_energy and runs on every EVENT_MARKET_CYCLE event. Returns initial selling rate in ct./kWh. decrease_energy_price_over_ticks Overrides d3a.models.strategy.update_frequency.decrease_energy_price_over_ticks . Is called on every EVENT_TICK event. Should be used to modify the price decrease over the ticks for the selected market. select_market_to_sell Overrides d3a.models.strategy.storage.select_market_to_sell . Is called by StorageStrategy.sell_energy and runs on every EVENT_MARKET_CYCLE event. Returns target market object. update_posted_bids Overwrites d3a.models.strategy.load_hours_fb.update_posted_bids . Is called on every TICK event. Should be used to modify the price of the bids over the ticks for the selected market. In the default implementation, an increase of the energy over the ticks is implemented.","title":"CustomStorageStrategy"},{"location":"how-implement-custom-device-strategies/#customloadstrategy","text":"The user can change the functionality of the following functions of the LoadHoursStrategy in d3a/models/strategy/custom_load.py : update_posted_bids Overwrites d3a.models.strategy.load_hours_fb.update_posted_bids . Is called on every TICK event. Should be used to modify the price of the bids over the ticks for the selected market. In the default implementation, an increase of the energy over the ticks is implemented.","title":"CustomLoadStrategy"},{"location":"how-strategies-adjust-prices/","text":"In each strategy, the bid or offer is changed according to its energy rate increase or decrease rate per update. Offers \u00b6 Related settings: initial_selling_rate final_selling_rate update_interval energy_rate_decrease_per_update fit_to_limit The following plot shows the energy rate in the frame of on spot market slot ( slot_length = 15mins ) for different combinations of the above mentioned parameters. If fit_to_limit is set to True , energy_rate_decrease_per_update is ignored and a rate decrease per time is calculated that starts at initial_selling_rate and ends at final_selling_rate while updating the rate every update_interval minutes. Bids \u00b6 Related settings: initial_buying_rate final_buying_rate update_interval energy_rate_increase_per_update fit_to_limit The following plot shows the energy rate in the frame of on spot market slot ( slot_length = 15mins ) for different combinations of the above mentioned parameters. If fit_to_limit is set to True , energy_rate_increase_per_update is ignored and a rate increase per time is calculated that starts at initial_buying_rate and ends at final_buying_rate while updating the rate every update_interval minutes.","title":"How Strategies Adjust the Prices of Offers and Bids"},{"location":"how-strategies-adjust-prices/#offers","text":"Related settings: initial_selling_rate final_selling_rate update_interval energy_rate_decrease_per_update fit_to_limit The following plot shows the energy rate in the frame of on spot market slot ( slot_length = 15mins ) for different combinations of the above mentioned parameters. If fit_to_limit is set to True , energy_rate_decrease_per_update is ignored and a rate decrease per time is calculated that starts at initial_selling_rate and ends at final_selling_rate while updating the rate every update_interval minutes.","title":"Offers"},{"location":"how-strategies-adjust-prices/#bids","text":"Related settings: initial_buying_rate final_buying_rate update_interval energy_rate_increase_per_update fit_to_limit The following plot shows the energy rate in the frame of on spot market slot ( slot_length = 15mins ) for different combinations of the above mentioned parameters. If fit_to_limit is set to True , energy_rate_increase_per_update is ignored and a rate increase per time is calculated that starts at initial_buying_rate and ends at final_buying_rate while updating the rate every update_interval minutes.","title":"Bids"},{"location":"infinite-bus-strategy/","text":"This device is the same as the commercial energy producer / infinite power plant in that it produces an infinite amount of energy at the energy_sell_rate . However, the infinite bus can also buy an infinite amount of energy at a predefined price, the energy_buy_rate. Configuration parameters: energy_buy_rate : energy rate for selling in cents/kWh (can be a profile in JSON or dict format as well as a filename) energy_sell_rate : energy rate for buying in cents/kWh (can be a profile in JSON or dict format as well as a filename) Corresponding code: src/3a/models/strategy/infinite_bus.py How to add a infinite power plant to the setup-file: Area('Infinite Bus', strategy=InfiniteBusStrategy(energy_buy_rate=24, energy_sell_rate=25), appliance=SimpleAppliance()),","title":"Infinite Bus Strategy"},{"location":"infinite-power-plant-strategy/","text":"An infinite power plant is coded as a Commercial Energy Producer in the D3A code. The infinite power plant is used to represent the concept of an infinite bus, which has an unchangeable energy supply, unaffected by variations or disturbances caused by connected grids. Similar to its stable energy supply, the selling price of the infinite power plant is also unaffected by competition. This selling price is called the market maker price, as it provides a basis for local markets as other devices to compete against each other and the infinite power plant (or in many cases, the legacy grid). The market maker price is configured globally for a simulation, unassigned to a specific device. But when configuring an infinite power plant, it usually makes sense to assign its energy rate to the market maker price. (The market maker price can be a constant value, a CSV file, or an array of changing values over time, similar to the PV and Load custom profile options). Rate settings include: energy_rate : the energy rate in cents/kWh (can be configured to the market maker price) Corresponding code: src/3a/models/strategy/commercial_producer.py","title":"Infinite Power Plant Strategy"},{"location":"installation-instructions/","text":"How to Install D3A on Ubuntu 18.04 \u00b6 Preparations \u00b6 In case you have not installed git, python3.6 and pip yet: \u00b6 sudo apt-get update sudo apt-get install git-core software-properties-common -y sudo add-apt-repository ppa:deadsnakes/ppa sudo apt-get update sudo apt-get install python3.6 -y sudo apt-get install git-core -y sudo apt-get install python3-pip -y Install virtualenv and create a python virtual environment for d3a \u00b6 pip3 install virtualenv mkdir envs cd envs virtualenv -p /usr/bin/python3.6 d3a How to activate the environment: source d3a/bin/activate How to deactivate: deactivate Before you start: \u00b6 Please add the following lines to your .bashrc and reopen the shell: export LC_ALL=C.UTF-8 export LANG=C.UTF-8 Clone the d3a repository to a directory of your choice: git clone https://github.com/gridsingularity/d3a.git Install the D3A: \u00b6 Activate your virtualenvironment Install fabric pip3 install fabric3 Go into your d3a folder and install d3a with: fab sync Now, if you run d3a run \u2013help , the help of d3a should be shown.","title":"Linux"},{"location":"installation-instructions/#how-to-install-d3a-on-ubuntu-1804","text":"","title":"How to Install D3A on Ubuntu 18.04"},{"location":"installation-instructions/#preparations","text":"","title":"Preparations"},{"location":"installation-instructions/#in-case-you-have-not-installed-git-python36-and-pip-yet","text":"sudo apt-get update sudo apt-get install git-core software-properties-common -y sudo add-apt-repository ppa:deadsnakes/ppa sudo apt-get update sudo apt-get install python3.6 -y sudo apt-get install git-core -y sudo apt-get install python3-pip -y","title":"In case you have not installed git, python3.6 and pip yet:"},{"location":"installation-instructions/#install-virtualenv-and-create-a-python-virtual-environment-for-d3a","text":"pip3 install virtualenv mkdir envs cd envs virtualenv -p /usr/bin/python3.6 d3a How to activate the environment: source d3a/bin/activate How to deactivate: deactivate","title":"Install virtualenv and create a python virtual environment for d3a"},{"location":"installation-instructions/#before-you-start","text":"Please add the following lines to your .bashrc and reopen the shell: export LC_ALL=C.UTF-8 export LANG=C.UTF-8 Clone the d3a repository to a directory of your choice: git clone https://github.com/gridsingularity/d3a.git","title":"Before you start:"},{"location":"installation-instructions/#install-the-d3a","text":"Activate your virtualenvironment Install fabric pip3 install fabric3 Go into your d3a folder and install d3a with: fab sync Now, if you run d3a run \u2013help , the help of d3a should be shown.","title":"Install the D3A:"},{"location":"inter-area-agent/","text":"The Inter-Area Agent (IAA) plays a crucial role in the architecture of D3A. It is created for each area class (for nodes such as Houses, streets, etc. that do not have configured strategies) and mainly deals with forwarding offers and bids between markets of different hierarchy levels. The IAA class accounts for the direction of the offer, meaning whether the offer is sent from a lower to a higher hierarchy layer or the other way around. This is achieved by creating two separate IAA Engines for each direction. Sample grid setup and the role of the IAA in the hierarchy if nodes, leafs and markets (this scheme only applies for one time slot) : The Inter-Area Agent is responsible for modeling the inter-area operations for an area. The main functionalities of an inter-area agent can be summarized to these points: Forwarding offers from a lower hierarchy (market) to an upper hierarchy. Forwarding bids, in the same fashion as offers Keeping track of the aforementioned forwarded bids and offers Reacting to events coming from neighbouring inter-area agents, in order to propagate the event for an offer/bid that has been forwarded from this IAA. Triggering the matching of offers and bids for the two sided market.","title":"Inter-Area Agent"},{"location":"ios-installation-instructions/","text":"How to Install D3A on macOS \u00b6 Preparations \u00b6 Make sure the command line compiler tools are installed: \u00b6 xcode-select --install (Select 'Install' in the window that opens) Install Homebrew \u00b6 /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" Install some libraries we need later: \u00b6 brew install automake libtool pkg-config libffi gmp openssl readline xz Install pyenv: \u00b6 brew install pyenv echo -e 'if command -v pyenv 1>/dev/null 2>&1; then\\n eval \"$(pyenv init -)\"\\nfi' >> ~/.bash_profile Close and re-open the terminal \u00b6 Install Python 3.6 and set as default: \u00b6 pyenv install 3.6.3 pyenv global 3.6.3 Install virtualenvwrapper: \u00b6 pip install virtualenvwrapper echo -e 'export WORKON_HOME=~/Envs\\nsource ~/.pyenv/versions/3.6.3/bin/virtualenvwrapper.sh' >> ~/.bash_profile Setup paths for compiling python libraries: \u00b6 echo -e 'BREW_PREFIX=\"$(brew --prefix openssl)\"\\nexport CFLAGS=\"-I${BREW_PREFIX}/include\"\\nexport LDFLAGS=\"-L${BREW_PREFIX}/lib\"' >> ~/.bash_profile Installation \u00b6 Close and re-open the terminal \u00b6 Clone d3a repository (do this inside the directory where you want the project to be): \u00b6 git clone \"https://github.com/gridsingularity/d3a.git\" cd d3a Create and initialize d3a virtualenv \u00b6 brew install npm npm install --global ganache-cli mkvirtualenv d3a pip install pendulum pip-tools pip install -e . Install \u00b6 Done, you now should have a working d3a setup. \u00b6 Now, if you run d3a run -\u2013help , the help of d3a should be shown.","title":"Mac"},{"location":"ios-installation-instructions/#how-to-install-d3a-on-macos","text":"","title":"How to Install D3A on macOS"},{"location":"ios-installation-instructions/#preparations","text":"","title":"Preparations"},{"location":"ios-installation-instructions/#make-sure-the-command-line-compiler-tools-are-installed","text":"xcode-select --install (Select 'Install' in the window that opens)","title":"Make sure the command line compiler tools are installed:"},{"location":"ios-installation-instructions/#install-homebrew","text":"/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"","title":"Install Homebrew"},{"location":"ios-installation-instructions/#install-some-libraries-we-need-later","text":"brew install automake libtool pkg-config libffi gmp openssl readline xz","title":"Install some libraries we need later:"},{"location":"ios-installation-instructions/#install-pyenv","text":"brew install pyenv echo -e 'if command -v pyenv 1>/dev/null 2>&1; then\\n eval \"$(pyenv init -)\"\\nfi' >> ~/.bash_profile","title":"Install pyenv:"},{"location":"ios-installation-instructions/#close-and-re-open-the-terminal","text":"","title":"Close and re-open the terminal"},{"location":"ios-installation-instructions/#install-python-36-and-set-as-default","text":"pyenv install 3.6.3 pyenv global 3.6.3","title":"Install Python 3.6 and set as default:"},{"location":"ios-installation-instructions/#install-virtualenvwrapper","text":"pip install virtualenvwrapper echo -e 'export WORKON_HOME=~/Envs\\nsource ~/.pyenv/versions/3.6.3/bin/virtualenvwrapper.sh' >> ~/.bash_profile","title":"Install virtualenvwrapper:"},{"location":"ios-installation-instructions/#setup-paths-for-compiling-python-libraries","text":"echo -e 'BREW_PREFIX=\"$(brew --prefix openssl)\"\\nexport CFLAGS=\"-I${BREW_PREFIX}/include\"\\nexport LDFLAGS=\"-L${BREW_PREFIX}/lib\"' >> ~/.bash_profile","title":"Setup paths for compiling python libraries:"},{"location":"ios-installation-instructions/#installation","text":"","title":"Installation"},{"location":"ios-installation-instructions/#close-and-re-open-the-terminal_1","text":"","title":"Close and re-open the terminal"},{"location":"ios-installation-instructions/#clone-d3a-repository-do-this-inside-the-directory-where-you-want-the-project-to-be","text":"git clone \"https://github.com/gridsingularity/d3a.git\" cd d3a","title":"Clone d3a repository (do this inside the directory where you want the project to be):"},{"location":"ios-installation-instructions/#create-and-initialize-d3a-virtualenv","text":"brew install npm npm install --global ganache-cli mkvirtualenv d3a pip install pendulum pip-tools pip install -e .","title":"Create and initialize d3a virtualenv"},{"location":"ios-installation-instructions/#install","text":"","title":"Install"},{"location":"ios-installation-instructions/#done-you-now-should-have-a-working-d3a-setup","text":"Now, if you run d3a run -\u2013help , the help of d3a should be shown.","title":"Done, you now should have a working d3a setup."},{"location":"kpis/","text":"In the last few years, distributed energy resources concept has gained ground in the power utility scope. Strictly speaking in terms of D3A, it is necessary to know a metric that could aid in visualising local resource utilisation in distributed energy trading platform. In order to do so we have planned to implement some KPIs to give us a good figure of effectiveness of localised distributed energy trading. Self-Sufficiency & Self-Consumption \u00b6 The Self-Sufficiency of an area is its internal consumption of energy (all energy consumed that was produced internally in the area) as a fraction of it's demand of energy (all energy demanded by the area). The Self-Consumption of an area is its internal consumption of energy (all energy consumed that was produced internally in the area) as a fraction of it's production of energy (all energy produced by the area). Strictly speaking in terms of formula: self_sufficiency(area) = self_consumed_energy / total_energy_demanded self_consumption(area) = self_consumed_energy / total_energy_produced If you have a look at the hierarchical energy grid as shown in figure below, the self_consumed energy would be different from the reference point of whole energy grid. Lets consider house 1 where, total_house1_pv_production = 10kWh house1_pv \u2192 house1_load = 1kWh house1_pv \u2192 house1_storage = 5kWh house1_pv \u2192 house2_load = 4kWh house1_storage \u2192 house1_load = 2kWh house1_storage \u2192 house2_load = 3kWh house1_self_consumer_energy = ( house1_pv \u2192 house1_load ) + ( house1_pv \u2192 house1_storage \u2192 house1_load ) = 1 + 2 = 3kWh house1_total_energy_demanded (only includes the demanded energy from house1\u2019s load device) = 4kWh Then, self-sufficiency of the house 1 is self_sufficiency(house1) = house1_self_consumer_energy / house1_total_energy_demanded self_sufficiency(house1) = 3 / 4 = 0.75 \u2192 75% Then, self-consumption of the house 1 is self_consumption(house1) = house1_self_consumer_energy / house1_total_energy_produced self_consumption(house1) = 3 / 10 = 0.3 \u2192 30% From the reference point of GRID where all others areas are its children: self_sufficiency would always be 100% unless there is an unmatched load from any of the load devices self_consumption would always be 100% unless there is an unmatched PV\u2019s offer from any of the PV devices.","title":"Key Performance Indicators (KPIs)"},{"location":"kpis/#self-sufficiency-self-consumption","text":"The Self-Sufficiency of an area is its internal consumption of energy (all energy consumed that was produced internally in the area) as a fraction of it's demand of energy (all energy demanded by the area). The Self-Consumption of an area is its internal consumption of energy (all energy consumed that was produced internally in the area) as a fraction of it's production of energy (all energy produced by the area). Strictly speaking in terms of formula: self_sufficiency(area) = self_consumed_energy / total_energy_demanded self_consumption(area) = self_consumed_energy / total_energy_produced If you have a look at the hierarchical energy grid as shown in figure below, the self_consumed energy would be different from the reference point of whole energy grid. Lets consider house 1 where, total_house1_pv_production = 10kWh house1_pv \u2192 house1_load = 1kWh house1_pv \u2192 house1_storage = 5kWh house1_pv \u2192 house2_load = 4kWh house1_storage \u2192 house1_load = 2kWh house1_storage \u2192 house2_load = 3kWh house1_self_consumer_energy = ( house1_pv \u2192 house1_load ) + ( house1_pv \u2192 house1_storage \u2192 house1_load ) = 1 + 2 = 3kWh house1_total_energy_demanded (only includes the demanded energy from house1\u2019s load device) = 4kWh Then, self-sufficiency of the house 1 is self_sufficiency(house1) = house1_self_consumer_energy / house1_total_energy_demanded self_sufficiency(house1) = 3 / 4 = 0.75 \u2192 75% Then, self-consumption of the house 1 is self_consumption(house1) = house1_self_consumer_energy / house1_total_energy_produced self_consumption(house1) = 3 / 10 = 0.3 \u2192 30% From the reference point of GRID where all others areas are its children: self_sufficiency would always be 100% unless there is an unmatched load from any of the load devices self_consumption would always be 100% unless there is an unmatched PV\u2019s offer from any of the PV devices.","title":"Self-Sufficiency &amp; Self-Consumption"},{"location":"launch-sim-via-cli/","text":"Command line arguments include: -d, --duration : Duration of simulation [default: 24h] -t, --tick-length : Length of a tick [default: 1s] -s, --slot-length : Length of a market slot [default: 15m] -c, --cloud-coverage : Cloud coverage, 0 for sunny, 1 for partial coverage, 2 for clouds. [default: 0] -m, --market-count : Number of tradable market slots into the future [default: 5] Example simulation call: \u00b6 d3a -l ERROR run --duration=24h --tick-length=1s --slot-length=15m --cloud-coverage=0 --market-count=5 --setup default_2a Getting help in the command line: \u00b6 d3a --help returns: Usage: d3a [OPTIONS] COMMAND [ARGS]... Options: -l, --log-level [CRITICAL|FATAL|ERROR|WARN|WARNING|INFO|DEBUG|NOTSET|TRACE] Log level [default: INFO] --help Show this message and exit. Commands: run* resume d3a run --help returns: Usage: d3a run [OPTIONS] Options: -d, --duration INTERVAL Duration of simulation [default: 1d] -t, --tick-length INTERVAL Length of a tick [default: 1s] -s, --slot-length INTERVAL Length of a market slot [default: 15m] -c, --cloud-coverage INTEGER Cloud coverage, 0 for sunny, 1 for partial coverage, 2 for clouds. [default: 0] -m, --market-count INTEGER Number of tradable market slots into the future [default: 1] --setup TEXT Simulation setup module use. Available modules: [1000_houses, area_events.cloud_coverage_event, area_events.disable_interval_event, area_events.disconnect_interval_event, area_events.isolated_connect_event, area_events.isolated_disable_event, area_events.isolated_disconnect_event, area_events.isolated_enable_event, area_events.load_event, area_events.pv_event, area_events.storage_event, balancing_market.default_2a, balancing_market.one_load_one_pv, balancing_market.one_load_one_storage, balancing_market.one_storage_one_pv, balancing_market.test_device_registry, balancing_market.two_sided_one_load_one_pv, config_parameter_test, default_2, default_2a, default_2b, default_3, default_3_pv_only, default_3a, default_3b, default_4, default_5, default_addcurve, default_addcurve2, default_csv, graphs_testing, jira.d3asim_1024, jira.d3asim_1139, jira.d3asim_638_custom_load, jira.d3asim_639_custom_storage, jira.d3asim_640_custom_pv, jira.d3asim_778, jira.d3asim_780, jira.d3asim_869, jira.d3asim_871, jira.d3asim_895, jira.d3asim_895_pr1, jira.d3asim_895_pr2, jira.d3asim_895_pr3, jira.d3asim_962, jira.default_2off_d3asim_1475, jira.default_595, jira.default_611, jira.default_613, jira.default_623, jira.default_645, jira.default_737, jira.test_strategy_custom_load, jira.test_strategy_custom_pv, jira.test_strategy_custom_storage, json_arg, json_file, non_compounded_grid_fees, redis_communication_default_2a, sam_config, sam_config_const_load, sam_config_small, strategy_tests.commercial_producer_market_maker_rate, strategy_tests.ess_capacity_based_sell_offer, strategy_tests.ess_sell_offer_decrease_based_on_risk_or_rate, strategy_tests.finite_power_plant, strategy_tests.finite_power_plant_profile, strategy_tests.home_cp_ess_load, strategy_tests.home_hybrid_pv_ess_load, strategy_tests.infinite_bus, strategy_tests.predefined_pv_test, strategy_tests.pv_const_price_decrease, strategy_tests.pv_final_selling_rate, strategy_tests.pv_initial_pv_rate_option, strategy_tests.pv_max_panel_output, strategy_tests.pv_max_panel_power_global, strategy_tests.pv_risk_based_price_decrease, strategy_tests.storage_buys_and_offers, strategy_tests.storage_strategy_break_even_hourly, strategy_tests.user_profile_load_csv, strategy_tests.user_profile_load_csv_multiday, strategy_tests.user_profile_load_dict, strategy_tests.user_profile_pv_csv, strategy_tests.user_profile_pv_dict, strategy_tests.user_profile_wind_csv, strategy_tests.user_rate_profile_load_dict, tobalaba.one_producer_load, two_sided_market.default_2a, two_sided_market.infinite_bus, two_sided_market.offer_reposted_at_old_offer_rate, two_sided_market.one_cep_one_load, two_sided_market.one_load_5_pv_partial, two_sided_market.one_load_one_storage, two_sided_market.one_pv_one_load, two_sided_market.one_pv_one_storage, two_sided_market.one_storage_5_pv_partial, two_sided_market.user_min_rate_profile_load_dict, two_sided_market.with_balancing_market, two_sided_pay_as_clear.default_2a, two_sided_pay_as_clear.test_clearing_energy] -g, --settings-file TEXT Settings file path --slowdown INTEGER Slowdown factor [0 - 10,000]. Where 0 means: no slowdown, ticks are simulated as fast as possible; and 100: ticks are simulated in realtime --seed TEXT Manually specify random seed --paused Start simulation in paused state [default: False] --pause-at TEXT Automatically pause at a certain time. Accepted Input formats: (YYYY-MM-DD, HH:mm) [default: disabled] --repl / --no-repl Start REPL after simulation run. [default: False] --no-export Skip export of simulation data --export-path TEXT Specify a path for the csv export files (default: ~/d3a-simulation) --enable-bc Run simulation on Blockchain --compare-alt-pricing Compare alternative pricing schemes --start-date DATE Start date of the Simulation (YYYY-MM-DD) [default: 2019-09-27] --help Show this message and exit.","title":"How to launch Simulation via Command Line Interface (CLI)"},{"location":"launch-sim-via-cli/#example-simulation-call","text":"d3a -l ERROR run --duration=24h --tick-length=1s --slot-length=15m --cloud-coverage=0 --market-count=5 --setup default_2a","title":"Example simulation call:"},{"location":"launch-sim-via-cli/#getting-help-in-the-command-line","text":"d3a --help returns: Usage: d3a [OPTIONS] COMMAND [ARGS]... Options: -l, --log-level [CRITICAL|FATAL|ERROR|WARN|WARNING|INFO|DEBUG|NOTSET|TRACE] Log level [default: INFO] --help Show this message and exit. Commands: run* resume d3a run --help returns: Usage: d3a run [OPTIONS] Options: -d, --duration INTERVAL Duration of simulation [default: 1d] -t, --tick-length INTERVAL Length of a tick [default: 1s] -s, --slot-length INTERVAL Length of a market slot [default: 15m] -c, --cloud-coverage INTEGER Cloud coverage, 0 for sunny, 1 for partial coverage, 2 for clouds. [default: 0] -m, --market-count INTEGER Number of tradable market slots into the future [default: 1] --setup TEXT Simulation setup module use. Available modules: [1000_houses, area_events.cloud_coverage_event, area_events.disable_interval_event, area_events.disconnect_interval_event, area_events.isolated_connect_event, area_events.isolated_disable_event, area_events.isolated_disconnect_event, area_events.isolated_enable_event, area_events.load_event, area_events.pv_event, area_events.storage_event, balancing_market.default_2a, balancing_market.one_load_one_pv, balancing_market.one_load_one_storage, balancing_market.one_storage_one_pv, balancing_market.test_device_registry, balancing_market.two_sided_one_load_one_pv, config_parameter_test, default_2, default_2a, default_2b, default_3, default_3_pv_only, default_3a, default_3b, default_4, default_5, default_addcurve, default_addcurve2, default_csv, graphs_testing, jira.d3asim_1024, jira.d3asim_1139, jira.d3asim_638_custom_load, jira.d3asim_639_custom_storage, jira.d3asim_640_custom_pv, jira.d3asim_778, jira.d3asim_780, jira.d3asim_869, jira.d3asim_871, jira.d3asim_895, jira.d3asim_895_pr1, jira.d3asim_895_pr2, jira.d3asim_895_pr3, jira.d3asim_962, jira.default_2off_d3asim_1475, jira.default_595, jira.default_611, jira.default_613, jira.default_623, jira.default_645, jira.default_737, jira.test_strategy_custom_load, jira.test_strategy_custom_pv, jira.test_strategy_custom_storage, json_arg, json_file, non_compounded_grid_fees, redis_communication_default_2a, sam_config, sam_config_const_load, sam_config_small, strategy_tests.commercial_producer_market_maker_rate, strategy_tests.ess_capacity_based_sell_offer, strategy_tests.ess_sell_offer_decrease_based_on_risk_or_rate, strategy_tests.finite_power_plant, strategy_tests.finite_power_plant_profile, strategy_tests.home_cp_ess_load, strategy_tests.home_hybrid_pv_ess_load, strategy_tests.infinite_bus, strategy_tests.predefined_pv_test, strategy_tests.pv_const_price_decrease, strategy_tests.pv_final_selling_rate, strategy_tests.pv_initial_pv_rate_option, strategy_tests.pv_max_panel_output, strategy_tests.pv_max_panel_power_global, strategy_tests.pv_risk_based_price_decrease, strategy_tests.storage_buys_and_offers, strategy_tests.storage_strategy_break_even_hourly, strategy_tests.user_profile_load_csv, strategy_tests.user_profile_load_csv_multiday, strategy_tests.user_profile_load_dict, strategy_tests.user_profile_pv_csv, strategy_tests.user_profile_pv_dict, strategy_tests.user_profile_wind_csv, strategy_tests.user_rate_profile_load_dict, tobalaba.one_producer_load, two_sided_market.default_2a, two_sided_market.infinite_bus, two_sided_market.offer_reposted_at_old_offer_rate, two_sided_market.one_cep_one_load, two_sided_market.one_load_5_pv_partial, two_sided_market.one_load_one_storage, two_sided_market.one_pv_one_load, two_sided_market.one_pv_one_storage, two_sided_market.one_storage_5_pv_partial, two_sided_market.user_min_rate_profile_load_dict, two_sided_market.with_balancing_market, two_sided_pay_as_clear.default_2a, two_sided_pay_as_clear.test_clearing_energy] -g, --settings-file TEXT Settings file path --slowdown INTEGER Slowdown factor [0 - 10,000]. Where 0 means: no slowdown, ticks are simulated as fast as possible; and 100: ticks are simulated in realtime --seed TEXT Manually specify random seed --paused Start simulation in paused state [default: False] --pause-at TEXT Automatically pause at a certain time. Accepted Input formats: (YYYY-MM-DD, HH:mm) [default: disabled] --repl / --no-repl Start REPL after simulation run. [default: False] --no-export Skip export of simulation data --export-path TEXT Specify a path for the csv export files (default: ~/d3a-simulation) --enable-bc Run simulation on Blockchain --compare-alt-pricing Compare alternative pricing schemes --start-date DATE Start date of the Simulation (YYYY-MM-DD) [default: 2019-09-27] --help Show this message and exit.","title":"Getting help in the command line:"},{"location":"libraries/","text":"Libraries are pre-configured devices, Areas, and even small grids that can be reused in different simulations. The List of libraries is paginated. You can either click through the pages by pressing the \"Prev\" or \"Next\" button on the bottom right corner or use the search field on the top right to filter the list by the library names. The following buttons and labels can be seen in the Library page: Denotes public Libraries (other users can see the Library and the uploaded profiles): & (in the search bar) Quicklook labels for showing which kind of devices (and how many) are used in the library and whether they are areas: With this button the user can edit the library (or view public libraries): With this button the user can rename, duplicate or delete the library (only his own library): The user can also create a new library (redirects to Grid setup ):","title":"Libraries"},{"location":"load-strategy/","text":"In the one sided market, loads buy the cheapest offers available to them. However, they can also set a limit to the maximum price they are willing to pay. To configure a load, the user can input the following parameters: avg_power_W : average consuming power of the load. Unit is Watts. This is a required parameter. hrs_of_day : list representing a daily schedule that contains the hours where the load is allowed to consume energy. Default value is None , meaning that the load is allowed to consume energy during every hour of the day. See addendum below for more information. hrs_per_day : number of hours per day that the load is consuming power. The initial value is None , meaning that the load will consume energy for all the hours listed in the hrs_of_day parameter. See addendum below for more information. update_interval : time after which the rate should be updated (type: pendulum duration object). Range \u2192 [1:(slot_length_minute-1)] initial_buying_rate : initial rate in ct/kWh. final_buying_rate : final rate in ct/kWh. use_market_maker_rate: If this flag is set True , then agent's final_buying_rate would be overwritten with Market Maker Strategy 's defined energy_rate. energy_rate_increase_per_update : explicit rate decrease increment in cents. fit_to_limit: derive bidding behaviour from a linear fitted curve of a buying rate between initial_buying_rate and final_buying_rate (boolean value) within the bidding interval. If activated, energy_rate_increase_per_update = (final_buying_rate - initial_buying_rate) / max(int((slot_length / update_interval) -1), 1) In order to enable the load to participate in balancing market, a prerequisite is to add the load device in \" Device Registry \" and set the following parameters: balancing_energy_ratio : tuple with 2 values. The first value dictates the ratio of energy to be demanded in balancing market, i.e. committing to voluntary ramping-up consumption. The second value dictates the ratio of energy to be supplied in balancing market, i.e. committing to voluntary ramping down of consumption (default value: tuple(0.1, 0.1)). The Load will increase its acceptable energy rate linearly in the frame of a market slot of a one-sided market. It will start at the initial_buying_rate and end at final_buying_rate . Corresponding code: src/ 3a/models/strategy/load_hours.py How to add load device to setup-file: Area ( 'Load' , strategy = LoadHoursStrategy ( avg_power_W = 200 , hrs_per_day = 6 , hrs_of_day = list ( range ( 12 , 18 )), initial_buying_rate = 0 , final_buying_rate = 35 ), appliance = SwitchableAppliance ()) Addendum: hrs_of_day and hrs_per_day hrs_of_day defines the allowed time-window in which the load has to consume for a time defined by hrs_per_day . For example, a user can input 5 hrs_per_day , for example and give a wider range for hrs_of_day like (2,18). The 5 programmed hours will be consumed \"greedily\" during this period, meaning that the Load will try to consume as fast as possible if there are any offered energy to purchase within the limits of initial_buying_rate and final_buying_rate set parameters . So if there is sufficient energy with affordable rates, the load will consume in the hours first 5 hours, i.e. from 02:00 until 07:00, with no energy demand being unmatched. In case energy prices would be too high during the time-interval from 04:00 to 16:00, the load will consume from 02:00 until 04:00, turn off, and consume from 16:00 until 18:00, resulting in 1 hour of energy demand being unmatched. For information on buying rate decrease behaviour, please see: Energy Rate Settings and Behaviour . Relation of different parameters for energy pricing \u00b6 Let's assume the user has configured its LoadStrategy with these parameters (initial_buying_rate=0, final_buying_rate=30, fit_to_limit=True, update_interval=5mins) and slot_length=15min . At the start of market, LOAD would place its initial bid at the rate of initial_buying_rate . If fit_to_limit is set to True , it will gradually increase its bid_rate linearly such that its final_bid before the end of market_slot should be equal to final_buying_rate . Number of available updates in such a case is (slot_length / update_interval) -1) \u2192 (15/5 -1)=2 . Therefore, it is possible for a user to update its offer two times inside the same market_slot . The first update would happen at 5mins. The calculated energy_rate_decrease_per_update \u2192 (30 - 0) / 2 \u2192 15 . So, the Load will increase its buying_rate at the 5th min from 0 to 15 cts/kWh and at the 10th min from 15 to 30 cts/kWh.","title":"Load Strategy"},{"location":"load-strategy/#relation-of-different-parameters-for-energy-pricing","text":"Let's assume the user has configured its LoadStrategy with these parameters (initial_buying_rate=0, final_buying_rate=30, fit_to_limit=True, update_interval=5mins) and slot_length=15min . At the start of market, LOAD would place its initial bid at the rate of initial_buying_rate . If fit_to_limit is set to True , it will gradually increase its bid_rate linearly such that its final_bid before the end of market_slot should be equal to final_buying_rate . Number of available updates in such a case is (slot_length / update_interval) -1) \u2192 (15/5 -1)=2 . Therefore, it is possible for a user to update its offer two times inside the same market_slot . The first update would happen at 5mins. The calculated energy_rate_decrease_per_update \u2192 (30 - 0) / 2 \u2192 15 . So, the Load will increase its buying_rate at the 5th min from 0 to 15 cts/kWh and at the 10th min from 15 to 30 cts/kWh.","title":"Relation of different parameters for energy pricing"},{"location":"load/","text":"The following parameters can be set in the Load Strategy: Name: Must be unique. When number of duplicates greater than 1, a number is appended to the individual names. Load profile : The user can choose between two options: User configured profile (in which case a load profile can be uploaded that is compliant with Upload File Formats ) User Upload Profile (in which case the user has to provide the Average Power of the load) Average power: Average power consumed by the load. Hours per day: The number of hours the Load operates per day. Hours of day: The time range in which the load operates. Initial buying rate: Initial energy buying rate at the beginning of each market slot. Final buying rate: Final energy buying rate at the end of each market slot. Rate increase: Explicit rate increase increment Fit to limits: Derive bidding behavior from a linear fitted curve of a buying rate between initial_buying_rate and final_buying_rate within the bidding interval. If activated, energy rate_increase = (final_buying_rate - initial_buying_rate) / max(int((slot_length / update_interval) -1), 1) Update interval: The frequency at which the rate is updated. For further general information about this strategy follow the backend Load Strategy manual. The configuration interface is shown below:","title":"Load"},{"location":"market-maker-strategy/","text":"The Market Maker Strategy mimics the behaviour of a typical energy utility and is used as a reference point. It can work in following modes: grid_connected : In this mode, it has the ability to meet the infinite energy demands of consumers at the most expensive 'energy_rate' that could exist in that grid. islanded : In this mode, it won\u2019t fulfill the energy demands of any consumer but would only be used as a reference point of the highest possible energy_rate that could exist in that grid. Following are the parameters needed for its configuration: energy_rate : It could be a float value OR a time-series value that gives the ability to have different value for every market_slot . grid_connected : If set to True , enables it to work in grid_connected' mode as explained above. OTHERWISE, it would operate in islanded mode. Corresponding code: src/d3a/setup/strategy_tests/market_maker_strategy.py How to add Market Maker to the setup-file: Area('Market Maker', strategy=MarketMakerStrategy(energy_rate=35, grid_connected=True), appliance=SimpleAppliance()),","title":"Market Maker Strategy"},{"location":"market-maker/","text":"The following parameters can be set in the Market Maker. Name: The name of the Market Maker. Role: The user has two options: Infinite power plant, grid connected: In this mode, it has the ability to meet the infinite energy demands of consumers at the most expansive rate that could exist in that grid. Pricer setter, islanded microgrid: In this mode, it won\u2019t fulfill the energy demands of any consumer but would only be used as a reference point of highest possible energy_rate that could exist in that grid. Market maker rate type: The user can choose either User Input to define a fixed rate defined by the Market maker rate or to upload their own Market Maker profile. Market maker rate: The fixed rate the Market Maker will enforce, if User Input is chosen for the Market maker rate type . For further general information about this strategy, follow the backend Market Maker Strategy manual. The configuration interface is shown below:","title":"Market Maker"},{"location":"market-slots-and-ticks/","text":"Spot Market Slots \u00b6 The energy spot market is broken into slots, the default is set to 15 minutes of simulation time. For a one day simulation, 96 market slots would occur with the default setting. See How to launch Simulation via Command Line Interface for how to adjust market slot length. Depending on the market type, bids and asks are either matched within or at the end of each slot. Bids and asks that remain unmatched at the end of a market slot are deleted. Market Ticks \u00b6 Each slot is further incremented into ticks. The default setting for a tick is 15 seconds of simulation time, but is configurable . The default 15 minute market slot is made up of 60 15-second ticks. The real-time length of both market slots and ticks is determined by the configurable simulation time scale (e.g. 1 simulation-time hour = 1 real-time minute) With the API, agents are limited to one update to their bids and asks per tick (60 per market slot). In a pay-as-bid market, the market is cleared at the end of each tick. An order submitted in a tick could be matched at the end of that tick. If the order is not matched, it is propogated to all adjacent markets by the Inter-Area Agent for the next tick. If it is not matched at the end of that tick, it is further propagated to connected markets in the subsequent ticks following the same logic. For example, assume a bid is created in market A in tick t1 . If markets A and D are separated by markets B and C , market D would see an unmatched offer from market A in t4 . If a match is found in market D , the orders would simultaneously clear in both markets at the end of t4 in a pay-as-bid market. In a pay-as-clear market, offers still propagate to adjacent markets each tick. However, clearing happens at the determined clear frequency (default is 3 times per market slot).","title":"Market Slots and Ticks"},{"location":"market-slots-and-ticks/#spot-market-slots","text":"The energy spot market is broken into slots, the default is set to 15 minutes of simulation time. For a one day simulation, 96 market slots would occur with the default setting. See How to launch Simulation via Command Line Interface for how to adjust market slot length. Depending on the market type, bids and asks are either matched within or at the end of each slot. Bids and asks that remain unmatched at the end of a market slot are deleted.","title":"Spot Market Slots"},{"location":"market-slots-and-ticks/#market-ticks","text":"Each slot is further incremented into ticks. The default setting for a tick is 15 seconds of simulation time, but is configurable . The default 15 minute market slot is made up of 60 15-second ticks. The real-time length of both market slots and ticks is determined by the configurable simulation time scale (e.g. 1 simulation-time hour = 1 real-time minute) With the API, agents are limited to one update to their bids and asks per tick (60 per market slot). In a pay-as-bid market, the market is cleared at the end of each tick. An order submitted in a tick could be matched at the end of that tick. If the order is not matched, it is propogated to all adjacent markets by the Inter-Area Agent for the next tick. If it is not matched at the end of that tick, it is further propagated to connected markets in the subsequent ticks following the same logic. For example, assume a bid is created in market A in tick t1 . If markets A and D are separated by markets B and C , market D would see an unmatched offer from market A in t4 . If a match is found in market D , the orders would simultaneously clear in both markets at the end of t4 in a pay-as-bid market. In a pay-as-clear market, offers still propagate to adjacent markets each tick. However, clearing happens at the determined clear frequency (default is 3 times per market slot).","title":"Market Ticks"},{"location":"market-smart-contract/","text":"The market smart contract is used for performing energy transactions, in exactly the same manner as the Market Python class. There are 3 main non-view functions/transactions (functions that actually mutate the state of the blockchain) on the contract: offer() : Places an energy offer to the market. Needs the offered energy and the offer price as arguments. The smart contract generates an offer id and stores the offer in its 'offers' mapping, similar to its Python counterpart. Emits a NewOffer event on success, which will notify the listeners of the contract about the new offer that was created. cancel() : Removes a previously created offer from the market. Needs the offer id in bytes as argument. This function removes the offer id from the 'offers' mapping. Emits a CancelOffer event to notify the listeners about the deleted offer. trade() : Performs an energy trade. Needs the selected offer id and the desired traded energy as arguments. Similar to the accept_offer Python function, it checks whether the selected offer is eligible for this trade and performs the actual trade. In case the desired energy is less than the offer energy, a partial trade is performed and a new residual offer is generated. The listeners get notified for the offer change by an OfferChanged event that gets emitted, which notifies the listeners about the new and the old offer ids, along with the new offer energy and price. On a successful trade, a NewTrade event is also emitted, which notifies the listeners about the trade that was performed. This contract is also responsible for the energy and token balance of the devices registered in it. For the energy balance, it is stored directly on the market contract ('balances' mapping). As for the token balance, a separate smart contract is responsible ( ClearingToken ) which is invoked via an external function during the trade function, in order to update the price/token balances of the buyer and the seller of the trade.","title":"Market Smart Contract"},{"location":"markets/","text":"Status Quo \u00b6 To give a better overview of the interaction of the D3A with the existing electrical grid, we first discuss a typical market structure: The main goal of an electricity market is always to balance the grid in terms of demand and supply. Since massive storage of energy is currently not economically feasible and electrical current varies within seconds, a market structure that efficiently allocates production and consumption is necessary. Generally, trading occurs in three different kind of markets that each have different time intervals: Futures market: futures (long term trades) between consumption and production are agreed upon. This market is currently left outside the scope of D3A implementation. Spot market: typically 15 minutes, agents within the grid are trading through a one-sided pay-as-offer, double-sided pay-as-bid or double-sided pay-as-clear auction. Grid balancing market: imbalances that occur between agreements in the spot market due to changes in consumption and production are absorbed by balance responsible parties that are reimbursed for their service. D3A \u00b6 The current implementation of the D3A focuses on the spot & balancing market. In contrast to the status quo, balancing markets take place in parallel to the spot markets (if enabled). The duration of the markets can be configured. Currently, three spot market types are implemented: One sided pay-as-offer Two sided pay-as-bid Two sided pay-as-clear In the d3a setup file, the spot market type can be defined by the following line (example for one sided pay-as-offer): ConstSettings.IAASettings.MARKET_TYPE = 1 Setting the market type influences the behaviour of both the markets as well as the behaviour of the devices or agents. For individual behaviour of the device strategies please refer to Strategies documentation.","title":"Markets Overview"},{"location":"markets/#status-quo","text":"To give a better overview of the interaction of the D3A with the existing electrical grid, we first discuss a typical market structure: The main goal of an electricity market is always to balance the grid in terms of demand and supply. Since massive storage of energy is currently not economically feasible and electrical current varies within seconds, a market structure that efficiently allocates production and consumption is necessary. Generally, trading occurs in three different kind of markets that each have different time intervals: Futures market: futures (long term trades) between consumption and production are agreed upon. This market is currently left outside the scope of D3A implementation. Spot market: typically 15 minutes, agents within the grid are trading through a one-sided pay-as-offer, double-sided pay-as-bid or double-sided pay-as-clear auction. Grid balancing market: imbalances that occur between agreements in the spot market due to changes in consumption and production are absorbed by balance responsible parties that are reimbursed for their service.","title":"Status Quo"},{"location":"markets/#d3a","text":"The current implementation of the D3A focuses on the spot & balancing market. In contrast to the status quo, balancing markets take place in parallel to the spot markets (if enabled). The duration of the markets can be configured. Currently, three spot market types are implemented: One sided pay-as-offer Two sided pay-as-bid Two sided pay-as-clear In the d3a setup file, the spot market type can be defined by the following line (example for one sided pay-as-offer): ConstSettings.IAASettings.MARKET_TYPE = 1 Setting the market type influences the behaviour of both the markets as well as the behaviour of the devices or agents. For individual behaviour of the device strategies please refer to Strategies documentation.","title":"D3A"},{"location":"one-sided-pay-as-offer/","text":"The market object collects offers and serves the functionality of accepting and deleting offers as well as dispatching these offer events to its listeners (other areas and their markets). The auction is continuous, meaning that once an offer is posted, it can be accepted right away, even before the end of the slot market. Energy producing agents (or \u201csellers\u201d) post offers in the market with an energy price determined by the devices' strategy. Consuming agents (or \u201cbuyers\u201d) can see the offers available in their local market, filter the affordable offers and then select the cheapest offer among them. The energy rate by which the seller and buyer settle is the price of the offer (pay-as-offer). Consequently, the trade rate may be different than other trades settled in the same slot. An Inter-Area Agent is created and operated by each area. Its job is to forward offers to the connected markets. It does not have any strategy allocated to it.","title":"One Sided Pay-As-Offer"},{"location":"power-plant/","text":"The following parameters can be set in the Power Plant Strategy. Name: Must be unique. When number of duplicates greater than 1, a number is appended to the individual names. Energy rate: Selling price of the power plant. Maximum available power: Maximum power that the power plant can supply. For further general information about this strategy, follow the backend Finite Power Plant Strategy manual. The configuration interface is shown below:","title":"Power Plant"},{"location":"projects-home-page/","text":"After logging in, the user lands on the home page. It shows an overview of all projects and configurations. Projects can be either private or public. Projects can be set up as separate use cases or grid locations in order to keep versions organized in one project folder. Within a project, the user can make several versions by creating duplicates of simulations and thus iteratively optimizing a particular grid configuration or use case. Public projects will appear on the user's home page. The simulations in these projects can be viewed by the user as examples and also duplicated to a new project made by the user. As a duplicated simulation in a user's own project, the user can edit the simulation. Projects \u00b6 Projects can be used to group simulations. They can be seen as folders in which simulations are located. Before creating a simulation, a project has to be created by selecting the New Project button: The following symbol notifies the user that a project is public : Simulations \u00b6 To create a new simulation, select the New Simulation button shown below. The user will then be redirected to the General Settings . The following quick links are available for each simulation: Run the simulation and redirect the user to the Results Page Redirects the user to the Results Page Edit the General Settings of the simulation Edit the grid setup of the simulation Duplicate the configuration, download the results or delete the simulation Search \u00b6 Projects and simulation can be filtered by name, using this search field found on the upper right: Compare \u00b6 The user can compare 2 simulations results side by side by clicking on the compare icon:","title":"Projects (Home Page)"},{"location":"projects-home-page/#projects","text":"Projects can be used to group simulations. They can be seen as folders in which simulations are located. Before creating a simulation, a project has to be created by selecting the New Project button: The following symbol notifies the user that a project is public :","title":"Projects"},{"location":"projects-home-page/#simulations","text":"To create a new simulation, select the New Simulation button shown below. The user will then be redirected to the General Settings . The following quick links are available for each simulation: Run the simulation and redirect the user to the Results Page Redirects the user to the Results Page Edit the General Settings of the simulation Edit the grid setup of the simulation Duplicate the configuration, download the results or delete the simulation","title":"Simulations"},{"location":"projects-home-page/#search","text":"Projects and simulation can be filtered by name, using this search field found on the upper right:","title":"Search"},{"location":"projects-home-page/#compare","text":"The user can compare 2 simulations results side by side by clicking on the compare icon:","title":"Compare"},{"location":"pv-strategy/","text":"The PV strategy determines the price of the PV offers on the spot market. It also determines what to do when its offer is not immediately accepted by a buyer. Initial parameters that can be defined include: panel_count : The number of panels in the simulation max_panel_power_W : Peak power rating per panel update_interval : time after which the rate should be updated (type: pendulum duration object). Range[1:(slot_length_minute-1)] final_selling_rate : The minimum offer rate (ct/kWh) initial_selling_rate : The maximum offer rate (ct/kWh) use_market_maker_rate : If this flag is set True , then agent's initial_selling_rate would be overwritten with Market Maker Strategy 's defined energy_rate energy_rate_decrease_per_update : It is configured as the cents/kWh decrease per update. fit_to_limit : derive bidding behaviour from a linear fitted curve of a buying rate between initial_selling_rate and final_selling_rate (boolean value) within the bidding interval. If activated, energy_rate_decrease_per_update = (initial_selling_rate - final_selling_rate) / max(int((slot_length / update_interval) -1), 1) . For information buying rate decrease behaviour, please see: Energy Rate Settings and Behaviour . The PV profile can be configured as a saved profile here (via choosing the PVPredefinedStrategy ): cloud_coverage : (0: sunny; 1: partially cloudy; 2: cloudy). Using this parameter, the simulation allows the user to choose between three solar curves that are stored in the simulation for convenience. No default value for this parameter. Corresponding code: src/d3a/models/strategy/pv.py or for the predefined PV: src/d3a/models/strategy/predefined_pv.py How to add a PV device to the setup-file: Area('H2 PV', strategy=PVStrategy(panel_count=4, initial_selling_rate=30, final_selling_rate=5, fit_to_limit=True, update_interval=duration(minutes=5)), appliance=PVAppliance()), In order to understand how the strategy is actually decreasing its offered_rate in the case of not getting traded, see the following diagram. Relation of different parameters for energy pricing \u00b6 Lets assume the user has configured its PVStrategy with these parameters (initial_selling_rate=30, final_selling_rate=0, fit_to_limit=True, update_interval=5mins) and slot_length=15min At the start of market, PV would place its initial offer at the rate of initial_selling_rate . If fit_to_limit is set to True , it will reduce its offer_rate linearly such that its final_offer before the end of market_slot should be equal to final_selling_rate . Number of available updates in such a case is (slot_length / update_interval) -1) \u2192 (15/5 -1)=2 . Therefore, it is possible for a user to update its offer two times inside the same market_slot . The first update would happen at 5mins. The calculated energy_rate_decrease_per_update \u2192 (30 - 0) / 2 \u2192 15 . So, the PV will reduce it selling_rate at 5th min from 30 to 15 cts/kWh and at 10th min from 15 to 0 cts/kWh.","title":"PV Strategy"},{"location":"pv-strategy/#relation-of-different-parameters-for-energy-pricing","text":"Lets assume the user has configured its PVStrategy with these parameters (initial_selling_rate=30, final_selling_rate=0, fit_to_limit=True, update_interval=5mins) and slot_length=15min At the start of market, PV would place its initial offer at the rate of initial_selling_rate . If fit_to_limit is set to True , it will reduce its offer_rate linearly such that its final_offer before the end of market_slot should be equal to final_selling_rate . Number of available updates in such a case is (slot_length / update_interval) -1) \u2192 (15/5 -1)=2 . Therefore, it is possible for a user to update its offer two times inside the same market_slot . The first update would happen at 5mins. The calculated energy_rate_decrease_per_update \u2192 (30 - 0) / 2 \u2192 15 . So, the PV will reduce it selling_rate at 5th min from 30 to 15 cts/kWh and at 10th min from 15 to 0 cts/kWh.","title":"Relation of different parameters for energy pricing"},{"location":"pv/","text":"The following parameters can be configured in the PV Strategy: Name: Must be unique. When number of duplicates greater than 1, a number is appended to the individual names. Panel count: How many PV panels should be attached, each panel creates a power of 250W. Solar Profile: The user can choose between multiple solar profiles ( sunny, partially cloudy or cloudy ). If the user wants to use a different power output per panel, they can create a Gaussian curve or upload their own generation profile. Initial selling rate: Initial energy rate that the PV offers at the beginning of each market slot. The initial selling rate is defined and frozen by the marker maker rate. Final selling rate: Final energy rate that the PV offers at the end of each market slot. Rate decrease: Explicit rate decrease increment. Fit to limits: Derive bidding behavior from a linear fitted curve of a selling rate between initial_selling_rate and final_selling_rate within the bidding interval. If activated, energy_rate_decrease_per_update = (initial_selling_rate - final_selling_rate) / max(int((slot_length / update_interval) -1), 1) Update interval: The frequency at which the rate is updated. For further general information about this strategy, follow the backend PV Strategy manual. The configuration interface is shown below:","title":"PV"},{"location":"results/","text":"Navigating your configuration grid The D3A allows energy devices to trade inside energy markets. During trading, the user can view what is happening at the energy device level and at the market level. Since a D3A grid is build up into a hierarchy of multiple markets, we use a folder structure to navigate through the grid simulation results. The user can select a market , which brings the user to the result page of this specific market; or, you can select a device (located inside a market) to bring the user to the results page of this specific device. In the above figure, the community market is selected. Simulation Results When selecting a market, the results page will show you various relevant plots and tables. This section will discuss each of these results. Energy Availability This plot shows whether or not each energy device inside the selected market had access to the energy it needed. On the x-axis, the time is given. If the participating agent was able to get the energy it wants, at a certain time, the block at that time will appear green. If not, it will appear purple. The granularity of the plot is 1 hour, so if there has been a trade interval (possibly <1 hour length) within the hour in which the agent was not able to buy the demanded energy, the whole block will turn purple. The user can hover over a purple block to see a list of the devices not able to buy for that time slot. Cumulative trading This plot shows the total trade volumes that have been traded between market participants in the selected market over the simulation's duration. Market participants are the agents (representing a device or an area) immediately inside the selected market. Each bar has its own color to represent its sold energy. Energy sold is negative and energy bought is positive. In this example, the energy sold by House 1 is purple. House 1 also has a positive purple bar, meaning that it bought some of its own energy production. The rest of its energy production was sold as the thin purple layer shown in the bar of the other market participants. By using this color coding, the user can visually track how energy has flowed in a specific market. The external trades represent energy produced in this market, but sold to an outside market (the positive bar layers containing the colors of each participant) and the energy bought from an external source and sold to a participant in this market. The energy bought externally is teal in this example and is the negative bar for External Trades. This energy was sold to the other participants where a positive teal colored bar can be seen (all participants). Energy bills The energy bills provide information on the cumulative trade volumes of all market participants and the costs associated with these trades. For each agent, including the external trades, the energy bought and sold during the simulation is listed, along with a total net consumption. The \"Totals\" column can be considered as the net energy consumption and final bill to the listed agent, which may represent a device or an area of ownership. Negative values for costs stands for a profit. Accumulated Trades represents the total of trades that are made by the agents inside the selected area. External Trades represents the import/export from/to a higher level market by the inter-area agent of the selected market, and hence represents the difference between energy traded inside the community and the total accumulated trades. In this example, we have the Community market selected. In the Community market, the participating agents are the inter-area agents of the houses that lie inside of the community area. Energy profile The energy profile shows both the demand-side as supply-side of the trades made inside the selected market for every market interval of the simulation. The negative side of the y-axis represents the energy sold, and the positive y-axis shows the energy bought. The different colors represent the different agents. As all buyers and sellers of each trade are accounted for in a select market, the supply and demand sides should be exact mirrors of each other in terms of volume. Energy prices In this plot, energy pricing is shown. In case of multiple clearing moments within a market interval (depending on market design and grid configuration), there could be different prices for different trades in the market interval. In this case, an average of the trade price is shown. In addition, the minimum and maximum price on that time of the day for all days of simulation is provided. If there was no trade happening during a certain market interval, the price is set to zero at that time. Compare results The user has the possibility to compare the results to another simulation (in order to compare results, the simulation should already have been run). The user can also download the results using the interface shown below: Settings The user have the possibility to duplicate the setup, download the results of their simulation or delete the configuration:","title":"Results"},{"location":"run-d3a-on-tobalaba/","text":"Following are the prequisite to run D3A on tobalaba: Please install Parity client . Open your terminal and launch the tobalaba node with: parity --chain tobalaba --jsonrpc-apis=all --jsonrpc-cors=all Goto /Users/<user>/Library/Application Support/io.parity.ethereum/keys and overwrite Tobalaba.zip after unzipping it (PS: Do backup your already existing keys, if you need them later). Launch the simulation on tobalaba via cli: d3a -l INFO run -t 15s -s 60m -m 1 --enable-bc --setup tobalaba.<setup_file_name>","title":"Steps to Run D3A on Tobalaba"},{"location":"simulation-configuration/","text":"To start building a simulation, the user is guided through the simulation configuration pages. These pages allow a user to model their use-case and D3A market structure that the energy devices in their model will use to trade energy. The simulation configuration consists of two steps: General Settings , where general simulation parameters can be set. Grid setup , where the user can build the grid configuration for their use-case.","title":"Simulation Configuration Overview"},{"location":"simulation-events/","text":"Simulation events are changes in the configuration/setup that take place during normal execution of a simulation. They have to be defined by the user in the setup files before the start of the simulation, and they are associated with a specific point in time (or duration), at which point the event is triggered. An event has to be associated with an area, thus there is a new constructor parameter on the area, namely ' event_list ', that accepts a list of events for this specific area. There are 4 different event types: Add/Remove area event Connect/Disconnect area event Strategy events Config events Each is described in detail below. Add/Remove area event \u00b6 This event is associated with an area, and dictates that this area (and its children) will be added or removed from the grid at a specific point in time. There are 2 ways to configure this behaviour, either via individual events ( EnableAreaEvent and DisableAreaEvent ) or to configure this area to be disabled for a time interval ( DisableIntervalAreaEvent ). EnableAreaEvent / DisableAreaEvent accept only one argument, which is the hour that this event is triggered (hourly resolution is supported in events for now, minute resolution is under consideration if we see the need for it), and this area will be enabled/disabled at this specific point in time no matter its current state. DisableIntervalAreaEvent on the other hand, accepts 2 arguments, which denote the start hour and the end hour that the area is disabled. The term 'disabled area' means that the area and all the areas under it are not performing any trading, meaning that the entire sub-tree based on this area is taken off the simulation for the time that the area is disabled. Once the area is enabled, the sub-tree will continue to operate. It is designed this way in order to simulate areas being added or removed from the grid, since it is easier to configure and much more optimal for the UI and D3A to have one configuration scenario with parts of it being disabled at certain points in time, instead of creating new areas during the simulation. You can find examples for these events on github: EnableAreaEvent : isolated_enable_event.py DisableAreaEvent : isolated_disable_event.py DisableIntervalAreaEvent : disable_interval_event.py Connect/Disconnect area event \u00b6 These events are similar to the enable/disable event, both event types have a similar API and both are used for removing an area from the grid. The difference between the 2 is that the Connect/Disconnect events are decoupling their children from the main grid, meaning that during the time that the event is enabled, there are going to be 2 independent grids both trading energy internally, but not trading energy to each other. This is contrary to enable/disable event, where the sub-tree is not performing any trades at all. This is useful to showcase examples from grids that are abruptly decoupled from the main grid, but manage to self-sustain their devices by continuing to trade energy even after they are disconnected from the main grid. You can find examples for these events on github: ConnectAreaEvent : isolated_connect_event.py DisconnectAreaEvent : isolated_disconnect_event.py DisconnectIntervalAreaEvent : disconnect_interval_event.py Strategy events \u00b6 These events are used to change the parameters of the strategy of an area during the simulation runtime. They are applicable for all types of strategies (Load, Storage and PV) and are able to modify different parameters according to the target strategy. These are distinct events and no interval event is provided for strategy events. Load StrategyEvent : load_event.py PV StrategyEvent : pv_event.py Storage StrategyEvent : storage_event.py Config events \u00b6 These events are used to change the config of an area during runtime. This event is also applied to all children of this area, meaning that if a config parameter is changed on one area, the same config parameter will be changed for its children, but not for its parents. A useful application for this is to be able to set different weather conditions for a subset of the grid. The config parameters that are available as events are cloud coverage and the PV user profile (for now, if there is a need to modify other config parameters during the simulation these will be added). Furthermore, config events are distinct and no interval event is provided. Cloud Coverage Event : cloud_coverage_event.py","title":"Simulation Events"},{"location":"simulation-events/#addremove-area-event","text":"This event is associated with an area, and dictates that this area (and its children) will be added or removed from the grid at a specific point in time. There are 2 ways to configure this behaviour, either via individual events ( EnableAreaEvent and DisableAreaEvent ) or to configure this area to be disabled for a time interval ( DisableIntervalAreaEvent ). EnableAreaEvent / DisableAreaEvent accept only one argument, which is the hour that this event is triggered (hourly resolution is supported in events for now, minute resolution is under consideration if we see the need for it), and this area will be enabled/disabled at this specific point in time no matter its current state. DisableIntervalAreaEvent on the other hand, accepts 2 arguments, which denote the start hour and the end hour that the area is disabled. The term 'disabled area' means that the area and all the areas under it are not performing any trading, meaning that the entire sub-tree based on this area is taken off the simulation for the time that the area is disabled. Once the area is enabled, the sub-tree will continue to operate. It is designed this way in order to simulate areas being added or removed from the grid, since it is easier to configure and much more optimal for the UI and D3A to have one configuration scenario with parts of it being disabled at certain points in time, instead of creating new areas during the simulation. You can find examples for these events on github: EnableAreaEvent : isolated_enable_event.py DisableAreaEvent : isolated_disable_event.py DisableIntervalAreaEvent : disable_interval_event.py","title":"Add/Remove area event"},{"location":"simulation-events/#connectdisconnect-area-event","text":"These events are similar to the enable/disable event, both event types have a similar API and both are used for removing an area from the grid. The difference between the 2 is that the Connect/Disconnect events are decoupling their children from the main grid, meaning that during the time that the event is enabled, there are going to be 2 independent grids both trading energy internally, but not trading energy to each other. This is contrary to enable/disable event, where the sub-tree is not performing any trades at all. This is useful to showcase examples from grids that are abruptly decoupled from the main grid, but manage to self-sustain their devices by continuing to trade energy even after they are disconnected from the main grid. You can find examples for these events on github: ConnectAreaEvent : isolated_connect_event.py DisconnectAreaEvent : isolated_disconnect_event.py DisconnectIntervalAreaEvent : disconnect_interval_event.py","title":"Connect/Disconnect area event"},{"location":"simulation-events/#strategy-events","text":"These events are used to change the parameters of the strategy of an area during the simulation runtime. They are applicable for all types of strategies (Load, Storage and PV) and are able to modify different parameters according to the target strategy. These are distinct events and no interval event is provided for strategy events. Load StrategyEvent : load_event.py PV StrategyEvent : pv_event.py Storage StrategyEvent : storage_event.py","title":"Strategy events"},{"location":"simulation-events/#config-events","text":"These events are used to change the config of an area during runtime. This event is also applied to all children of this area, meaning that if a config parameter is changed on one area, the same config parameter will be changed for its children, but not for its parents. A useful application for this is to be able to set different weather conditions for a subset of the grid. The config parameters that are available as events are cloud coverage and the PV user profile (for now, if there is a need to modify other config parameters during the simulation these will be added). Furthermore, config events are distinct and no interval event is provided. Cloud Coverage Event : cloud_coverage_event.py","title":"Config events"},{"location":"simulation-results/","text":"After a successful simulation run, in order to draw some conclusions over the simulation, D3A has the ability to export the simulation results. This functionality is enabled by default. If you want to disable the export of simulation results, use the --no-export flag for the simulation run. Another useful parameter is: --export-path . It changes the output path of the simulation results. The default path is $HOME/d3a-simulation/ . The simulation results include analytical information about the trades, offers, bids and balancing offers that took place in the course of the simulation. Also information about energy characteristics of each device and area agent are included (eg. battery SOC, energy traded/requested/deficit for the agents). In addition to text files, some graphs that display aggregated area information during the course of the simulation are also exposed. These can be found under 'plot' directory.","title":"Simulation Results Overview"},{"location":"storage/","text":"The following parameters can be set in the Energy Storage Strategy (ESS): Name: Must be unique. When number of duplicates greater than 1, a number is appended to the individual names. Battery capacity: Total energy capacity. Initial capacity: Can be set in two ways: Initial state of charge (in %) Initial Energy (in kWh) Minimum state of charge: Minimum energy to leave in the storage. Max power rating for battery: Power limit for each market slot for sold and bought energy. Initial selling rate: Initial energy rate for selling energy at the beginning of each market slot. Final selling rate: Final energy rate for selling energy at the end of each market slot. Rate decrease: Explicit rate decrease increment. Initial buying rate: Initial energy rate for buying energy at the beginning of each market slot. Final buying rate: Final energy rate for buying energy at the end of each market slot. Rate increase: Explicit rate increase increment. Fit to limits: Derive bidding behavior from a linear fitted curve of a buying rate between initial_buying_rate and final_buying_rate and a selling rate between initial_selling_rate and final_selling_rate within the bidding interval. If activated: energy_rate_increase = (final_buying_rate - initial_buying_rate) / max(int((slot_length / update_interval) -1), 1) energy_rate_decrease_per_update = (initial_selling_rate - final_selling_rate) / max(int((slot_length / update_interval) -1), 1) Update interval: The frequency at which the rate is updated. Capacity based method: The ESS can trade energy based on a capacity dependent sell price. For further general information about this strategy, follow the backend Energy Storage System (ESS) Strategy manual. The configuration interface is shown below:","title":"Storage"},{"location":"two-sided-pay-as-bid/","text":"In the two-sided market, buyers are able to place bids in the market, alongside the offers placed by sellers (as seen in the one-sided market). The market collects offers and bids and serves the functionality of accepting and deleting offers and bids as well as dispatching these offer and bids to other markets via the Inter-Area Agent . The auction is continuous, meaning that once an offer or bid is posted, it can be matched right away, even before the end of the slot market. An Inter-Area Agent (IAA) is created and operated by each area to deal with forwarding offers and bids to the connected markets. The area constantly triggers the matching between bids and offers according to the matching algorithm.","title":"Two Sided Pay-As-Bid"},{"location":"two-sided-pay-as-clear/","text":"In the two-sided market, buyers are able to place bids in the market, alongside the offers placed by sellers (as seen in the one-sided market). The Two Sided Pay-As-Clear behaves the same as the Two Sided Pay-As-Bid market The only difference is the offer/bid matching algorithm. Currently, there is a so-called merit-order-effect mechanism implemented that works like the following: Bids and offers are aggregated in a specified discrete interval (clearing interval). At the end of that interval, bids are arranged in a descending order, offers in an ascending order and the equilibrium quantity of energy and price is calculated. The clearing point (the amount of energy that is accepted [ trade volume ] for a specific energy rate [ clearing price ]) is determined by point where arranged bid curve for the Consumers drops below the offer curve for the Producers. All offers that have an energy rate below or equal to the clearing price are accepted and matched randomly with all bids that have an energy rate higher or equal to the clearing price. The remaining bids and offers (right of the clearing point in the plot above) are not cleared at this clearing point and stay in the market for later matching.","title":"Two Sided Pay-As-Clear"},{"location":"ui-releases/","text":"December 2019 \u00b6 The following features were implemented : Run simulations with up to 250 nodes Compare results of two simulations side by side New navigation side bar with Home, Projects, and Library easily accessible October 2019 \u00b6 The following features were implemented : Run simulations for one week Choose your market type: additional access to two-sided pay as bid and two-sided pay as clear market types New user friendly device strategies Configure your market maker Scrollable graphs on the results page optimized for longer simulations Download simulation results","title":"Releases"},{"location":"ui-releases/#december-2019","text":"The following features were implemented : Run simulations with up to 250 nodes Compare results of two simulations side by side New navigation side bar with Home, Projects, and Library easily accessible","title":"December 2019"},{"location":"ui-releases/#october-2019","text":"The following features were implemented : Run simulations for one week Choose your market type: additional access to two-sided pay as bid and two-sided pay as clear market types New user friendly device strategies Configure your market maker Scrollable graphs on the results page optimized for longer simulations Download simulation results","title":"October 2019"},{"location":"upload-file-formats/","text":"Files can be uploaded to support custom energy supply or load profiles. The following file formats are supported: Comma Separated Values (.csv) \u00b6 The separation can be done by comma , or semicolon ; Two time formats are supported, see below. Power set-points are given in Watts. D3A handles any conversions to energy (in kWh). hh:mm Example: INTERVAL;POWER(W): 00:00;10 00:15;10 00:30;10 00:45;10 01:00;10 YYYY-MM-DDThh:mm Example: INTERVAL,POWER(W) 2019-01-01T00:00,10.0 2019-01-01T00:15,10.0 2019-01-01T00:30,10.0 2019-01-01T00:45,10.0 2019-01-01T01:00,10.0 Warning : If you upload csv files with date information (second example), you should also set the start-date of the simulation (the start-date of your csv files and the one of your simulation should be identical).","title":"Upload File Formats"},{"location":"upload-file-formats/#comma-separated-values-csv","text":"The separation can be done by comma , or semicolon ; Two time formats are supported, see below. Power set-points are given in Watts. D3A handles any conversions to energy (in kWh). hh:mm Example: INTERVAL;POWER(W): 00:00;10 00:15;10 00:30;10 00:45;10 01:00;10 YYYY-MM-DDThh:mm Example: INTERVAL,POWER(W) 2019-01-01T00:00,10.0 2019-01-01T00:15,10.0 2019-01-01T00:30,10.0 2019-01-01T00:45,10.0 2019-01-01T01:00,10.0 Warning : If you upload csv files with date information (second example), you should also set the start-date of the simulation (the start-date of your csv files and the one of your simulation should be identical).","title":"Comma Separated Values (.csv)"},{"location":"user-interface-d3a/","text":"This is the user's manual to the D3A User Interface (UI) at d3a.io . For questions, comments, and feedback, please engage with us through the D3A community at gitter.im/D3A-community . We are always welcoming feedback regarding how to improve the D3A. We are starting a tutorial video series. Check out our first video here and let us know what other videos you'd like to see! We also publish videos about the new features implemented in our latest releases . In the D3A UI users can model, simulate, optimize, and (coming soon) download and deploy their own energy exchange. Each exchange will be downloadable as a set of smart contracts, allowing the exchange to be decentralized for specific use cases. When creating, configuring and running a simulation of an energy trading use-case, the D3A UI will lead the user to three pages: Projects (Home Page) Simulation Configuration Results","title":"UI Overview"}]}