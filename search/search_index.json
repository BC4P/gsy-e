{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"alternative-pricing-schemes/","text":"Alternative Pricing Schemes \u00b6 How to configure Alternative Pricing To enable comparison of 4 different pricing schemes: (0) D3A pricing (trading according the D3A hierarchical market model) (1) no-scheme pricing ( GridAgent buys at 0 ct/kWh and sells for market_maker_rate ) (2) feed-in-tariff pricing ( GridAgent buys at feed_in_tariff_percentage * market_maker_rate and sells for market_maker_rate ) (3) net metering pricing ( GridAgent buys at market_maker_rate and sells for market_maker_rate ) set the command line flag --compare-alt-pricing . This will run separate d3a-simulation s with all 4 alternative pricing schemes in parallel for the selected setup file. The results of each simulation are stored in separate subfolders in the export-path . If you want to run a simulation only for one specific pricing scheme, set it via a ConstSetting in the setup file in which you are configuring your grid, e.g. by adding the following line: ConstSettings.IAASettings.AlternativePricing.PRICING_SCHEME = 1 (You should not set this parameter and use the --compare-alt-pricing cli parameter combined) The feed-in-tariff (FIT) is a percentage that is set in the ConstSetting s as well, the default is 50%. Set this parameter yourself via a ConstSetting in the setup file in which you are configuring your grid, by adding the following line (e.g. FIT = 60% of market_maker_rate ): ConstSettings.IAASettings.AlternativePricing.FEED_IN_TARIFF_PERCENTAGE = 60 For more information we refer to Alternative Pricing Mechanisms. Alternative Pricing Mechanisms \u00b6 In the D3A, the D3A pricing mechanism (determined through the D3A market structure) can be compared to other pricing mechanisms that are currently being used by utilities and grid providers. By setting one of the three pricing schemes below, the user can calculate the energy bills from a simulation according to that scheme. This is done by adjusting the feed-in-tariff (FIT). Many energy markets have a FIT that fits one of the three scenarios that can each be configured and run in the D3A. The cost to buy electricity from the utility is known in the D3A as the market maker rate (MMR). This is because in grid connected scenarios, a community or local grid is connected to the utility grid which is modeled as an infinite power plant and sells power at the utility rate. This rate is called the market maker rate because it sets the price basis for the other buyers and sellers in the market. There are three alternative pricing schemes: No Pricing scheme : In this scheme, the households or grid customers have a 0% FIT and cannot sell any surplus energy they produce to the grid for additional income. They buy energy from the grid at the utility rate (MMR). Feed In Tariff (FIT) : In this scheme, the households or grid customers have 50% FIT (50% is the default value; it is configurable) at which they can sell surplus energy to the grid for 50% of the MMR. They buy energy from the grid at the utility rate (MMR). Net Metering (NM) : In this scheme, the households or grid customers have a 100% FIT, which is also known as net metering. This means that they can sell surplus energy to the utility at the same rate that they must pay to buy. In many implementations this means that the customer simply rolls back their meter when supplying the grid with energy and pays the net energy they have consumed each paying period times the utility rate (MMR). (In the case of 100% FIT, the customer could actually make a net income if they produce more than they consume under a flat MMR.) How the D3A engine simulates these alternative pricing schemes: All areas at the lowest level (with their own meter) are disconnected. Areas that contain children/devices are considered \"households\" or \"grid customers\". These households are allowed to trade internally; this way, household PV's are still able to supply to that respective household load, just as you would expect. The surplus PV energy is \"sold\" to the IAA of the household; the IAA does not connect to the higher level market as would be the case in D3A trading, but connects directly to a \" GridAgent \". This GridAgent reimburses the household IAA according to the FIT. Any energy bought, for instance when a household PV (if any) does not supply enough energy, is provided by the GridAgent at the MMR. See picture; in case of --compare-alt-price is flagged; the D3A grid is isolated according to the red dotted lines; and IAA are connected to the DSO/Utility grid.","title":"Alternative Pricing Schemes"},{"location":"alternative-pricing-schemes/#alternative-pricing-schemes","text":"How to configure Alternative Pricing To enable comparison of 4 different pricing schemes: (0) D3A pricing (trading according the D3A hierarchical market model) (1) no-scheme pricing ( GridAgent buys at 0 ct/kWh and sells for market_maker_rate ) (2) feed-in-tariff pricing ( GridAgent buys at feed_in_tariff_percentage * market_maker_rate and sells for market_maker_rate ) (3) net metering pricing ( GridAgent buys at market_maker_rate and sells for market_maker_rate ) set the command line flag --compare-alt-pricing . This will run separate d3a-simulation s with all 4 alternative pricing schemes in parallel for the selected setup file. The results of each simulation are stored in separate subfolders in the export-path . If you want to run a simulation only for one specific pricing scheme, set it via a ConstSetting in the setup file in which you are configuring your grid, e.g. by adding the following line: ConstSettings.IAASettings.AlternativePricing.PRICING_SCHEME = 1 (You should not set this parameter and use the --compare-alt-pricing cli parameter combined) The feed-in-tariff (FIT) is a percentage that is set in the ConstSetting s as well, the default is 50%. Set this parameter yourself via a ConstSetting in the setup file in which you are configuring your grid, by adding the following line (e.g. FIT = 60% of market_maker_rate ): ConstSettings.IAASettings.AlternativePricing.FEED_IN_TARIFF_PERCENTAGE = 60 For more information we refer to Alternative Pricing Mechanisms.","title":"Alternative Pricing Schemes"},{"location":"alternative-pricing-schemes/#alternative-pricing-mechanisms","text":"In the D3A, the D3A pricing mechanism (determined through the D3A market structure) can be compared to other pricing mechanisms that are currently being used by utilities and grid providers. By setting one of the three pricing schemes below, the user can calculate the energy bills from a simulation according to that scheme. This is done by adjusting the feed-in-tariff (FIT). Many energy markets have a FIT that fits one of the three scenarios that can each be configured and run in the D3A. The cost to buy electricity from the utility is known in the D3A as the market maker rate (MMR). This is because in grid connected scenarios, a community or local grid is connected to the utility grid which is modeled as an infinite power plant and sells power at the utility rate. This rate is called the market maker rate because it sets the price basis for the other buyers and sellers in the market. There are three alternative pricing schemes: No Pricing scheme : In this scheme, the households or grid customers have a 0% FIT and cannot sell any surplus energy they produce to the grid for additional income. They buy energy from the grid at the utility rate (MMR). Feed In Tariff (FIT) : In this scheme, the households or grid customers have 50% FIT (50% is the default value; it is configurable) at which they can sell surplus energy to the grid for 50% of the MMR. They buy energy from the grid at the utility rate (MMR). Net Metering (NM) : In this scheme, the households or grid customers have a 100% FIT, which is also known as net metering. This means that they can sell surplus energy to the utility at the same rate that they must pay to buy. In many implementations this means that the customer simply rolls back their meter when supplying the grid with energy and pays the net energy they have consumed each paying period times the utility rate (MMR). (In the case of 100% FIT, the customer could actually make a net income if they produce more than they consume under a flat MMR.) How the D3A engine simulates these alternative pricing schemes: All areas at the lowest level (with their own meter) are disconnected. Areas that contain children/devices are considered \"households\" or \"grid customers\". These households are allowed to trade internally; this way, household PV's are still able to supply to that respective household load, just as you would expect. The surplus PV energy is \"sold\" to the IAA of the household; the IAA does not connect to the higher level market as would be the case in D3A trading, but connects directly to a \" GridAgent \". This GridAgent reimburses the household IAA according to the FIT. Any energy bought, for instance when a household PV (if any) does not supply enough energy, is provided by the GridAgent at the MMR. See picture; in case of --compare-alt-price is flagged; the D3A grid is isolated according to the red dotted lines; and IAA are connected to the DSO/Utility grid.","title":"Alternative Pricing Mechanisms"},{"location":"api-overview/","text":"There are 2 available APIs to interact with a running simulation. The first one is the Asset API and allows to manage multiple assets by implementing custom trading strategies. The second API is the Market API that allows to manage multiple markets by implementing grid fee strategies based on the market statistics. API Client Installation \u00b6 Note, if you are running the d3a using a virtual machine and vagrant, the latest api-client is already installed on your machine and you can skip to the Launch Simulation section below. If you are running the d3a locally, please follow the following instructions. Install Redis server. Open a new terminal and type \u00b6 brew install redis Install d3a-client \u00b6 mkvirtualenv d3a-api-env pip install git+https://github.com/gridsingularity/d3a-api-client.git Update d3a-client (as needed when an update is deployed) \u00b6 pip uninstall d3a-api-client pip install git+https://github.com/gridsingularity/d3a-api-client.git","title":"Overview"},{"location":"api-overview/#api-client-installation","text":"Note, if you are running the d3a using a virtual machine and vagrant, the latest api-client is already installed on your machine and you can skip to the Launch Simulation section below. If you are running the d3a locally, please follow the following instructions.","title":"API Client Installation"},{"location":"api-overview/#install-redis-server-open-a-new-terminal-and-type","text":"brew install redis","title":"Install Redis server. Open a new terminal and type"},{"location":"api-overview/#install-d3a-client","text":"mkvirtualenv d3a-api-env pip install git+https://github.com/gridsingularity/d3a-api-client.git","title":"Install d3a-client"},{"location":"api-overview/#update-d3a-client-as-needed-when-an-update-is-deployed","text":"pip uninstall d3a-api-client pip install git+https://github.com/gridsingularity/d3a-api-client.git","title":"Update d3a-client (as needed when an update is deployed)"},{"location":"areas/","text":"Areas contain sub-areas and energy resources. Areas are interconnected by inter-area agents in a hierarchical network. Each area has a market on which inter-area agents (representing other markets) and energy resources can post bids and offers. For further information about the markets, see the backend manual: Markets .","title":"Areas"},{"location":"assets-api/","text":"Asset API documentation \u00b6 The D3A API client allows you to create agents that follow custom trading strategies to buy and sell energy in the energy market. The agent can request and receive information through the API, feed that information into an algorithm, and post bids or offers on a live simulated exchange. This document covers installation and descriptions of the functions available. Using the API Client with a Running Simulation \u00b6 Start Redis server \u00b6 To use the API locally, your script connects to the simulation using a local Redis instance. To start the redis instance, open a new terminal and run the following command : redis-server /usr/local/etc/redis.conf Launch simulation \u00b6 This requires you to have the d3a simulation installed on your machine. If you have yet to do this, see the installation instructions. First navigate to the d3a folder in a new terminal, then activate the d3a environment with: workon d3a Then run: d3a -l INFO run -t 15s -s 15m --setup odyssey_momentum.odyssey_training --start-date 2014-10-01 --enable-external-connection After a few seconds, trading should begin, and should look something like the below. Launch smart agents \u00b6 Open a new terminal to run your trading strategy script (python file). In this python file you can code the trading strategy for the assets you manage. A template python script is provided. You are also able to print some information that you will get with your API calls. You can run your script in the terminal. First navigate to the folder d3a/src/d3a/setup/odyssey_momentum/ Then run python assets_api_template.py Grid Setup File Configuration \u00b6 Backend simulations require modifications to the setup files to allow API connections. When you connect to the web application, the grid operator will make the necessary changes instead. This section is only relevant if you\u2019re modifying your own setup files. Open Device for external connection \u00b6 In the setup file, a device must be designated as open to external connection via the API. This is controlled when setting up the simulation in the setup file by designating the ExternalStrategy for each relevant device: Area ( 'house-1-s' , [ Area ( 'h1-load-s' , strategy = LoadProfileExternalStrategy ( daily_load_profile = load1 , initial_buying_rate = Houses_initial_buying_rate , use_market_maker_rate = True ), appliance = SwitchableAppliance ()), Area ( 'h1-pv-s' , strategy = PVUserProfileExternalStrategy ( power_profile = pv1 , initial_selling_rate = PV_initial , final_selling_rate = PV_final ), appliance = PVAppliance ()), Area ( 'h1-storage-s' , strategy = StorageExternalStrategy ( initial_soc = 50 ), appliance = SwitchableAppliance ()), ], grid_fee_percentage = 0 , transfer_fee_const = 0 , external_connection_available = True ), By default, template strategies do not allow connections. Please also ensure that the appropriate libraries are imported (as in the template setup file provided). Open Area for external connection \u00b6 The API supports multiple areas exposing their market statistics (e.g. min, max, avg, median price and volume of energy) to external devices. Access is controlled when setting up the simulation, using the Area class boolean argument called external_connection_available: Area ( 'Member 2' , [ ... ], # Children of the area external_connection_available = True ), If set to true, the area allows all of its \u2018child\u2019 devices to request its market statistics. By default, this external_connection_available is set to False. API Commands \u00b6 There are multiple instances that can get you information or enable you to take action in the simulation. Event-Triggered Functions \u00b6 In order to facilitate offer and bid management and scheduling, a python file with the class Oracle is provided. The Oracle class acts as an information aggregator for all of the energy assets (e.g. loads and PVs) you manage, and allows you to post bids and offers on their behalf. A few functions are triggered on different types of events, and can be overridden, useful to take actions when market events occur. Each New Market Slot (on_market_cycle(self, market_info)) \u00b6 When a new market slot is available the client will get notified via an event. It is possible to capture this event and perform operations after it by overriding the on_market_cycle method. Ex: def on_market_cycle(self, market_info): In the variable market_info you will get a dictionary with information on the market and your devices. You receive information for each device you manage. The return values are the following : { \"name\" : \"house2\" , \"id\" : \"13023c7d-205d-4b3a-a434-02375eb277ca\" , \"start_time\" : # start-time of the market slot, \"duration_min\" : # 15, \"device_info\" : { \"energy_requirement_kWh\" : # energy that the device has to buy during this market slot, \"available_energy_kWh\" : # energy that the device has to sell during this market slot }, \"event\" : \"market\" , \"device_bill\" : { \"bought\" : # energy bought in kWh, \"sold\" : # energy sold in kWh, \"spent\" : # money spent in \u20ac, \"earned\" : # money earned in \u20ac, \"total_energy\" : # bought - sold, \"total_cost\" : # spent - earned, \"market_fee\" : # \u20ac that goes in grid fee, \"type\" : # type of the strategy }, \"last_market_stats\" : { \"min_trade_rate\" : # minimum trade price in \u20ac/kWh, \"max_trade_rate\" : # maximum trade price in \u20ac/kWh, \"avg_trade_rate\" : # average trade price in \u20ac/kWh, \"total_traded_energy_kWh\" : # total energy traded in kWh } } On % of Market Slot Completion (on_tick(self, tick_info)) \u00b6 Each 10% of market slot completion (e.g. 10%, 20%, 30%, \u2026), the same information as market_info will be passed, updated with new device energy requirements. This can be used to update your bid or offer price at these milestones. On Trade (on_trade(self, trade_info)) \u00b6 Each time the device you manage makes a trade, information about the trade is passed through trade_info. This information can be stored locally or acted upon. On Simulation Finish (on_finished(self)) \u00b6 This executes when the simulation finishes, and can be used to trigger exporting data, training a model or exiting the code. Device Commands \u00b6 Register - Backend \u00b6 Devices are automatically registered to your aggregator in the provided template script. You must update the list below in the oracle template script to the devices you want to manage. Each oracle registered must have a unique name. # Designate devices and markets to manage oracle_name = 'oracle' load_names = [ 'Load 1' , 'Load 2' ] pv_names = [ 'PV 1' ] storage_names = [ 'Storage 1' ] Register - Frontend \u00b6 To register for a collaboration (public simulation hosted by a grid operator) on d3a.io, limited changes must be made in the agent script, including updating the simulation id (found in the url of the collaboration's results page) Sending bids and offers \u00b6 The oracle is able to post bids and offers for multiple devices at the same time. This is implemented already in the template agent for you, so you can focus instead on your strategy. A batch_command dictionary structure is used. To update an existing bid with a load and update both your bid and offer with a storage device, you would use: batch_commands = {} batch_commands[device_event[\"area_uuid\"]] = [ {\"type\": \"update_bid\", \"price\": price, \"energy\": energy},] batch_commands[device_event[\"area_uuid\"]] = [ {\"type\": \"update_bid\", \"price\": buy_price, \"energy\": buy_energy}, {\"type\": \"update_offer\", \"price\": sell_price, \"energy\": sell_energy},) self.batch_command(batch_commands) Note: The total amount of energy bid at any point is limited to the energy requirement of the device. Updating a bid during a market slot deletes other active bids. Additionally, the price of your bids/offers should be a positive float otherwise it will get rejected by the market. Trading Strategies \u00b6 A simple trading strategy is available in the template agent. See the TODO flags there to see how you may update your trading strategy based on predictions about the market and energy requirements.","title":"Asset API"},{"location":"assets-api/#asset-api-documentation","text":"The D3A API client allows you to create agents that follow custom trading strategies to buy and sell energy in the energy market. The agent can request and receive information through the API, feed that information into an algorithm, and post bids or offers on a live simulated exchange. This document covers installation and descriptions of the functions available.","title":"Asset API documentation"},{"location":"assets-api/#using-the-api-client-with-a-running-simulation","text":"","title":"Using the API Client with a Running Simulation"},{"location":"assets-api/#start-redis-server","text":"To use the API locally, your script connects to the simulation using a local Redis instance. To start the redis instance, open a new terminal and run the following command : redis-server /usr/local/etc/redis.conf","title":"Start Redis server"},{"location":"assets-api/#launch-simulation","text":"This requires you to have the d3a simulation installed on your machine. If you have yet to do this, see the installation instructions. First navigate to the d3a folder in a new terminal, then activate the d3a environment with: workon d3a Then run: d3a -l INFO run -t 15s -s 15m --setup odyssey_momentum.odyssey_training --start-date 2014-10-01 --enable-external-connection After a few seconds, trading should begin, and should look something like the below.","title":"Launch simulation"},{"location":"assets-api/#launch-smart-agents","text":"Open a new terminal to run your trading strategy script (python file). In this python file you can code the trading strategy for the assets you manage. A template python script is provided. You are also able to print some information that you will get with your API calls. You can run your script in the terminal. First navigate to the folder d3a/src/d3a/setup/odyssey_momentum/ Then run python assets_api_template.py","title":"Launch smart agents"},{"location":"assets-api/#grid-setup-file-configuration","text":"Backend simulations require modifications to the setup files to allow API connections. When you connect to the web application, the grid operator will make the necessary changes instead. This section is only relevant if you\u2019re modifying your own setup files.","title":"Grid Setup File Configuration"},{"location":"assets-api/#open-device-for-external-connection","text":"In the setup file, a device must be designated as open to external connection via the API. This is controlled when setting up the simulation in the setup file by designating the ExternalStrategy for each relevant device: Area ( 'house-1-s' , [ Area ( 'h1-load-s' , strategy = LoadProfileExternalStrategy ( daily_load_profile = load1 , initial_buying_rate = Houses_initial_buying_rate , use_market_maker_rate = True ), appliance = SwitchableAppliance ()), Area ( 'h1-pv-s' , strategy = PVUserProfileExternalStrategy ( power_profile = pv1 , initial_selling_rate = PV_initial , final_selling_rate = PV_final ), appliance = PVAppliance ()), Area ( 'h1-storage-s' , strategy = StorageExternalStrategy ( initial_soc = 50 ), appliance = SwitchableAppliance ()), ], grid_fee_percentage = 0 , transfer_fee_const = 0 , external_connection_available = True ), By default, template strategies do not allow connections. Please also ensure that the appropriate libraries are imported (as in the template setup file provided).","title":"Open Device for external connection"},{"location":"assets-api/#open-area-for-external-connection","text":"The API supports multiple areas exposing their market statistics (e.g. min, max, avg, median price and volume of energy) to external devices. Access is controlled when setting up the simulation, using the Area class boolean argument called external_connection_available: Area ( 'Member 2' , [ ... ], # Children of the area external_connection_available = True ), If set to true, the area allows all of its \u2018child\u2019 devices to request its market statistics. By default, this external_connection_available is set to False.","title":"Open Area for external connection"},{"location":"assets-api/#api-commands","text":"There are multiple instances that can get you information or enable you to take action in the simulation.","title":"API Commands"},{"location":"assets-api/#event-triggered-functions","text":"In order to facilitate offer and bid management and scheduling, a python file with the class Oracle is provided. The Oracle class acts as an information aggregator for all of the energy assets (e.g. loads and PVs) you manage, and allows you to post bids and offers on their behalf. A few functions are triggered on different types of events, and can be overridden, useful to take actions when market events occur.","title":"Event-Triggered Functions"},{"location":"assets-api/#each-new-market-slot-on_market_cycleself-market_info","text":"When a new market slot is available the client will get notified via an event. It is possible to capture this event and perform operations after it by overriding the on_market_cycle method. Ex: def on_market_cycle(self, market_info): In the variable market_info you will get a dictionary with information on the market and your devices. You receive information for each device you manage. The return values are the following : { \"name\" : \"house2\" , \"id\" : \"13023c7d-205d-4b3a-a434-02375eb277ca\" , \"start_time\" : # start-time of the market slot, \"duration_min\" : # 15, \"device_info\" : { \"energy_requirement_kWh\" : # energy that the device has to buy during this market slot, \"available_energy_kWh\" : # energy that the device has to sell during this market slot }, \"event\" : \"market\" , \"device_bill\" : { \"bought\" : # energy bought in kWh, \"sold\" : # energy sold in kWh, \"spent\" : # money spent in \u20ac, \"earned\" : # money earned in \u20ac, \"total_energy\" : # bought - sold, \"total_cost\" : # spent - earned, \"market_fee\" : # \u20ac that goes in grid fee, \"type\" : # type of the strategy }, \"last_market_stats\" : { \"min_trade_rate\" : # minimum trade price in \u20ac/kWh, \"max_trade_rate\" : # maximum trade price in \u20ac/kWh, \"avg_trade_rate\" : # average trade price in \u20ac/kWh, \"total_traded_energy_kWh\" : # total energy traded in kWh } }","title":"Each New Market Slot (on_market_cycle(self, market_info))"},{"location":"assets-api/#on-of-market-slot-completion-on_tickself-tick_info","text":"Each 10% of market slot completion (e.g. 10%, 20%, 30%, \u2026), the same information as market_info will be passed, updated with new device energy requirements. This can be used to update your bid or offer price at these milestones.","title":"On % of Market Slot Completion (on_tick(self, tick_info))"},{"location":"assets-api/#on-trade-on_tradeself-trade_info","text":"Each time the device you manage makes a trade, information about the trade is passed through trade_info. This information can be stored locally or acted upon.","title":"On Trade (on_trade(self, trade_info))"},{"location":"assets-api/#on-simulation-finish-on_finishedself","text":"This executes when the simulation finishes, and can be used to trigger exporting data, training a model or exiting the code.","title":"On Simulation Finish (on_finished(self))"},{"location":"assets-api/#device-commands","text":"","title":"Device Commands"},{"location":"assets-api/#register-backend","text":"Devices are automatically registered to your aggregator in the provided template script. You must update the list below in the oracle template script to the devices you want to manage. Each oracle registered must have a unique name. # Designate devices and markets to manage oracle_name = 'oracle' load_names = [ 'Load 1' , 'Load 2' ] pv_names = [ 'PV 1' ] storage_names = [ 'Storage 1' ]","title":"Register - Backend"},{"location":"assets-api/#register-frontend","text":"To register for a collaboration (public simulation hosted by a grid operator) on d3a.io, limited changes must be made in the agent script, including updating the simulation id (found in the url of the collaboration's results page)","title":"Register - Frontend"},{"location":"assets-api/#sending-bids-and-offers","text":"The oracle is able to post bids and offers for multiple devices at the same time. This is implemented already in the template agent for you, so you can focus instead on your strategy. A batch_command dictionary structure is used. To update an existing bid with a load and update both your bid and offer with a storage device, you would use: batch_commands = {} batch_commands[device_event[\"area_uuid\"]] = [ {\"type\": \"update_bid\", \"price\": price, \"energy\": energy},] batch_commands[device_event[\"area_uuid\"]] = [ {\"type\": \"update_bid\", \"price\": buy_price, \"energy\": buy_energy}, {\"type\": \"update_offer\", \"price\": sell_price, \"energy\": sell_energy},) self.batch_command(batch_commands) Note: The total amount of energy bid at any point is limited to the energy requirement of the device. Updating a bid during a market slot deletes other active bids. Additionally, the price of your bids/offers should be a positive float otherwise it will get rejected by the market.","title":"Sending bids and offers"},{"location":"assets-api/#trading-strategies","text":"A simple trading strategy is available in the template agent. See the TODO flags there to see how you may update your trading strategy based on predictions about the market and energy requirements.","title":"Trading Strategies"},{"location":"backend-codebase/","text":"For general usage of the D3A software please consult the README . Constants, limits and validators live in the d3a-interface repository . It gets installed automatically if one runs \" fab sync \" in the d3a folder.","title":"Backend Codebase Overview"},{"location":"balancing-market/","text":"Device Registry \u00b6 Any device first has to get registered before actually placing offers in balancing market. HOW TO REGISTER A DEVICE IN THE REGISTRY IN THE SETUP FILE: The balancing device registry is a dictionary that contains the names of the devices as keys and the balancing rates as the tuple values: (demand balancing rate, supply balancing rate). device_registry_dict = { \"H1 General Load\": (33, 35), \"H2 General Load\": (33, 35), \"H1 Storage1\": (33, 35), \"H1 Storage2\": (33, 35), } Devices \u00b6 Currently, Load Strategy / Storage Strategy / Infinite Power Plant (Commercial Producer) can place balancing offers only if they are registered in \"Device Registry\". Balancing Market \u00b6 It is a single sided Pay-as-Ask market, accepts balancing_offers from devices and connected hierarchies of balancing_market . balancing_offers could be positive or negative. It also facilitates the balancing_trade . Balancing Agent \u00b6 It listens to the spot_market_trade of its lower hierarchy. Whenever there is a trade in lower hierarchy of spot_market , it will to try secure a percentage of spot market trades in balancing market. Constant Parameters \u00b6 Following are the constant parameters related to balancing market ENABLE_BALANCING_MARKET \u2192 (Default: False) : enables the simulation with Balancing Market BALANCING_SPOT_TRADE_RATIO \u2192 (Default: 0.2) : dictates the ratio of spot_market_energy to be traded in balancing market BALANCING_OFFER_DEMAND_RATIO \u2192 (Default: 0.1) : dictates the ratio of spot_market_energy to be offered in balancing market as demand_balancing_offer BALANCING_OFFER_SUPPLY_RATIO \u2192 (Default: 0.1) : dictates the ratio of spot_market_energy to be offered in balancing market as supply_balancing_offer BALANCING_FLEXIBLE_LOADS_SUPPORT \u2192 (Default: True) : It enables Load Strategy to place supply_balancing_offer (effectively curtailing it's load)","title":"Balancing Market"},{"location":"balancing-market/#device-registry","text":"Any device first has to get registered before actually placing offers in balancing market. HOW TO REGISTER A DEVICE IN THE REGISTRY IN THE SETUP FILE: The balancing device registry is a dictionary that contains the names of the devices as keys and the balancing rates as the tuple values: (demand balancing rate, supply balancing rate). device_registry_dict = { \"H1 General Load\": (33, 35), \"H2 General Load\": (33, 35), \"H1 Storage1\": (33, 35), \"H1 Storage2\": (33, 35), }","title":"Device Registry"},{"location":"balancing-market/#devices","text":"Currently, Load Strategy / Storage Strategy / Infinite Power Plant (Commercial Producer) can place balancing offers only if they are registered in \"Device Registry\".","title":"Devices"},{"location":"balancing-market/#balancing-market","text":"It is a single sided Pay-as-Ask market, accepts balancing_offers from devices and connected hierarchies of balancing_market . balancing_offers could be positive or negative. It also facilitates the balancing_trade .","title":"Balancing Market"},{"location":"balancing-market/#balancing-agent","text":"It listens to the spot_market_trade of its lower hierarchy. Whenever there is a trade in lower hierarchy of spot_market , it will to try secure a percentage of spot market trades in balancing market.","title":"Balancing Agent"},{"location":"balancing-market/#constant-parameters","text":"Following are the constant parameters related to balancing market ENABLE_BALANCING_MARKET \u2192 (Default: False) : enables the simulation with Balancing Market BALANCING_SPOT_TRADE_RATIO \u2192 (Default: 0.2) : dictates the ratio of spot_market_energy to be traded in balancing market BALANCING_OFFER_DEMAND_RATIO \u2192 (Default: 0.1) : dictates the ratio of spot_market_energy to be offered in balancing market as demand_balancing_offer BALANCING_OFFER_SUPPLY_RATIO \u2192 (Default: 0.1) : dictates the ratio of spot_market_energy to be offered in balancing market as supply_balancing_offer BALANCING_FLEXIBLE_LOADS_SUPPORT \u2192 (Default: True) : It enables Load Strategy to place supply_balancing_offer (effectively curtailing it's load)","title":"Constant Parameters"},{"location":"bills/","text":"All the cumulated bills of each area and device is reported in the JSON file \u201cbills.json\u201d at the end of the simulation. The bills are reported according to the various markets' point of view. In order to have a visual example, let\u2019s take this configuration : In this example we will simulate this configuration for one day using the Pay as Bid market type and the load only have to buy some energy at 12:00. Let\u2019s now see more precisely the only trade of the day and the propagation of the bid of the load and the offer of the DSO until they are matched : The bid and the offer is forwarded to the upper market (for more information on this process, please read the grid fees documentation ) and are matched in the Grid market with a clearing price (and trade price) of 0.45 \u20ac. In the bills.json file, bills will be reported multiple times according to the different market point of view.For each bill we will have the following structure : \u201cParent area\u201c: { \"Agent\": { \"bought\": Energy that has been bought during the simulation [kWh], \"sold\": Energy that has been sold during the simulation [kWh], \"spent\": Amount of money that has been spent in trades during the simulation [\u20ac] , \"earned\": Amount of money that has been earned in trades during the simulation [\u20ac], \"total_energy\": energy bought - energy sold [kWh], \"total_cost\": money spent in trades - money earned in trades [\u20ac], \"market_fee\": Money spent to the \u201cParent area\u201c as grid fees [\u20ac] , \"type\": Type of the agent. Can either be an Area or the name of the device strategy }, }, Now we will look at the results of our previous example. The first point of view is the highest market and in our case the Grid market : From the point of view of the Grid, the House 1 area has bought 1 kWh from the DSO and spent 0.375\u20ac in this trade. House 1 also pays the market fee that the Grid is charging : 0.075\u20ac. The total cost is then 0.375 + 0.075 = 0.45\u20ac After that we go down in the hierarchy and look from the House 1 market : The House 1 market has no information on the other markets and this why from its point of view the Load has spent 0.45\u20ac (0.0375+0.075) for 1 kWh and no fees are added up because this market has no fee. At the very end of the results we have the bills of each device (from their point of view): With this we see that the Load, from his point of view has bought 1 kWh for 0.45\u20ac. From the point of view of the DSO, this latter only received 0.375\u20ac for 1 kWh.","title":"Bills"},{"location":"change-global-sim-settings/","text":"Editing Configuration Parameters \u00b6 There are default values (global constants) for configuration parameters, they can be set in the following way: There are two ways of changing global constants and settings via: setup-file (best option) d3a-settings.json 1. setup-file (best option): \u00b6 For the global update of configuration please see Setting Global Configuration Parameters section below. For setting the grid fee please consult How to configure grid transfer fee . The user can overwrite the configuration settings by changing the wanted variables of the ConstSettings class in the setup-file . For instance, if the user wants to set the market type to double-sided-market, and set the default min and max energy rate for all loads the following lines have to be added to the get_setup function: from d3a_interface.constants_limits import ConstSettings def get_setup(config): ConstSettings.IAASettings.MARKET_TYPE = 2 ConstSettings.LoadSettings.MIN_ENERGY_RATE = 0 ConstSettings.LoadSettings.MAX_ENERGY_RATE = 35 2. d3a-settings.json \u00b6 These global settings can also be parsed via a settings file in JSON format, that contains all constants in the advanced_settings branch. An example can be found here: src/d3a/setup/d3a-settings.json The settings JSON file can be parsed via the --settings-file keyword Setting Global Configuration Parameters \u00b6 Following parameters are part of SimualtionConfig and are initialised even before updating any ConstSettings : sim_duration slot_length tick_length market_count cloud_coverage * market_maker_rate * transfer_fee_pct * transfer_fee_const * pv_user_profile * max_panel_power_W In order to update the some of these parameters (starred in list above), please use update_config_parameters method to update the global config parameters in the setup file: def get_setup(config): config.update_config_parameters(transfer_fee_pct=5, transfer_fee_const=35, cloud_coverage=2, pv_user_profile=\"<path>/<profile_name>\", market_maker_rate=30) area = Area( 'Grid', [ Area('General Load', strategy=LoadHoursStrategy(avg_power_W=200, hrs_per_day=4, hrs_of_day=list(range(12, 16)), final_buying_rate=35), appliance=SwitchableAppliance()), Area('PV', strategy=PVStrategy(4, 80), appliance=PVAppliance()), ], config=config ) return area","title":"How to Change Global Simulation Settings"},{"location":"change-global-sim-settings/#editing-configuration-parameters","text":"There are default values (global constants) for configuration parameters, they can be set in the following way: There are two ways of changing global constants and settings via: setup-file (best option) d3a-settings.json","title":"Editing Configuration Parameters"},{"location":"change-global-sim-settings/#1-setup-file-best-option","text":"For the global update of configuration please see Setting Global Configuration Parameters section below. For setting the grid fee please consult How to configure grid transfer fee . The user can overwrite the configuration settings by changing the wanted variables of the ConstSettings class in the setup-file . For instance, if the user wants to set the market type to double-sided-market, and set the default min and max energy rate for all loads the following lines have to be added to the get_setup function: from d3a_interface.constants_limits import ConstSettings def get_setup(config): ConstSettings.IAASettings.MARKET_TYPE = 2 ConstSettings.LoadSettings.MIN_ENERGY_RATE = 0 ConstSettings.LoadSettings.MAX_ENERGY_RATE = 35","title":"1. setup-file (best option):"},{"location":"change-global-sim-settings/#2-d3a-settingsjson","text":"These global settings can also be parsed via a settings file in JSON format, that contains all constants in the advanced_settings branch. An example can be found here: src/d3a/setup/d3a-settings.json The settings JSON file can be parsed via the --settings-file keyword","title":"2. d3a-settings.json"},{"location":"change-global-sim-settings/#setting-global-configuration-parameters","text":"Following parameters are part of SimualtionConfig and are initialised even before updating any ConstSettings : sim_duration slot_length tick_length market_count cloud_coverage * market_maker_rate * transfer_fee_pct * transfer_fee_const * pv_user_profile * max_panel_power_W In order to update the some of these parameters (starred in list above), please use update_config_parameters method to update the global config parameters in the setup file: def get_setup(config): config.update_config_parameters(transfer_fee_pct=5, transfer_fee_const=35, cloud_coverage=2, pv_user_profile=\"<path>/<profile_name>\", market_maker_rate=30) area = Area( 'Grid', [ Area('General Load', strategy=LoadHoursStrategy(avg_power_W=200, hrs_per_day=4, hrs_of_day=list(range(12, 16)), final_buying_rate=35), appliance=SwitchableAppliance()), Area('PV', strategy=PVStrategy(4, 80), appliance=PVAppliance()), ], config=config ) return area","title":"Setting Global Configuration Parameters"},{"location":"clearingtoken-smart-contract/","text":"The ClearingToken smart contract is responsible for keeping and updating the token balance for every user of the blockchain. The idea behind this contract is that every market that wants to perform energy trading needs to be approved first by a central authority. There are 2 main non-view functions that this smart contract exposes: globallyApprove() : Is used for approving one clearing member (market). This needs to be executed before a market starts trading, otherwise the trade function of the Market smart contract will always fail. A subsequent event will be emitted ( ApproveClearingMember event) which will notify the listeners of this contract about the market being approved. clearingTransfer() : Is used for transferring tokens from the buyer to the seller, keeping and updating the token balance amongst all simulation participants. Validates that the market that called this function is an approved clearing member, and if yes, performs the token exchange, if not nothing happens and the caller gets notified about the failed token transfer.","title":"ClearingToken Smart Contract"},{"location":"collaboration/","text":"Introduction \u00b6 Collaboration is a type of simulation that allows multiple D3A's users to participate inside the same grid. These user can act in a collaborative or competitive way, to optimize specific metrics. Users can connect through the API client to actively engage in the collaboration. As part of collaborations, users have different role that influence their capabilities and their objectives : User roles \u00b6 Exchange Operator \u00b6 The exchange operator (EO) is responsible to build the digital twin of the electrical grid, including energy resources, in a collaboration. Once the setup is set the EO can open an external connection to devices and markets. By doing so, it allows other users to register to those nodes. Once the EO has approved the registration of external users for those devices and markets, they gain control on those. The exchange operator is also in charge of expanding the grid (with events ) to new user desiring to connect to the exchange. Grid Operator \u00b6 The grid operator roles is designed towards Distribution System Operators (DSOs) and Transmission System Operators (TSOs). Those users have the possibility to register to different markets, on different grid level in the collaboration. Once registered and approved by the EO, they can control their owned markets with the API client. Through this latter grid operators can change grid fees in order to influence trades to optimize specific metrics (e.g. peak percentage ). Researcher \u00b6 The researcher is designed towards meters, PV and batteries vendors, communities leaders, energy management companies and data scientists. Researchers can register to devices ( Load , PV and Storage ) and once approved by the EO are responsible of buying and selling energy on markets. While the collaboration is running they are sending bids and offers, for their respective owned devices through the API to the exchange. How to connect \u00b6 If you desire to connect to a collaboration (in the framework of an event such as the Chaos Experiments hack) please follow these following steps : Go to the collaboration page from your account. On this page are listed all collaborations made in the D3A. For every simulation you are allowed to see the settings and the grid setup. If the collaboration you wish to participate in is public, you can click on Registry and Scoreboard . On this page is listed every markets and devices of the collaboration. For the ones that have their API connection opened, you can apply to them. The EO on his side will see that you have applied and is able to either approve or deny your request. Once you're approved you can start your API script","title":"Collaboration"},{"location":"collaboration/#introduction","text":"Collaboration is a type of simulation that allows multiple D3A's users to participate inside the same grid. These user can act in a collaborative or competitive way, to optimize specific metrics. Users can connect through the API client to actively engage in the collaboration. As part of collaborations, users have different role that influence their capabilities and their objectives :","title":"Introduction"},{"location":"collaboration/#user-roles","text":"","title":"User roles"},{"location":"collaboration/#exchange-operator","text":"The exchange operator (EO) is responsible to build the digital twin of the electrical grid, including energy resources, in a collaboration. Once the setup is set the EO can open an external connection to devices and markets. By doing so, it allows other users to register to those nodes. Once the EO has approved the registration of external users for those devices and markets, they gain control on those. The exchange operator is also in charge of expanding the grid (with events ) to new user desiring to connect to the exchange.","title":"Exchange Operator"},{"location":"collaboration/#grid-operator","text":"The grid operator roles is designed towards Distribution System Operators (DSOs) and Transmission System Operators (TSOs). Those users have the possibility to register to different markets, on different grid level in the collaboration. Once registered and approved by the EO, they can control their owned markets with the API client. Through this latter grid operators can change grid fees in order to influence trades to optimize specific metrics (e.g. peak percentage ).","title":"Grid Operator"},{"location":"collaboration/#researcher","text":"The researcher is designed towards meters, PV and batteries vendors, communities leaders, energy management companies and data scientists. Researchers can register to devices ( Load , PV and Storage ) and once approved by the EO are responsible of buying and selling energy on markets. While the collaboration is running they are sending bids and offers, for their respective owned devices through the API to the exchange.","title":"Researcher"},{"location":"collaboration/#how-to-connect","text":"If you desire to connect to a collaboration (in the framework of an event such as the Chaos Experiments hack) please follow these following steps : Go to the collaboration page from your account. On this page are listed all collaborations made in the D3A. For every simulation you are allowed to see the settings and the grid setup. If the collaboration you wish to participate in is public, you can click on Registry and Scoreboard . On this page is listed every markets and devices of the collaboration. For the ones that have their API connection opened, you can apply to them. The EO on his side will see that you have applied and is able to either approve or deny your request. Once you're approved you can start your API script","title":"How to connect"},{"location":"configure-transfer-fee/","text":"There are two fees that can be added to every trade in the grid: constant transfer fee (in cents/kWh) percentage transfer fee (in %) In a configuration you can either set constant fees or percentage fees. By default D3A use constant fees. If you want to set percentage fees you just have to add config.grid_fee_type = 2 at the top of your file. A percentage transfer fee (in %) or a constant transfer fee (in cents/kWh) can be configured for each area individually in the setup file with the keyword grid_fee_percentage and transfer_fee_const : Area( 'House 1', [ Area('H1 General Load', strategy=LoadHoursStrategy(avg_power_W=200, hrs_per_day=6, final_buying_rate=35), appliance=SwitchableAppliance()), Area('H1 Storage1', strategy=StorageStrategy(initial_capacity_kWh=0.6), appliance=SwitchableAppliance()), ], grid_fee_percentage=0, transfer_fee_const=2, ), If no grid_fee_percentage or transfer_fee_const is provided, the global values of grid_fee_percentage or transfer_fee_const is used (set via the update_config_parameters function, see Setting Global Configuration Parameters ) If none of these is set, the const.IAASettings.FEE_PERCENTAGE or const.IAASettings.FEE_CONSTANT values are applied to all areas.","title":"How to Configure Grid Transfer Fee"},{"location":"constant-fees/","text":"Configuration Model \u00b6 Introduction and definitions \u00b6 We have agreed that the buyer should pay all of the fees, at least for this implementation. Any fee that a seller has to pay is ultimately the burden of the buyer. A seller with additional operational costs or taxes will have to raise their prices in a competitive market. When running D3A simulations, we consider the current grid fees and propose which fees need to be added at which layers in the D3A. Configuring separate grid fees in separate markets or areas helps to accomplish this. The grid fee is a part of the energy trade price and is cumulative so that the fees in each market a trade passes through can be added cumulatively together to get the entire grid fee, often as a percentage of the clearing price. The Clearing Rate is the rate that the market clears at The Trade Price is the price the buyer pays (revenue to the seller plus the grid fees) As seen in the examples below, the rate of a bid or offer changes as it is propagated into different markets. The rate of an offer increases to account for the added fees of the market. This helps an agent submitting an offer to receive equal or greater revenue than the value of the offer. The rate of a bid decreases for the same reason. This helps an agent submitting a bid to pay equal or less than the value of the bid. This way, an agent making an offer will never receive less than their offer and an agent making a bid will never pay more than the bid. One Sided Pay as Offer \u00b6 In the One Sided Pay as Offer market, there are no bids and only offers exist. The offers are propagated throughout the markets in the hierarchy. The grid fees are taken into account when an offer is forwarded to the higher market, by the higher market itself. Therefore the agent is not responsible for adapting the offer rate to include the grid fees. The grid fees' unit is a constant value per energy volume \u20ac/kWh , therefore the formula to calculate the new offer rate when placing an offer to a market is the following: offer_rate_after_fees (\u20ac/kWh) = offer_rate (\u20ac/kWh) + grid_fee (\u20ac/kWh) If the offer is not purchased after one tick, it is moved into the next market. When entering a new market, the offer's rate is increased according that that market's grid fee. The PV offer of 0.10 \u20ac/kWh is first placed into the House 2 Market where it gains zero fees. Then it moves into the Neighborhood 2 Market, gaining a fee of 0.01 \u20ac/kWh to become 0.11 \u20ac/kWh. Then if not purchased it moves into the Grid Market, gaining a fee of 0.02 \u20ac/kWh to become 0.13 \u20ac/kWh. Continuing into the Neighborhood 1 Market, the offer gains a fee of 0.01 \u20ac/kWh to become 0.14 \u20ac/kWh. Continuing into the House 1 Market, the offer gains zero fees. The Load buys the offer in the House 1 Market at the Clearing Rate of 0.14 \u20ac/kWh. Using the initial offer rate, the trade price is calculated from the total fees and energy. The total fees are (0.01+0.02+0.01) = 0.04 \u20ac/kWh and are added to the original offer (0.10 \u20ac/kWh) and multiplied by 1 kWh to yield the Trade Price of \u20ac 0.14. The Load pays the Trade Price of \u20ac 0.14, which includes \u20ac 0.10 revenue to the PV, \u20ac 0.01 fees to Neighborhood Market 1, \u20ac 0.02 fees to Grid Market, and \u20ac 0.01 fees to Neighborhood Market 2. Since the market is pay-as-offer, the offer rate is used as the clearing rate. The grid fees are added to the offer rate to determine the trade rate and therefore the trade price in each market. The following formula is used: supply_side_tax (\u20ac/kWh) = forwarded_offer_rate (\u20ac/kWh) - original_offer_rate (\u20ac/kWh) trade_rate (\u20ac/kWh) = clearing rate (\u20ac/kWh) trade_price (\u20ac) = energy (kWh) * trade_rate (\u20ac/kWh) For our example, the trade price for each market is: Market_trade_price (\u20ac) = (original_offer_rate (\u20ac/kWh) + supply_side_tax (\u20ac/kWh)) * energy (kWh) Grid Market = (0.10 + 0.03)*1 = 0.13, Neighborhood 2 Market = (0.10 + 0.01)*1 = 0.11, Neighborhood 1 Market = (0.10 + 0.04)*1 = 0.14, House 1 Market = (0.10 + 0.04)*1 = 0.14, House 2 Market = (0.10 + 0)*1 = 0.10. Two Sided Pay as Bid \u00b6 In the Two Sided Pay as Bid market, there are both bids and offers, which are both propagated throughout the markets in the hierarchy. If a bid or offer is not purchased after one tick, it is moved into the next market. In order to prevent the double accounting of a market's grid fee when a bid and an offer are matched in that market, market fees are added to offers when they enter that market (target market) and market fees are subtracted from bids when they leave that market and enter the another one (source market). The formula for propagating the offers is exactly the same as on the one-sided market : offer_rate_after_fees (\u20ac/kWh) = offer_rate (\u20ac/kWh) + grid_fee (\u20ac/kWh) The bids are not adapted by the market itself, but the area/IAA is responsible to subtract the fees from the bid before propagating the bid to the higher market. As mentioned above, the difference in behavior compared to offers is to avoid double accounting of the grid fee on one market. The formula for an area to update the bid to include grid fees is the following: bid_rate_after_fees (\u20ac/kWh) = bid_rate (\u20ac/kWh) - grid_fee (\u20ac/kWh) In the case of the Two Sided Pay as Bid market, the offer has moved into the Grid Market by the same mechanism as explained in the One Sided Pay as Offer market. The bid of 0.30 \u20ac/kWh follows a similar mechanism and is placed into the House 1 Market where there are zero fees. If the bid is not purchased after one tick, it is moved into the Neighborhood 1 Market. As explained above, only the fees from the source market are added, which are zero in this case. So the bid remains at 0.30 \u20ac/kWh. Next the bid moves into the Grid Market, where it its value is lowered according to the fees of its source market, the Neighborhood 1 Market at 0.01 \u20ac/kWh. With the Neighborhood 1 Market fee, the bid is lowered to 0.29 \u20ac/kWh as it enters the Grid Market. In the example above, the bid and offer are matched in the Grid Market. However, when the offer entered the Grid Market, its rate was immediately updated to account for the Grid Market's fees ( 0.11 + 0.02 ). The bid on the other hand did not add the 0.02 \u20ac/kWh fee. In the case that the bid was not matched in the Grid Market and moved into the Neighborhood 2 Market, the 0.02 \u20ac/kWh fee from the Grid Market would be added. In this case the bid would become ( 0.29 - 0.02 ) 0.27 \u20ac/kWh. The fees from the Neighborhood 2 Market would not be added to the bid unless it entered the House 2 Market (fees added according to the source market). In the Grid Market, the Load bid is listed as 0.29 \u20ac/kWh and the PV offer is listed as 0.13 \u20ac/kWh. As the bid is greater than the offer a trade can be scheduled. The trade clears at the bid rate, giving a Clearing Rate of 0.29 \u20ac/kWh. There is a separate algorithm that calculates the grid fee according to the clearing rate. This allows the markets to act more independently and in a decentralized manner, without having to share information regarding their fees with other markets. In order to calculate the fee correctly based on the original rate, the algorithm needs to be able to calculate the supply side and demand side tax. It is easy to calculate this, since the original bid/offer prices are available: demand_side_tax (\u20ac/kWh) = original_bid_rate (\u20ac/kWh) - forwarded_bid_rate (\u20ac/kWh) supply_side_tax (\u20ac/kWh) = forwarded_offer_rate (\u20ac/kWh) - original_offer_rate (\u20ac/kWh) For the example, we have the following values: supply_side_tax = 0.13 - 0.10 = 0.03 , demand_side_tax = 0.30 - 0.29 = 0.01 . After calculating the supply and demand side tax, we can calculate the revenue of the trade. Note the original_trade_rate is the amount that the original buyer (in our case the Load) will need to pay, therefore for pay as bid this is the original bid price. The calculation is the following: total_tax (\u20ac/kWh) = supply_side_tax (\u20ac/kWh) + demand_side_tax (\u20ac/kWh) revenue_rate (\u20ac/kWh) = original_trade_rate (\u20ac/kWh) - total_tax (\u20ac/kWh) For the example, the revenue will be: revenue = 0.30 - 0.04 = 0.26 Finally, the trade rate is adapted according to the supply side tax, in order to include the fees of the current market: trade_rate (\u20ac/kWh) = revenue_rate (\u20ac/kWh) + supply_side_tax (\u20ac/kWh) trade_price (\u20ac) = energy (kWh) * trade_rate (\u20ac/kWh) For our example, the trade price for each market is: Market_trade_price (\u20ac) = (revenue_rate (\u20ac/kWh) + supply_side_tax (\u20ac/kWh)) * energy (kWh) Grid Market = (0.26 + 0.03)*1 = 0.29, Neighborhood 2 Market = (0.26 + 0.01)*1 = 0.27, Neighborhood 1 Market = (0.26 + 0.04)*1 = 0.30, House 1 Market = (0.26 + 0.04)*1 = 0.30, House 2 Market = (0.26 + 0)*1 = 0.26. The Load pays the Trade Price of \u20ac 0.30, which includes \u20ac 0.26 revenue to the PV, \u20ac 0.01 fees to Neighborhood Market 1, \u20ac 0.02 fees to Grid Market, and \u20ac 0.01 fees to Neighborhood Market 2. Two Sided Pay as Clear \u00b6 In construction...","title":"Constant fees"},{"location":"constant-fees/#configuration-model","text":"","title":"Configuration Model"},{"location":"constant-fees/#introduction-and-definitions","text":"We have agreed that the buyer should pay all of the fees, at least for this implementation. Any fee that a seller has to pay is ultimately the burden of the buyer. A seller with additional operational costs or taxes will have to raise their prices in a competitive market. When running D3A simulations, we consider the current grid fees and propose which fees need to be added at which layers in the D3A. Configuring separate grid fees in separate markets or areas helps to accomplish this. The grid fee is a part of the energy trade price and is cumulative so that the fees in each market a trade passes through can be added cumulatively together to get the entire grid fee, often as a percentage of the clearing price. The Clearing Rate is the rate that the market clears at The Trade Price is the price the buyer pays (revenue to the seller plus the grid fees) As seen in the examples below, the rate of a bid or offer changes as it is propagated into different markets. The rate of an offer increases to account for the added fees of the market. This helps an agent submitting an offer to receive equal or greater revenue than the value of the offer. The rate of a bid decreases for the same reason. This helps an agent submitting a bid to pay equal or less than the value of the bid. This way, an agent making an offer will never receive less than their offer and an agent making a bid will never pay more than the bid.","title":"Introduction and definitions"},{"location":"constant-fees/#one-sided-pay-as-offer","text":"In the One Sided Pay as Offer market, there are no bids and only offers exist. The offers are propagated throughout the markets in the hierarchy. The grid fees are taken into account when an offer is forwarded to the higher market, by the higher market itself. Therefore the agent is not responsible for adapting the offer rate to include the grid fees. The grid fees' unit is a constant value per energy volume \u20ac/kWh , therefore the formula to calculate the new offer rate when placing an offer to a market is the following: offer_rate_after_fees (\u20ac/kWh) = offer_rate (\u20ac/kWh) + grid_fee (\u20ac/kWh) If the offer is not purchased after one tick, it is moved into the next market. When entering a new market, the offer's rate is increased according that that market's grid fee. The PV offer of 0.10 \u20ac/kWh is first placed into the House 2 Market where it gains zero fees. Then it moves into the Neighborhood 2 Market, gaining a fee of 0.01 \u20ac/kWh to become 0.11 \u20ac/kWh. Then if not purchased it moves into the Grid Market, gaining a fee of 0.02 \u20ac/kWh to become 0.13 \u20ac/kWh. Continuing into the Neighborhood 1 Market, the offer gains a fee of 0.01 \u20ac/kWh to become 0.14 \u20ac/kWh. Continuing into the House 1 Market, the offer gains zero fees. The Load buys the offer in the House 1 Market at the Clearing Rate of 0.14 \u20ac/kWh. Using the initial offer rate, the trade price is calculated from the total fees and energy. The total fees are (0.01+0.02+0.01) = 0.04 \u20ac/kWh and are added to the original offer (0.10 \u20ac/kWh) and multiplied by 1 kWh to yield the Trade Price of \u20ac 0.14. The Load pays the Trade Price of \u20ac 0.14, which includes \u20ac 0.10 revenue to the PV, \u20ac 0.01 fees to Neighborhood Market 1, \u20ac 0.02 fees to Grid Market, and \u20ac 0.01 fees to Neighborhood Market 2. Since the market is pay-as-offer, the offer rate is used as the clearing rate. The grid fees are added to the offer rate to determine the trade rate and therefore the trade price in each market. The following formula is used: supply_side_tax (\u20ac/kWh) = forwarded_offer_rate (\u20ac/kWh) - original_offer_rate (\u20ac/kWh) trade_rate (\u20ac/kWh) = clearing rate (\u20ac/kWh) trade_price (\u20ac) = energy (kWh) * trade_rate (\u20ac/kWh) For our example, the trade price for each market is: Market_trade_price (\u20ac) = (original_offer_rate (\u20ac/kWh) + supply_side_tax (\u20ac/kWh)) * energy (kWh) Grid Market = (0.10 + 0.03)*1 = 0.13, Neighborhood 2 Market = (0.10 + 0.01)*1 = 0.11, Neighborhood 1 Market = (0.10 + 0.04)*1 = 0.14, House 1 Market = (0.10 + 0.04)*1 = 0.14, House 2 Market = (0.10 + 0)*1 = 0.10.","title":"One Sided Pay as Offer"},{"location":"constant-fees/#two-sided-pay-as-bid","text":"In the Two Sided Pay as Bid market, there are both bids and offers, which are both propagated throughout the markets in the hierarchy. If a bid or offer is not purchased after one tick, it is moved into the next market. In order to prevent the double accounting of a market's grid fee when a bid and an offer are matched in that market, market fees are added to offers when they enter that market (target market) and market fees are subtracted from bids when they leave that market and enter the another one (source market). The formula for propagating the offers is exactly the same as on the one-sided market : offer_rate_after_fees (\u20ac/kWh) = offer_rate (\u20ac/kWh) + grid_fee (\u20ac/kWh) The bids are not adapted by the market itself, but the area/IAA is responsible to subtract the fees from the bid before propagating the bid to the higher market. As mentioned above, the difference in behavior compared to offers is to avoid double accounting of the grid fee on one market. The formula for an area to update the bid to include grid fees is the following: bid_rate_after_fees (\u20ac/kWh) = bid_rate (\u20ac/kWh) - grid_fee (\u20ac/kWh) In the case of the Two Sided Pay as Bid market, the offer has moved into the Grid Market by the same mechanism as explained in the One Sided Pay as Offer market. The bid of 0.30 \u20ac/kWh follows a similar mechanism and is placed into the House 1 Market where there are zero fees. If the bid is not purchased after one tick, it is moved into the Neighborhood 1 Market. As explained above, only the fees from the source market are added, which are zero in this case. So the bid remains at 0.30 \u20ac/kWh. Next the bid moves into the Grid Market, where it its value is lowered according to the fees of its source market, the Neighborhood 1 Market at 0.01 \u20ac/kWh. With the Neighborhood 1 Market fee, the bid is lowered to 0.29 \u20ac/kWh as it enters the Grid Market. In the example above, the bid and offer are matched in the Grid Market. However, when the offer entered the Grid Market, its rate was immediately updated to account for the Grid Market's fees ( 0.11 + 0.02 ). The bid on the other hand did not add the 0.02 \u20ac/kWh fee. In the case that the bid was not matched in the Grid Market and moved into the Neighborhood 2 Market, the 0.02 \u20ac/kWh fee from the Grid Market would be added. In this case the bid would become ( 0.29 - 0.02 ) 0.27 \u20ac/kWh. The fees from the Neighborhood 2 Market would not be added to the bid unless it entered the House 2 Market (fees added according to the source market). In the Grid Market, the Load bid is listed as 0.29 \u20ac/kWh and the PV offer is listed as 0.13 \u20ac/kWh. As the bid is greater than the offer a trade can be scheduled. The trade clears at the bid rate, giving a Clearing Rate of 0.29 \u20ac/kWh. There is a separate algorithm that calculates the grid fee according to the clearing rate. This allows the markets to act more independently and in a decentralized manner, without having to share information regarding their fees with other markets. In order to calculate the fee correctly based on the original rate, the algorithm needs to be able to calculate the supply side and demand side tax. It is easy to calculate this, since the original bid/offer prices are available: demand_side_tax (\u20ac/kWh) = original_bid_rate (\u20ac/kWh) - forwarded_bid_rate (\u20ac/kWh) supply_side_tax (\u20ac/kWh) = forwarded_offer_rate (\u20ac/kWh) - original_offer_rate (\u20ac/kWh) For the example, we have the following values: supply_side_tax = 0.13 - 0.10 = 0.03 , demand_side_tax = 0.30 - 0.29 = 0.01 . After calculating the supply and demand side tax, we can calculate the revenue of the trade. Note the original_trade_rate is the amount that the original buyer (in our case the Load) will need to pay, therefore for pay as bid this is the original bid price. The calculation is the following: total_tax (\u20ac/kWh) = supply_side_tax (\u20ac/kWh) + demand_side_tax (\u20ac/kWh) revenue_rate (\u20ac/kWh) = original_trade_rate (\u20ac/kWh) - total_tax (\u20ac/kWh) For the example, the revenue will be: revenue = 0.30 - 0.04 = 0.26 Finally, the trade rate is adapted according to the supply side tax, in order to include the fees of the current market: trade_rate (\u20ac/kWh) = revenue_rate (\u20ac/kWh) + supply_side_tax (\u20ac/kWh) trade_price (\u20ac) = energy (kWh) * trade_rate (\u20ac/kWh) For our example, the trade price for each market is: Market_trade_price (\u20ac) = (revenue_rate (\u20ac/kWh) + supply_side_tax (\u20ac/kWh)) * energy (kWh) Grid Market = (0.26 + 0.03)*1 = 0.29, Neighborhood 2 Market = (0.26 + 0.01)*1 = 0.27, Neighborhood 1 Market = (0.26 + 0.04)*1 = 0.30, House 1 Market = (0.26 + 0.04)*1 = 0.30, House 2 Market = (0.26 + 0)*1 = 0.26. The Load pays the Trade Price of \u20ac 0.30, which includes \u20ac 0.26 revenue to the PV, \u20ac 0.01 fees to Neighborhood Market 1, \u20ac 0.02 fees to Grid Market, and \u20ac 0.01 fees to Neighborhood Market 2.","title":"Two Sided Pay as Bid"},{"location":"constant-fees/#two-sided-pay-as-clear","text":"In construction...","title":"Two Sided Pay as Clear"},{"location":"create-setup-file/","text":"The user parses the grid architecture and settings to the d3a simulation via a setup-file. In this setup-file, global and strategy related settings can be set. Examples can be found in: d3a/src/d3a/setup/ This is the most basic skeleton for a setup-file: from d3a.models.area import Area def get_setup(config): area = Area('Grid', []) return area Now the user can ad more sub areas recursively by adding more instances of area to the second parameter (list) of the Area class. If the strategy parameter is set in the Area class, the area is converted to a leaf node, e.g. a load. The following grid architecture is given: Grid House 1 H1 General Load H1 Storage 1 H1 Storage 2 House 2 H2 General Load Cell Tower ( Bold instances are areas, not devices. For each of these non-device areas, an inter-area-agent is created in the background that deals with offer/bid forwarding and matching.) In the following, the corresponding setup-file is shown. from d3a.models.appliance.switchable import SwitchableAppliance from d3a.models.area import Area from d3a.models.strategy.storage import StorageStrategy from d3a.models.strategy.load_hours import CellTowerLoadHoursStrategy, LoadHoursStrategy from d3a.models.appliance.pv import PVAppliance from d3a.models.strategy.pv import PVStrategy def get_setup(config): area = Area( 'Grid', [ Area( 'House 1', [ Area('H1 General Load', strategy=LoadHoursStrategy(avg_power_W=200, hrs_per_day=6, hrs_of_day=list( range(12, 18)), final_buying_rate=35), appliance=SwitchableAppliance()), Area('H1 Storage1', strategy=StorageStrategy(initial_soc=50), appliance=SwitchableAppliance()), Area('H1 Storage2', strategy=StorageStrategy(initial_soc=50), appliance=SwitchableAppliance()), ], transfer_fee_pct=0, transfer_fee_const=0, ), Area( 'House 2', [ Area('H2 General Load', strategy=LoadHoursStrategy(avg_power_W=200, hrs_per_day=4, hrs_of_day=list( range(12, 16)), final_buying_rate=35), appliance=SwitchableAppliance()), Area('H2 PV', strategy=PVStrategy(panel_count=4, initial_selling_rate=30, final_selling_rate=5), appliance=PVAppliance()), ], transfer_fee_pct=0, transfer_fee_const=0, ), Area('Cell Tower', strategy=CellTowerLoadHoursStrategy(avg_power_W=100, hrs_per_day=24, hrs_of_day=list(range(0, 24)), final_buying_rate=35), appliance=SwitchableAppliance()), ], config=config ) return area","title":"How to Create a setup-file"},{"location":"custom-load-strategy/","text":"Instead of configuring the demand behaviour of a load through through avg_power_W , hrs_of_day and hrs_per_day (as described in \" Load Strategy \"), the user can also upload their own load profile in Watts in the backend. The user can do this by uploading a .csv file or inputing the profile directly in the grid configuration (setup) file. There are two demonstration setup files to show this feature: user_profile_load_csv.py In this setup file, the csv file is connected to the configuration via a pathway : user_profile_path = os.path.join(d3a_path,\"resources/LOAD_DATA_1.csv\") Comma or semicolon separated values are allowed. The timestamp can be provided in two formats: HH:mm , YYYY-MM-DDTHH:mm . For more information on what format is accepted by the D3A, see \" Upload File Formats \". user_profile_load_dict.py In this setup file, the user profile is inserted directly into the configuration: user_profile = { 8: 100, 9: 200, 10: 50, 11: 80, 12: 120, 13: 20, 14: 70, 15: 15, 16: 45, 17: 100 } Corresponding code: /src/3a/models/strategy/predefined_load.py How to add a load device with custom profile to the setup-file: user_profile = { 8: 100, 9: 200, 10: 50, 11: 80, 12: 120, 13: 20, 14: 70, 15: 15, 16: 45, 17: 100 } Area('DefinedLoad', strategy=DefinedLoadStrategy(daily_load_profile=user_profile, max_energy_rate=35), appliance=SwitchableAppliance()),","title":"Custom Load Strategy"},{"location":"custom-pv-strategy/","text":"Instead of a pre-configured file, the user can also upload their own PV profile in Watts in the backend. The user can do this by uploading a csv file or inputing the profile directly in the grid configuration (setup) file. There are two demonstration setup files to show this feature: user_profile_pv_csv.py In this setup file, the csv file is connected to the configuration via a pathway: user_profile_path = os.path.join(d3a_path,\"resources/Solar_Curve_W_sunny.csv\") Comma or semicolon separated values are allowed. The timestamp can be provided in two formats: HH:mm , YYYY-MM-DDTHH:mm . For more information on what format is accepted by the D3A, see \" Upload File Formats \". user_profile_pv_dict.py In this setup file, the user profile is inserted directly into the configuration: user_profile = { 8: 100, 9: 200, 10: 50, 11: 80, 12: 120, 13: 20, 14: 70, 15: 15, 16: 45, 17: 100 } Corresponding code: src/d3a/models/strategy/predefined_pv.py How to add a PV device with custom profile to the setup-file: user_profile_path = os.path.join(d3a_path, \"resources/Solar_Curve_W_sunny.csv\") Area('H1 PV', strategy=PVUserProfileStrategy(power_profile=user_profile_path, panel_count=), appliance=PVAppliance()),","title":"Custom PV Strategy"},{"location":"d3a-blockchain-support/","text":"Currently D3A has optional blockchain support, meaning that instead of the Python-simulated blockchain, a private blockchain can be used instead. Currently ganache-cli is used by default, and it is installed when d3a is installed (via fab sync command), but it is also possible to use your own blockchain that is running on your local machine or on a remote machine. The Solidity version that is used for the smart contracts is 0.4.25, which is also installed automatically with fab sync. There are 3 configuration parameters that control whether D3A is using blockchain, and which blockchain it uses (the default D3A blockchain, your own local blockchain, or a remote one). The most important one is the command-line option --enable-bc . This starts a simulation using a real blockchain, instead of using the simulated blockchain. Besides the command line option, there are 2 more configuration parameters that control the blockchain behavior, both of which are located in const.py (and are configurable for the end user via the advanced settings configuration file). First one is BLOCKCHAIN_START_LOCAL_CHAIN , which, if set to True , starts automatically a local chain (using ganache-cli) on the background when D3A starts. If it is desirable to circumvent this behavior, and use a different blockchain, then this option should be set to False . The second configuration setting is BLOCKCHAIN_URL , which defines the URL of the blockchain that is used by D3A. The default value is \" http://127.0.0.1:8545 \", which is the URL of a ganache-cli blockchain installed on localhost. In case the blockchain account that is going to be used requires a password in order to unlock, the password can be provided using the environment variable BLOCKCHAIN_ACCOUNT_PASSWORD , otherwise a default password of \" testgsy \" will be used if this variable is not set.","title":"D3A Blockchain Overview"},{"location":"d3a-documentation/","text":"This is the wiki of the D3A (Decentralized Autonomous Area Agent) which is being developed by Grid Singularity as an interface and codebase to model, simulate, optimize and (coming soon) download and deploy a custom energy exchange. The wiki is divided into three parts: User Interface (d3a.io) which concerns the usage and behavior of the browser app at d3a.io (front-end) Backend Codebase which is the master wiki for the open source backend code that can be downloaded here: https://github.com/gridsingularity/d3a FAQ for commonly asked questions","title":"Overview"},{"location":"ess-strategy/","text":"The ESS can buy or sell energy. For all cases the initial parameters of the battery can be defined: initial_soc : Initial battery SOC (State of Charge) in %. min_allowed_soc: It is the minimum SOC level in % below which the storage bank is never drawn battery_capacity_kWh : size of the battery (default value: 1.2 kWh) max_abs_battery_power_kW : maximum power rating for battery charge/discharge, (default value: 5 kW) Rate settings: update_interval : time after which the rate should be updated (type: pendulum duration object) initial_selling_rate : The maximum starting point of offer rate (ct/kWh) final_selling_rate : The minimum ending point of offer rate (ct/kWh) initial_buying_rate : The minimum starting point of bid rate (ct/kWh) final_buying_rate : The maximum ending point of bid rate (ct/kWh) energy_rate_decrease_per_update : configured as the cents/kWh decrease per update (default value: 1 cent/kWh per update). fit_to_limit: derive bidding behaviour from a linear fitted curve of a buying rate between initial_buying_rate and final_buying_rate (boolean value) within the bidding interval. If activated, energy_rate_increase_per_update = (final_buying_rate - initial_buying_rate) / (market_interval_length / update_interval) . cap_price_strategy : the ESS can trade energy based on a capacity dependent sell price (Default: False , set to True to activate). See Addendum on this page for more information. In order to enable ESS to participate in balancing market, a prerequisite is to add the ESS device in \" Device Registry \" and set the following parameters: balancing_energy_ratio : the first value dictates the ratio of energy to be charged from balancing market. The second value dictates the ratio of energy to be discharge to balancing market (default value: tuple(0.1, 0.1)) Corresponding code: src/3a/models/strategy/storage.py How to add a Storage device to the setup-file: Area('Storage', strategy=StorageStrategy(initial_soc=50, energy_rate_decrease_per_update=3, battery_capacity_kWh=1.2, max_abs_battery_power_kW=5, final_buying_rate=16.99, final_selling_rate= 17.01)), appliance=SwitchableAppliance()), Addendum: ESS Capacity Based Method \u00b6 This method was created to sell energy at lower prices during high SOC (when the battery has more energy stored) and at higher prices during low SOC (when the battery can afford to sell its stores less). If the cap_price_strategy is true, the offer price for the ESS is calculated according to: offer_rate = initial_selling_rate - ((initial_selling_rate - final_selling_rate)\\*soc/100) As an example, considering an initial_selling_rate of 30 cents/kWh and a final_selling_rate price of 20 cents/kWh, an ESS with an SOC of 1% would sell its energy at 29.9 cents/kWh, and a battery at 100% SOC would sell its energy at 20 cents/kWh. General Behaviour \u00b6 In general all offers and bids follow the physical constraint of the set max_abs_battery_power_kW Value. The accumulated energy per market slot can not exceed this power value. Here selling and buying cancel each other out meaning that if 2kWh are both sold and bought in the same market slot, the relative power is still 0. For the buying rate increase and selling rate decrease behaviour, please see: How the Strategies Adjust the Prices of Offers and Bids . Buying Energy \u00b6 One Sided Market \u00b6 On every tick, the storage scans the connected market for affordable offers* if there is storage space to be filled (if the current SOC is lower than 100%). Once an offer is found, it is either fully or partially accepted, depending on the demand. The storage always seeks for 100% SOC when buying energy. * = affordable offers are offers that have a price lower or equal the current acceptable energy rate. The acceptable energy rate changes in the frame of one market slot depending on the initial_buying_rate , final_buying_rate , energy_rate_decrease_per_update and update_interval setting . Two Sided Market \u00b6 On every tick, the storage either places a bid for the energy portion it needs to reach 100% SOC or updates the price of an existing bid in the market where the bid price is depending on the initial_buying_rate , final_buying_rate , energy_rate_decrease_per_update and update_interval setting . Selling Energy \u00b6 At the beginning of each slot market, the storage places an offer on the market offering all the energy it has stored (not including the energy that is needed to keep the storage at least at min_allowed_soc ). This offer gets updated on every tick following the rate decrease settings. This applies to both one and two sided market types. Consequently, it is possible for the storage to have both an offer and a bid placed in the same market.","title":"Energy Storage System (ESS) Strategy"},{"location":"ess-strategy/#addendum-ess-capacity-based-method","text":"This method was created to sell energy at lower prices during high SOC (when the battery has more energy stored) and at higher prices during low SOC (when the battery can afford to sell its stores less). If the cap_price_strategy is true, the offer price for the ESS is calculated according to: offer_rate = initial_selling_rate - ((initial_selling_rate - final_selling_rate)\\*soc/100) As an example, considering an initial_selling_rate of 30 cents/kWh and a final_selling_rate price of 20 cents/kWh, an ESS with an SOC of 1% would sell its energy at 29.9 cents/kWh, and a battery at 100% SOC would sell its energy at 20 cents/kWh.","title":"Addendum: ESS Capacity Based Method"},{"location":"ess-strategy/#general-behaviour","text":"In general all offers and bids follow the physical constraint of the set max_abs_battery_power_kW Value. The accumulated energy per market slot can not exceed this power value. Here selling and buying cancel each other out meaning that if 2kWh are both sold and bought in the same market slot, the relative power is still 0. For the buying rate increase and selling rate decrease behaviour, please see: How the Strategies Adjust the Prices of Offers and Bids .","title":"General Behaviour"},{"location":"ess-strategy/#buying-energy","text":"","title":"Buying Energy"},{"location":"ess-strategy/#one-sided-market","text":"On every tick, the storage scans the connected market for affordable offers* if there is storage space to be filled (if the current SOC is lower than 100%). Once an offer is found, it is either fully or partially accepted, depending on the demand. The storage always seeks for 100% SOC when buying energy. * = affordable offers are offers that have a price lower or equal the current acceptable energy rate. The acceptable energy rate changes in the frame of one market slot depending on the initial_buying_rate , final_buying_rate , energy_rate_decrease_per_update and update_interval setting .","title":"One Sided Market"},{"location":"ess-strategy/#two-sided-market","text":"On every tick, the storage either places a bid for the energy portion it needs to reach 100% SOC or updates the price of an existing bid in the market where the bid price is depending on the initial_buying_rate , final_buying_rate , energy_rate_decrease_per_update and update_interval setting .","title":"Two Sided Market"},{"location":"ess-strategy/#selling-energy","text":"At the beginning of each slot market, the storage places an offer on the market offering all the energy it has stored (not including the energy that is needed to keep the storage at least at min_allowed_soc ). This offer gets updated on every tick following the rate decrease settings. This applies to both one and two sided market types. Consequently, it is possible for the storage to have both an offer and a bid placed in the same market.","title":"Selling Energy"},{"location":"events/","text":"The user has the ability to make changes in the modelling page while the simulation is running. These changes are called events . To create an event the user can either go to the modelling page and make a change while the simulation is running or can pause the simulation beforehand and resume it when the change is done. The possible events are : Add & delete areas and energy resources Change parameters of energy resources to the exception of their names and the Market Maker Change parameters of areas to the exception of their names Add a library component (next deploy 0.7.0) Once an event is set the user can track it on the timeline of the simulation. If the user click on the event while being on the modelling page she/he can view the grid setup at that specific time. If the user click on an event in the result page she/he will get the results of the specific areas / energy resources. whenever an area or energy resource was added whenever an area or energy resource parameter was modified whenever an area or energy resource was removed whenever multiple events have been executed at the same time","title":"Events"},{"location":"faq-odyssey/","text":"This is a frequently asked questions (faq) specifically designed for the hackathon Odyssey 2020, in which we are producing 2 of the challenges. Stream 1: Trading Bots, KPIs, API \u00b6 What is the D3A ? \u00b6 The D3A is an open source software that enables users to model, simulate, optimise, download, and deploy energy exchanges. The D3A is designed to build \u201cdigital twin\u201d representations of physical energy systems and energy markets. It aims to build open energy exchanges, extending access for new energy players, a class which is growing due to increased investments in distributed energy resources and smart devices. By creating energy exchanges from bottom to top, smart, local, and flexible devices as well as distributed renewable generation can be monetised for a faster transition to 100% renewable energy. How are D3A market organised ? \u00b6 The electricity grid is organized into a hierarchy of energy marketplaces. Markets are organized according to grid voltage levels. Energy assets buy and sell into a House Market. Houses buy and sell into Community Markets. Communities buy and sell into a Grid Market. Each energy asset consumes, produces, or stores energy and trades in its local energy market first. If unsuccessful, the bid or offer is propagated to a higher market in the hierarchy. Energy assets, Houses, and Communities might optimise their bids and offers for a specific metric , such as minimising energy bill or maximising self-sufficiency. What is the Goal of Energy Singularity Challenge Stream 1? \u00b6 Stream 1 of the Energy Singularity challenge aims to optimize the trading strategies of individual devices with the goal of optimising key performance indicators (KPIs) such as a household\u2019s energy bill and a community\u2019s self-sufficiency. Teams will design and manage trading strategies of individual assets within houses or communities through an API. Each team will manage the assets of one or many homes in a community, depending on the challenge round. They will be judged on KPIs such as energy bill or energy self-sufficiency, but also on their approach and viability of their agent\u2019s \u2018deployability\u2019. Grid operators can adjust grid tariffs and transmission capacities in real-time, and utilities can compete in the market, offering energy from power plants at a competitive rate (these roles will be performed by challenge partners). What are energy assets and how are they represented? \u00b6 There are five types of energy assets modeled. Four are home energy assets. Loads have a variable energy demand (kWh) that must be purchased within each market slot PVs have variable energy generation that can be sold within each market slot Batteries can buy or sell energy, within a min and max state of charge Flexible Loads can buy flexibly by storing energy to use later, but must cover their base load over time The fifth is controlled by an agent representing a utility: Power Plants produce energy at a market maker rate (e.g. 30 cents per kWh) and act as \u2018infinite\u2019 producers Energy required to be purchased (Loads), energy available to be sold (PVs), and state of charge and available rate of charge / discharge (Batteries and Flexible Loads) will be provided through the API each market slot. What market mechanisms will be used in the Hackathon ? \u00b6 Without a peer to peer energy market, devices that consume energy would always buy energy at the market rate of 30 cents per kWh from the utility. PVs would sell excess energy to the utility at a feed-in tariff rate, such as 10 cents / kWh. In a peer to peer market, a PV would be able to sell energy to a nearby load instead of selling it to the grid. For example, the PV may offer to sell its excess energy at 25 cents / kWh to the load, 15 cents higher than the feed-in tariff. The load would likely be willing to buy this energy, as the cost is 5 cents lower than the 30 cent market rate from the utility, a benefit for both the PV and load. The exact value of the rate which the PV would sell to the load is optimally a function of energy supply and demand and is likely to decrease during times when there is more solar production than required load. Agents will try to predict this optimal price and arbitrage the energy market with their trading strategies. Markets are broken into 15 minute slots. Within each slot, an energy asset is able to post bids or offers for energy. These bids or offers are matched based on the market type. The two sided market Pay-as-Bid market type will be used for the hackathon, where bids are matched with the highest price offer where bid price >= offer price. If all remaining bid prices are less than all offer prices, the energy on bid / offer remains unmatched. Any energy not bought or sold at the end of the market slot vs. energy requirements of the assets will be penalised. Each market slot is broken into many ticks. When a bid or offer is posted, it is first attempted to be matched in its local energy market. If it remains unmatched at the end of one tick, it is propagated to a higher market. Bids or offers that match are immediately cleared in all markets, and bids and offers that are canceled are immediately canceled in all markets. The duration simulated for each round will be 1 week and each market slot will be 15 minutes of simulated time. Simulations will be accelerated and each market slot will only take a few seconds in \u201creal life\u201d. A walk-through of one market slot is depicted below. For more information on the market and its component, please visit these wiki pages : Overview Pay-as-Bid Inter-Area Agent Market slot and ticks What is a trading strategy and how do I optimise it ? \u00b6 Each energy asset is represented by a digital twin agent. The agent makes decisions to buy or sell energy at specific prices based on the energy requirements of the device. For example, a solar panel that produces 0.15 kWh of energy may request to SELL 0.15 kWh at 26 cents / kWh. Loads must buy a certain amount of energy. PVs must sell the amount of energy they produce. Batteries may buy or sell energy within a min and max state of charge. Each team will manage multiple energy assets. The goal is to optimize the trading strategy for a specific metric (that can either be the energy bills or the self-sufficiency of an area) by defining the price [\u20ac/kWh] and the volume [kWh] of your bids/offers. If you are controlling storage there is also the factor of time that comes into consideration (when to buy or sell) when optimizing, as illustrated in the figure below. Furthermore, since the market is continuous, you are also able to update your bids/offers during the market slot in order to increase your chance of being matched. What data is available to train my trading bot ? \u00b6 Data can be gathered in two ways, by: Gathering and locally storing the information passed to the agent through the API during simulations Processing the data outputs of simulations (exported to the d3a-simulation folder after each simulation) The information passed through the API is what will be available to be used in collaborative simulations such as at the hackathon. It is recommended your agents be trained on this data. Data includes past market data (min, max, avg, and median prices), amount of energy traded, trading events, and power curves. Exact data structures are available in the API documentation . What are penalties and how are they avoided? \u00b6 Penalties are incurred if the power curve of a device is not exactly met. The penalty for any energy withstanding is currently set to the market maker rate + 10%, but is subject to change. For example if a load is required to buy 1 kWh but only buys 0.8 kWh, the remaining 0.2 kWh will be penalised at the market maker rate + 10%. The same is true if a PV generates 1 kWh but only sells 0.8 kWh. This is to penalise unaccounted for power flow that could be detrimental to the physical grid. What is a Grid Fee ? \u00b6 A grid fee is a percentage of trade price or a constant value that is paid to the market for using the electrical grid. Simulation and API Setup \u00b6 How do I create a simulation and train and test my trading bot ? \u00b6 You will train your agent locally on the backend code, and will interact with the frontend at d3a.io during the hackathon. Review this document describing how to install and interact with simulations via the API , which discusses connecting to the backend and to d3a.io. To run simulations on our frontend at d3a.io, follow the steps on our wiki to create and run simulations on d3a.io . Technical information \u00b6 Please note that this information is subject to change as the challenge details are refined. How many days are in each simulation ? \u00b6 It is likely that each simulation will represent 7 real time days. How much time does a market slot take ? \u00b6 Each market slot represents 15 simulation time minutes which is 5-10 real time seconds. The exact simulation slowdown factor will be shared when decided upon. How many ticks are in a market slot ? \u00b6 In each market slot there will be 60-90 ticks. The on_tick(self, tick_info) function will be triggered every incremental 10% of the market slot, e.g. on tick 6, 12, 18, etc. if there are 60 ticks. This means you\u2019ll easily be able to make bid and offer decisions / updates 9 times per slot. How many API calls can I make per market slot ? \u00b6 Each device may have up to 5 active bids and 5 active offers at any point in time. There will be a realistic limit on the number of API calls, such as 1000 per slot, which will not limit your agents and is only intended to limit the probability of a DDOS attack. The exact number is to be determined and will be shared. \u00b6 How many accounts can register for one device ? \u00b6 Multiple accounts can apply for a device but only one will be selected by the simulation\u2019s grid operator, registered to a device and can send API calls. Do I have to run a single strategy for all my devices ? \u00b6 A single script could be used to manage all devices, but it is not obligatory. You can easily run multiple scripts with various strategies on your computer via multiple terminals. Defining Success \u00b6 What criteria will teams be judged on? \u00b6 Winners will not be decided purely on how well their trading algorithm performs relative to other teams. Teams will be judged on a combination of: Algorithm Success : the success of their TradingBot against defined metrics such as energy bill and community self-sufficiency, the goal being specified each challenge round Algorithm Approach : the explanation / documentation of why their algorithm is performing the way it does, and what that means for the devices and communities it represents Challenge Questions : answers or approaches to the challenge questions as defined below. Not all questions must be attempted, especially if you have very well thought out answers to a subset of the questions What are the challenge questions? \u00b6 Requirements for Intelligent Agents in the Real World - What information must be provided to intelligent agents who are trying to optimise the performance of energy devices they represent in the real world? What are some potential issues, such as privacy concerns or hardware limits? What should the flow of information look like? Calculate the Return on Investment of installing an energy asset - Given simulation outcomes, how could the return on investment of energy assets be determined? The intent would be to answer the question, \u201cshould I buy a battery or a solar panel, and what would be the benefit?\u201d. Community Index Design - Design a KPI that could be used to determine the effectiveness index of the way a community is interacting with the energy grid, taking into account energy bill, self-sufficiency, self-consumption, active devices, and other inputs. This index could then be used to judge communities or as an optimisation metric for trading algorithms.","title":"FAQ Odyssey hackathon"},{"location":"faq-odyssey/#stream-1-trading-bots-kpis-api","text":"","title":"Stream 1: Trading Bots, KPIs, API"},{"location":"faq-odyssey/#what-is-the-d3a","text":"The D3A is an open source software that enables users to model, simulate, optimise, download, and deploy energy exchanges. The D3A is designed to build \u201cdigital twin\u201d representations of physical energy systems and energy markets. It aims to build open energy exchanges, extending access for new energy players, a class which is growing due to increased investments in distributed energy resources and smart devices. By creating energy exchanges from bottom to top, smart, local, and flexible devices as well as distributed renewable generation can be monetised for a faster transition to 100% renewable energy.","title":"What is the D3A ?"},{"location":"faq-odyssey/#how-are-d3a-market-organised","text":"The electricity grid is organized into a hierarchy of energy marketplaces. Markets are organized according to grid voltage levels. Energy assets buy and sell into a House Market. Houses buy and sell into Community Markets. Communities buy and sell into a Grid Market. Each energy asset consumes, produces, or stores energy and trades in its local energy market first. If unsuccessful, the bid or offer is propagated to a higher market in the hierarchy. Energy assets, Houses, and Communities might optimise their bids and offers for a specific metric , such as minimising energy bill or maximising self-sufficiency.","title":"How are D3A market organised ?"},{"location":"faq-odyssey/#what-is-the-goal-of-energy-singularity-challenge-stream-1","text":"Stream 1 of the Energy Singularity challenge aims to optimize the trading strategies of individual devices with the goal of optimising key performance indicators (KPIs) such as a household\u2019s energy bill and a community\u2019s self-sufficiency. Teams will design and manage trading strategies of individual assets within houses or communities through an API. Each team will manage the assets of one or many homes in a community, depending on the challenge round. They will be judged on KPIs such as energy bill or energy self-sufficiency, but also on their approach and viability of their agent\u2019s \u2018deployability\u2019. Grid operators can adjust grid tariffs and transmission capacities in real-time, and utilities can compete in the market, offering energy from power plants at a competitive rate (these roles will be performed by challenge partners).","title":"What is the Goal of Energy Singularity Challenge Stream 1?"},{"location":"faq-odyssey/#what-are-energy-assets-and-how-are-they-represented","text":"There are five types of energy assets modeled. Four are home energy assets. Loads have a variable energy demand (kWh) that must be purchased within each market slot PVs have variable energy generation that can be sold within each market slot Batteries can buy or sell energy, within a min and max state of charge Flexible Loads can buy flexibly by storing energy to use later, but must cover their base load over time The fifth is controlled by an agent representing a utility: Power Plants produce energy at a market maker rate (e.g. 30 cents per kWh) and act as \u2018infinite\u2019 producers Energy required to be purchased (Loads), energy available to be sold (PVs), and state of charge and available rate of charge / discharge (Batteries and Flexible Loads) will be provided through the API each market slot.","title":"What are energy assets and how are they represented?"},{"location":"faq-odyssey/#what-market-mechanisms-will-be-used-in-the-hackathon","text":"Without a peer to peer energy market, devices that consume energy would always buy energy at the market rate of 30 cents per kWh from the utility. PVs would sell excess energy to the utility at a feed-in tariff rate, such as 10 cents / kWh. In a peer to peer market, a PV would be able to sell energy to a nearby load instead of selling it to the grid. For example, the PV may offer to sell its excess energy at 25 cents / kWh to the load, 15 cents higher than the feed-in tariff. The load would likely be willing to buy this energy, as the cost is 5 cents lower than the 30 cent market rate from the utility, a benefit for both the PV and load. The exact value of the rate which the PV would sell to the load is optimally a function of energy supply and demand and is likely to decrease during times when there is more solar production than required load. Agents will try to predict this optimal price and arbitrage the energy market with their trading strategies. Markets are broken into 15 minute slots. Within each slot, an energy asset is able to post bids or offers for energy. These bids or offers are matched based on the market type. The two sided market Pay-as-Bid market type will be used for the hackathon, where bids are matched with the highest price offer where bid price >= offer price. If all remaining bid prices are less than all offer prices, the energy on bid / offer remains unmatched. Any energy not bought or sold at the end of the market slot vs. energy requirements of the assets will be penalised. Each market slot is broken into many ticks. When a bid or offer is posted, it is first attempted to be matched in its local energy market. If it remains unmatched at the end of one tick, it is propagated to a higher market. Bids or offers that match are immediately cleared in all markets, and bids and offers that are canceled are immediately canceled in all markets. The duration simulated for each round will be 1 week and each market slot will be 15 minutes of simulated time. Simulations will be accelerated and each market slot will only take a few seconds in \u201creal life\u201d. A walk-through of one market slot is depicted below. For more information on the market and its component, please visit these wiki pages : Overview Pay-as-Bid Inter-Area Agent Market slot and ticks","title":"What market mechanisms will be used in the Hackathon ?"},{"location":"faq-odyssey/#what-is-a-trading-strategy-and-how-do-i-optimise-it","text":"Each energy asset is represented by a digital twin agent. The agent makes decisions to buy or sell energy at specific prices based on the energy requirements of the device. For example, a solar panel that produces 0.15 kWh of energy may request to SELL 0.15 kWh at 26 cents / kWh. Loads must buy a certain amount of energy. PVs must sell the amount of energy they produce. Batteries may buy or sell energy within a min and max state of charge. Each team will manage multiple energy assets. The goal is to optimize the trading strategy for a specific metric (that can either be the energy bills or the self-sufficiency of an area) by defining the price [\u20ac/kWh] and the volume [kWh] of your bids/offers. If you are controlling storage there is also the factor of time that comes into consideration (when to buy or sell) when optimizing, as illustrated in the figure below. Furthermore, since the market is continuous, you are also able to update your bids/offers during the market slot in order to increase your chance of being matched.","title":"What is a trading strategy and how do I optimise it ?"},{"location":"faq-odyssey/#what-data-is-available-to-train-my-trading-bot","text":"Data can be gathered in two ways, by: Gathering and locally storing the information passed to the agent through the API during simulations Processing the data outputs of simulations (exported to the d3a-simulation folder after each simulation) The information passed through the API is what will be available to be used in collaborative simulations such as at the hackathon. It is recommended your agents be trained on this data. Data includes past market data (min, max, avg, and median prices), amount of energy traded, trading events, and power curves. Exact data structures are available in the API documentation .","title":"What data is available to train my trading bot ?"},{"location":"faq-odyssey/#what-are-penalties-and-how-are-they-avoided","text":"Penalties are incurred if the power curve of a device is not exactly met. The penalty for any energy withstanding is currently set to the market maker rate + 10%, but is subject to change. For example if a load is required to buy 1 kWh but only buys 0.8 kWh, the remaining 0.2 kWh will be penalised at the market maker rate + 10%. The same is true if a PV generates 1 kWh but only sells 0.8 kWh. This is to penalise unaccounted for power flow that could be detrimental to the physical grid.","title":"What are penalties and how are they avoided?"},{"location":"faq-odyssey/#what-is-a-grid-fee","text":"A grid fee is a percentage of trade price or a constant value that is paid to the market for using the electrical grid.","title":"What is a Grid Fee ?"},{"location":"faq-odyssey/#simulation-and-api-setup","text":"","title":"Simulation and API Setup"},{"location":"faq-odyssey/#how-do-i-create-a-simulation-and-train-and-test-my-trading-bot","text":"You will train your agent locally on the backend code, and will interact with the frontend at d3a.io during the hackathon. Review this document describing how to install and interact with simulations via the API , which discusses connecting to the backend and to d3a.io. To run simulations on our frontend at d3a.io, follow the steps on our wiki to create and run simulations on d3a.io .","title":"How do I create a simulation and train and test my trading bot ?"},{"location":"faq-odyssey/#technical-information","text":"Please note that this information is subject to change as the challenge details are refined.","title":"Technical information"},{"location":"faq-odyssey/#how-many-days-are-in-each-simulation","text":"It is likely that each simulation will represent 7 real time days.","title":"How many days are in each simulation ?"},{"location":"faq-odyssey/#how-much-time-does-a-market-slot-take","text":"Each market slot represents 15 simulation time minutes which is 5-10 real time seconds. The exact simulation slowdown factor will be shared when decided upon.","title":"How much time does a market slot take ?"},{"location":"faq-odyssey/#how-many-ticks-are-in-a-market-slot","text":"In each market slot there will be 60-90 ticks. The on_tick(self, tick_info) function will be triggered every incremental 10% of the market slot, e.g. on tick 6, 12, 18, etc. if there are 60 ticks. This means you\u2019ll easily be able to make bid and offer decisions / updates 9 times per slot.","title":"How many ticks are in a market slot ?"},{"location":"faq-odyssey/#how-many-api-calls-can-i-make-per-market-slot","text":"","title":"How many API calls can I make per market slot ?"},{"location":"faq-odyssey/#each-device-may-have-up-to-5-active-bids-and-5-active-offers-at-any-point-in-time-there-will-be-a-realistic-limit-on-the-number-of-api-calls-such-as-1000-per-slot-which-will-not-limit-your-agents-and-is-only-intended-to-limit-the-probability-of-a-ddos-attack-the-exact-number-is-to-be-determined-and-will-be-shared","text":"","title":"Each device may have up to 5 active bids and 5 active offers at any point in time. There will be a realistic limit on the number of API calls, such as 1000 per slot, which will not limit your agents and is only intended to limit the probability of a DDOS attack. The exact number is to be determined and will be shared."},{"location":"faq-odyssey/#how-many-accounts-can-register-for-one-device","text":"Multiple accounts can apply for a device but only one will be selected by the simulation\u2019s grid operator, registered to a device and can send API calls.","title":"How many accounts can register for one device ?"},{"location":"faq-odyssey/#do-i-have-to-run-a-single-strategy-for-all-my-devices","text":"A single script could be used to manage all devices, but it is not obligatory. You can easily run multiple scripts with various strategies on your computer via multiple terminals.","title":"Do I have to run a single strategy for all my devices ?"},{"location":"faq-odyssey/#defining-success","text":"","title":"Defining Success"},{"location":"faq-odyssey/#what-criteria-will-teams-be-judged-on","text":"Winners will not be decided purely on how well their trading algorithm performs relative to other teams. Teams will be judged on a combination of: Algorithm Success : the success of their TradingBot against defined metrics such as energy bill and community self-sufficiency, the goal being specified each challenge round Algorithm Approach : the explanation / documentation of why their algorithm is performing the way it does, and what that means for the devices and communities it represents Challenge Questions : answers or approaches to the challenge questions as defined below. Not all questions must be attempted, especially if you have very well thought out answers to a subset of the questions","title":"What criteria will teams be judged on?"},{"location":"faq-odyssey/#what-are-the-challenge-questions","text":"Requirements for Intelligent Agents in the Real World - What information must be provided to intelligent agents who are trying to optimise the performance of energy devices they represent in the real world? What are some potential issues, such as privacy concerns or hardware limits? What should the flow of information look like? Calculate the Return on Investment of installing an energy asset - Given simulation outcomes, how could the return on investment of energy assets be determined? The intent would be to answer the question, \u201cshould I buy a battery or a solar panel, and what would be the benefit?\u201d. Community Index Design - Design a KPI that could be used to determine the effectiveness index of the way a community is interacting with the energy grid, taking into account energy bill, self-sufficiency, self-consumption, active devices, and other inputs. This index could then be used to judge communities or as an optimisation metric for trading algorithms.","title":"What are the challenge questions?"},{"location":"faq/","text":"This list of frequently asked questions (faq) is updated gradually, by adding the questions that come up on our Slack community chat (gsycommunity.slack.com). Our gitter has been replaced with our Slack community. D3A Functionality \u00b6 What is the D3A ? \u00b6 The D3A is an energy exchange engine. It is an open source software, enabling users to model, simulate, optimise, download, and deploy their own energy exchanges. The D3A is designed to build \u201cdigital twin\u201d representations of physical energy systems and energy markets. It aims to build open energy exchanges, extending access for new energy players, a class which is growing due to increased investments in distributed energy resources and smart devices. By creating energy exchanges from bottom to top, smart, local, and flexible devices as well as distributed renewable generation can be monetised for a faster transition to 100% renewable energy. The D3A simulation engine is currently available in two formats - the open source backend code , and the user friendly frontend User Interface (UI) . What are the possible use cases to simulate with the D3A ? \u00b6 The D3A is an energy exchange engine capable of simulating (and after further development facilitating) power flows and energy transactions in local marketplaces. The D3A showcases and harnesses the potential of transactive grids, renewable energy sources (RES) and peer to peer (P2P) energy trading for all stakeholders in the energy transition and can have multiple applications, including the following use cases. Community as a Service . Creates a local energy market within the grid-tied community and allows all energy assets (e.g. residential rooftop solar) equal access to market alongside traditional energy providers. This enables prosumers to participate actively in the energy market by trading locally before buying from or selling to the grid provider. Energy Access . Creates a local energy market within an islanded microgrid energy community . This allows for a more optimal microgrid configuration. To see an example of use case of \u201cCommunity as a Service\u201d with the D3A engine, please read our Medium article and watch our presentation from Event Horizon 2019 here . Both the \u201cCommunity as a Service\u201d and \u201cEnergy Access\u201d use cases are available as public projects at d3a.io . Do the D3A frontend and the backend have the same functionalities ? \u00b6 The backend code offers the full functionality of the active version of the D3A. The frontend User Interface (UI) offers a user friendly interface to the majority of features found in the backend. New features are typically developed in the backend first and are made available in the UI after internal testing for usability and accuracy. Frontend / User Interface at d3a.io \u00b6 How do I setup a simulation in the frontend ? \u00b6 To start using the D3A you need to register your account. You will then receive an email with a link to confirm your account. Once done you will be able to connect to d3a.io with your account. You can design your own project by clicking on \u201cnew project\u201d and then create a new simulation in it. The first step in setting up a simulation is to define the simulation settings. You can set the simulation duration, the solar profile type, the market type, and other relevant parameters. In the D3A you can choose one of the 3 market types available : single-sided pay as offer, two-sided pay as bid and two-sided pay as clear (for more information on the simulation settings please follow this link ). The next step is to design your grid. Once you arrive in the grid setup, the first thing that you will have to do is to define the market maker. Its goal is to represent a static or fluctuating base market price which will serve as a reference point for the selected device strategies. After creating this market maker, you can start building the digital twin of your grid. The D3A works by creating area markets. In each of these areas you can put devices or other grid areas. The devices can be loads, PV, storage, etc. The setup is intended to represent the physical architecture of the real energy market (country, region, neighbourhood, house, etc.). Importantly, each area contains a spot market where trades can occur. Each device places a bid/offer in their home market. When bids/offers are not matched in their own area, they are forwarded to the upper market in the upper area and so on. After your grid setup is complete, you can run your simulation. When it is finished you can view multiple scrollable plots and tables on the results page (for more on how to use these visuals, please see this link ) and you can also download the results file on your computer. For a step-by-step explanation on how to setup your simulation, please watch our tutorial . You can also see a video explaining the new release features implemented on the frontend here . If you have any other problems, please visit our documentation wiki page for the frontend and the backend D3A versions. Are there any limitations concerning the size of the simulation ? \u00b6 For smoother simulations and smaller queue, we have set some boundaries. First, the simulations are limited in their duration. You can currently set the duration from 1 to 7 days. Furthermore, the number of agents allowed per simulation is limited. Each device and area is considered as an agent and you can define up to 250 of these. Backend Codebase \u00b6 How do I setup a simulation in the backend ? \u00b6 There is no need to login to set up a simulation in the backend. You just need to follow the steps bellow : Download the code from our GitHub Repository . Please follow the technical instructions here to correctly install the D3A on your computer. To design a grid setup, please create a python file and follow our tips on how to setup file and global settings . You can also review our setup examples located at d3a/src/d3a/setup/ . To run a setup file you need to place it in the directory d3a/src/d3a/setup/ , or change the path yourself in the ConstSettings.py file. To launch the simulation in the command line interface, follow our technical instructions . Why do my results keep changing when I rerun the same setup ? \u00b6 This is caused by the random seed number. This number controls the randomness of the market, the bids, offers and the trades. If you have not defined this number, at each simulation a new random seed number will be generated and therefore you will keep observing different results (for example the trades between the areas and the storage SOC can vary). To set the random seed number you have to add this in the simulation launch command line interface --seed TEXT. By doing so, the randomness of the simulation will be frozen and your results won\u2019t change anymore. I am creating a long simulation (week/month/year) and would like to establish my spot market in the day ahead. Is this possible or is it frozen/strictly at 15 minutes ahead ? \u00b6 No, for now you cannot establish your spot market in the day ahead, but you can choose the number of tradable market slots into the future. This will allow your devices to trade in multiple future spot markets. To enable this functionality, you have to add to your simulation a launch command -m number_of_tradable_markets. The size of the market slot is configurable. You can change the market slot length of 15 minutes to be any integer between 2 minutes and 60 minutes. I am using the energy storage system (ESS) to represent a compressed air storage (with an electric-to-electric efficiency of 50%). How can I implement the efficiency in the ESS component ? \u00b6 For the time being, the storage component has a 100% electric-to-electric efficiency by default. Changing this characteristic is not possible at the moment but it will be possible in the near future. Users are welcome to add additional features to our open source code base on GitHub. I have created a setup with 2 identical areas. I would like to know how the d3a works if one area is prioritised over the other during clearing. Does it change when I change the random seed number ? \u00b6 If two areas are completely identical i.e post the same offer/bid, the market will randomly choose one of them. You can control this randomness by changing the random seed number in the launch CLI by adding --seed TEXT. I would like to study a structure with multiple microgrids exchanging energy based on a two sided market pay as clear. Furthermore, I would like that the exchanges inside microgrids (between houses) be based on a two sided market pay as bid. Can I setup such a structure with multiple market types inside one simulation ? \u00b6 No, for now that is not possible. You can only have one market type per simulation. In my simulations results, sometimes an area/device is both a seller and a buyer at the same time. Why does this happen ? \u00b6 Sometimes areas can be both a seller and a buyer at the same time. This is explained by the open market. It happens that loads in the area are not fast enough to place bids to buy their own generation. This also happens because of the device\u2019s strategy. If other loads (outside of the area) have the same buying rate as the load inside the area (and there are no grid fees), they can possibly \u201csteal\u201d the offers. To avoid this, you have to change the strategies and/or add grid fees in your simulation. This will help to prioritise self consumption inside each area. I am creating a simulation with one load and one generation and I am using the two sided market pay as clear. Sometimes, when my generation is lower than my demand, there are no trades at all. What is the reason for that ? \u00b6 The two sided market pay as clear is cleared if at least one bid is satisfied. For example in your case, since your only bid is not entirely satisfied, the market will not clear and therefore there won\u2019t be any trades. Can I configure all types of grid topography from meshed to radial under the same voltage level ? \u00b6 The D3A is designed for radial and hierarchical grid structures. Other topography types might be possible as long as they do not contain \"cycles\" (essentially closed loops in the grid structure). What you cannot currently simulate are loop networks, like rings. If I have a use case that has both residential consumers at 240V and industrial customers at 415V or higher, how can I set this up ? \u00b6 For now, voltage level is irrelevant, meaning that the D3A only simulate the amounts of energy transferred between each node (this will become important once we implement imbalances, differences between consumption and generation, which impact the frequency and the voltage of the grid). You can now simulate a grid that contains both residential and industrial consumers ignoring voltage limitations by taking for granted that the step-up transformers and transmission lines power rating will not be violated (since D3A does not check this for now). This will change once the power flows feature is implemented. By adding this new functionality, the electrical properties of the grid will be represented and used in the simulations. We recommend that each level of the D3A is tied to a specific grid voltage, so that each voltage level has its own market. How are the grid fees applied ? How do I set them up ? \u00b6 The grid fees represent the cost of the grid, taxes and other fees that are paid to another entity in exchange for using the grid. You can look at this page to see how you can set this up. When you define grid fees, it is applied inside of the specific area. These fees will be applied on the offers and bids, by raising or lowering their prices. Consequently, when an offer is published, its selling price will be the one defined by the seller plus the relevant grid fees. For trades to occur, the bid price minus the expected grid fees should be higher than the selling price plus the expected grid fees (for the two sided markets). Use of Blockchain \u00b6 Does D3A use blockchain technology ? \u00b6 The D3A has been designed so that it does not require blockchain technology but that it can benefit from this technology to provide enhanced functionality. Namely, if D3A-enabled deployment of energy markets is implemented via blockchain smart contracts there is full transparency of transactions, placing full trust in fair collaboration of energy actors rather than one actor having a market advantage. What are the current technological limitations for D3A\u2019s blockchain implementation and possible solutions ? \u00b6 The main limitation relates to scale or transactions throughput per second. We have tested the D3A on the ganache\u2019s private blockchain and it works only with increased simulation time as the processing is slower than when using the Python interpreter. The Energy Web Chain , designed especially for energy sector, is more efficient and less costly (in terms of transaction fees) than any other available public platform and hence would be the current blockchain of choice. As one single blockchain may never be able to handle the number and size of transactions of a large electrical grid, one solution to the problem lies in the interoperability of blockchains, with each responsible for one grid/area. This solution is proposed by the Polkadot Network , which will be launched and tested in 2020. In this scenario, the Energy Web Chain 2.0 could act as the relay chain for parachains for specific domains i.e. grid areas. Considering the hierarchical nature of the D3A market structure, do you look for special features on the blockchain for D3A to work more efficiently ? \u00b6 As D3A is hierarchical in design, there is a need of hierarchies of blockchain that specifically handle their own local grid/area. The Polkadot Network is therefore well suited for future D3A implementation. Grid Singularity\u2019s Approach \u00b6 Why is the D3A open source ? \u00b6 We believe that disruptive innovation that will lead us to new solutions to bring about the energy transition can not be achieved with private projects but rather with an open source community where everyone can contribute value, opportunities and challenges. The GPLv.3 license protects our code in a way that anyone who wishes to pursue proprietary commercialisation of the software would need to apply for a license, while open source applications continue to be free. What is the link between Grid Singularity and Energy Web Foundation ? \u00b6 Grid Singularity, an energy technology startup, and the Rocky Mountain Institute, a nonprofit clean technology organisation, jointly founded the Energy Web Foundation (EWF) in January 2017. EWF is a nonprofit foundation gathering an ecosystem of over 100 energy corporates and startups with a shared, public blockchain platform, the Energy Web Chain. While Grid Singularity has significantly contributed to EWF development and the launch of the Energy Web Chain, its role today is supervisory and advisory, with two Grid Singularity representatives serving on the EWF\u2019s Foundation Council. The Energy Web Chain is the blockchain of choice for D3A\u2019s future blockchain implementation. What are the future development plans ? \u00b6 We have partnered with innovative energy companies to facilitate further D3A development in the framework of the Odyssey 2020 Energy Singularity Track led by Grid Singularity. We will also work on some specific market simulation studies with partners to demonstrate the value of local energy markets. Following Odyssey Hackathon in June, we plan to deploy the D3A engine on a Testnet by the end of 2020. If I have questions regarding the D3A use, how can I contact you ? \u00b6 Please first review our wiki page documentation on the UI and the backend code. The best way to engage with us is via the D3A community/ecosystem channel on Slack . For any additional comments/feedback you can also send us an email at d3a@gridsingularity.com .","title":"FAQ"},{"location":"faq/#d3a-functionality","text":"","title":"D3A Functionality"},{"location":"faq/#what-is-the-d3a","text":"The D3A is an energy exchange engine. It is an open source software, enabling users to model, simulate, optimise, download, and deploy their own energy exchanges. The D3A is designed to build \u201cdigital twin\u201d representations of physical energy systems and energy markets. It aims to build open energy exchanges, extending access for new energy players, a class which is growing due to increased investments in distributed energy resources and smart devices. By creating energy exchanges from bottom to top, smart, local, and flexible devices as well as distributed renewable generation can be monetised for a faster transition to 100% renewable energy. The D3A simulation engine is currently available in two formats - the open source backend code , and the user friendly frontend User Interface (UI) .","title":"What is the D3A ?"},{"location":"faq/#what-are-the-possible-use-cases-to-simulate-with-the-d3a","text":"The D3A is an energy exchange engine capable of simulating (and after further development facilitating) power flows and energy transactions in local marketplaces. The D3A showcases and harnesses the potential of transactive grids, renewable energy sources (RES) and peer to peer (P2P) energy trading for all stakeholders in the energy transition and can have multiple applications, including the following use cases. Community as a Service . Creates a local energy market within the grid-tied community and allows all energy assets (e.g. residential rooftop solar) equal access to market alongside traditional energy providers. This enables prosumers to participate actively in the energy market by trading locally before buying from or selling to the grid provider. Energy Access . Creates a local energy market within an islanded microgrid energy community . This allows for a more optimal microgrid configuration. To see an example of use case of \u201cCommunity as a Service\u201d with the D3A engine, please read our Medium article and watch our presentation from Event Horizon 2019 here . Both the \u201cCommunity as a Service\u201d and \u201cEnergy Access\u201d use cases are available as public projects at d3a.io .","title":"What are the possible use cases to simulate with the D3A ?"},{"location":"faq/#do-the-d3a-frontend-and-the-backend-have-the-same-functionalities","text":"The backend code offers the full functionality of the active version of the D3A. The frontend User Interface (UI) offers a user friendly interface to the majority of features found in the backend. New features are typically developed in the backend first and are made available in the UI after internal testing for usability and accuracy.","title":"Do the D3A frontend and the backend have the same functionalities ?"},{"location":"faq/#frontend-user-interface-at-d3aio","text":"","title":"Frontend / User Interface at d3a.io"},{"location":"faq/#how-do-i-setup-a-simulation-in-the-frontend","text":"To start using the D3A you need to register your account. You will then receive an email with a link to confirm your account. Once done you will be able to connect to d3a.io with your account. You can design your own project by clicking on \u201cnew project\u201d and then create a new simulation in it. The first step in setting up a simulation is to define the simulation settings. You can set the simulation duration, the solar profile type, the market type, and other relevant parameters. In the D3A you can choose one of the 3 market types available : single-sided pay as offer, two-sided pay as bid and two-sided pay as clear (for more information on the simulation settings please follow this link ). The next step is to design your grid. Once you arrive in the grid setup, the first thing that you will have to do is to define the market maker. Its goal is to represent a static or fluctuating base market price which will serve as a reference point for the selected device strategies. After creating this market maker, you can start building the digital twin of your grid. The D3A works by creating area markets. In each of these areas you can put devices or other grid areas. The devices can be loads, PV, storage, etc. The setup is intended to represent the physical architecture of the real energy market (country, region, neighbourhood, house, etc.). Importantly, each area contains a spot market where trades can occur. Each device places a bid/offer in their home market. When bids/offers are not matched in their own area, they are forwarded to the upper market in the upper area and so on. After your grid setup is complete, you can run your simulation. When it is finished you can view multiple scrollable plots and tables on the results page (for more on how to use these visuals, please see this link ) and you can also download the results file on your computer. For a step-by-step explanation on how to setup your simulation, please watch our tutorial . You can also see a video explaining the new release features implemented on the frontend here . If you have any other problems, please visit our documentation wiki page for the frontend and the backend D3A versions.","title":"How do I setup a simulation in the frontend ?"},{"location":"faq/#are-there-any-limitations-concerning-the-size-of-the-simulation","text":"For smoother simulations and smaller queue, we have set some boundaries. First, the simulations are limited in their duration. You can currently set the duration from 1 to 7 days. Furthermore, the number of agents allowed per simulation is limited. Each device and area is considered as an agent and you can define up to 250 of these.","title":"Are there any limitations concerning the size of the simulation ?"},{"location":"faq/#backend-codebase","text":"","title":"Backend Codebase"},{"location":"faq/#how-do-i-setup-a-simulation-in-the-backend","text":"There is no need to login to set up a simulation in the backend. You just need to follow the steps bellow : Download the code from our GitHub Repository . Please follow the technical instructions here to correctly install the D3A on your computer. To design a grid setup, please create a python file and follow our tips on how to setup file and global settings . You can also review our setup examples located at d3a/src/d3a/setup/ . To run a setup file you need to place it in the directory d3a/src/d3a/setup/ , or change the path yourself in the ConstSettings.py file. To launch the simulation in the command line interface, follow our technical instructions .","title":"How do I setup a simulation in the backend ?"},{"location":"faq/#why-do-my-results-keep-changing-when-i-rerun-the-same-setup","text":"This is caused by the random seed number. This number controls the randomness of the market, the bids, offers and the trades. If you have not defined this number, at each simulation a new random seed number will be generated and therefore you will keep observing different results (for example the trades between the areas and the storage SOC can vary). To set the random seed number you have to add this in the simulation launch command line interface --seed TEXT. By doing so, the randomness of the simulation will be frozen and your results won\u2019t change anymore.","title":"Why do my results keep changing when I rerun the same setup ?"},{"location":"faq/#i-am-creating-a-long-simulation-weekmonthyear-and-would-like-to-establish-my-spot-market-in-the-day-ahead-is-this-possible-or-is-it-frozenstrictly-at-15-minutes-ahead","text":"No, for now you cannot establish your spot market in the day ahead, but you can choose the number of tradable market slots into the future. This will allow your devices to trade in multiple future spot markets. To enable this functionality, you have to add to your simulation a launch command -m number_of_tradable_markets. The size of the market slot is configurable. You can change the market slot length of 15 minutes to be any integer between 2 minutes and 60 minutes.","title":"I am creating a long simulation (week/month/year) and would like to establish my spot market in the day ahead. Is this possible or is it frozen/strictly at 15 minutes ahead ?"},{"location":"faq/#i-am-using-the-energy-storage-system-ess-to-represent-a-compressed-air-storage-with-an-electric-to-electric-efficiency-of-50-how-can-i-implement-the-efficiency-in-the-ess-component","text":"For the time being, the storage component has a 100% electric-to-electric efficiency by default. Changing this characteristic is not possible at the moment but it will be possible in the near future. Users are welcome to add additional features to our open source code base on GitHub.","title":"I am using the energy storage system (ESS) to represent a compressed air storage (with an electric-to-electric efficiency of 50%). How can I implement the efficiency in the ESS component ?"},{"location":"faq/#i-have-created-a-setup-with-2-identical-areas-i-would-like-to-know-how-the-d3a-works-if-one-area-is-prioritised-over-the-other-during-clearing-does-it-change-when-i-change-the-random-seed-number","text":"If two areas are completely identical i.e post the same offer/bid, the market will randomly choose one of them. You can control this randomness by changing the random seed number in the launch CLI by adding --seed TEXT.","title":"I have created a setup with 2 identical areas. I would like to know how the d3a works if one area is prioritised over the other during clearing. Does it change when I change the random seed number ?"},{"location":"faq/#i-would-like-to-study-a-structure-with-multiple-microgrids-exchanging-energy-based-on-a-two-sided-market-pay-as-clear-furthermore-i-would-like-that-the-exchanges-inside-microgrids-between-houses-be-based-on-a-two-sided-market-pay-as-bid-can-i-setup-such-a-structure-with-multiple-market-types-inside-one-simulation","text":"No, for now that is not possible. You can only have one market type per simulation.","title":"I would like to study a structure with multiple microgrids exchanging energy based on a two sided market pay as clear. Furthermore, I would like that the exchanges inside microgrids (between houses) be based on a two sided market pay as bid. Can I setup such a structure with multiple market types inside one simulation ?"},{"location":"faq/#in-my-simulations-results-sometimes-an-areadevice-is-both-a-seller-and-a-buyer-at-the-same-time-why-does-this-happen","text":"Sometimes areas can be both a seller and a buyer at the same time. This is explained by the open market. It happens that loads in the area are not fast enough to place bids to buy their own generation. This also happens because of the device\u2019s strategy. If other loads (outside of the area) have the same buying rate as the load inside the area (and there are no grid fees), they can possibly \u201csteal\u201d the offers. To avoid this, you have to change the strategies and/or add grid fees in your simulation. This will help to prioritise self consumption inside each area.","title":"In my simulations results, sometimes an area/device is both a seller and a buyer at the same time. Why does this happen ?"},{"location":"faq/#i-am-creating-a-simulation-with-one-load-and-one-generation-and-i-am-using-the-two-sided-market-pay-as-clear-sometimes-when-my-generation-is-lower-than-my-demand-there-are-no-trades-at-all-what-is-the-reason-for-that","text":"The two sided market pay as clear is cleared if at least one bid is satisfied. For example in your case, since your only bid is not entirely satisfied, the market will not clear and therefore there won\u2019t be any trades.","title":"I am creating a simulation with one load and one generation and I am using the two sided market pay as clear. Sometimes, when my generation is lower than my demand, there are no trades at all. What is the reason for that ?"},{"location":"faq/#can-i-configure-all-types-of-grid-topography-from-meshed-to-radial-under-the-same-voltage-level","text":"The D3A is designed for radial and hierarchical grid structures. Other topography types might be possible as long as they do not contain \"cycles\" (essentially closed loops in the grid structure). What you cannot currently simulate are loop networks, like rings.","title":"Can I configure all types of grid topography from meshed to radial under the same voltage level ?"},{"location":"faq/#if-i-have-a-use-case-that-has-both-residential-consumers-at-240v-and-industrial-customers-at-415v-or-higher-how-can-i-set-this-up","text":"For now, voltage level is irrelevant, meaning that the D3A only simulate the amounts of energy transferred between each node (this will become important once we implement imbalances, differences between consumption and generation, which impact the frequency and the voltage of the grid). You can now simulate a grid that contains both residential and industrial consumers ignoring voltage limitations by taking for granted that the step-up transformers and transmission lines power rating will not be violated (since D3A does not check this for now). This will change once the power flows feature is implemented. By adding this new functionality, the electrical properties of the grid will be represented and used in the simulations. We recommend that each level of the D3A is tied to a specific grid voltage, so that each voltage level has its own market.","title":"If I have a use case that has both residential consumers at 240V and industrial customers at 415V or higher, how can I set this up ?"},{"location":"faq/#how-are-the-grid-fees-applied-how-do-i-set-them-up","text":"The grid fees represent the cost of the grid, taxes and other fees that are paid to another entity in exchange for using the grid. You can look at this page to see how you can set this up. When you define grid fees, it is applied inside of the specific area. These fees will be applied on the offers and bids, by raising or lowering their prices. Consequently, when an offer is published, its selling price will be the one defined by the seller plus the relevant grid fees. For trades to occur, the bid price minus the expected grid fees should be higher than the selling price plus the expected grid fees (for the two sided markets).","title":"How are the grid fees applied ? How do I set them up ?"},{"location":"faq/#use-of-blockchain","text":"","title":"Use of Blockchain"},{"location":"faq/#does-d3a-use-blockchain-technology","text":"The D3A has been designed so that it does not require blockchain technology but that it can benefit from this technology to provide enhanced functionality. Namely, if D3A-enabled deployment of energy markets is implemented via blockchain smart contracts there is full transparency of transactions, placing full trust in fair collaboration of energy actors rather than one actor having a market advantage.","title":"Does D3A use blockchain technology ?"},{"location":"faq/#what-are-the-current-technological-limitations-for-d3as-blockchain-implementation-and-possible-solutions","text":"The main limitation relates to scale or transactions throughput per second. We have tested the D3A on the ganache\u2019s private blockchain and it works only with increased simulation time as the processing is slower than when using the Python interpreter. The Energy Web Chain , designed especially for energy sector, is more efficient and less costly (in terms of transaction fees) than any other available public platform and hence would be the current blockchain of choice. As one single blockchain may never be able to handle the number and size of transactions of a large electrical grid, one solution to the problem lies in the interoperability of blockchains, with each responsible for one grid/area. This solution is proposed by the Polkadot Network , which will be launched and tested in 2020. In this scenario, the Energy Web Chain 2.0 could act as the relay chain for parachains for specific domains i.e. grid areas.","title":"What are the current technological limitations for D3A\u2019s blockchain implementation and possible solutions ?"},{"location":"faq/#considering-the-hierarchical-nature-of-the-d3a-market-structure-do-you-look-for-special-features-on-the-blockchain-for-d3a-to-work-more-efficiently","text":"As D3A is hierarchical in design, there is a need of hierarchies of blockchain that specifically handle their own local grid/area. The Polkadot Network is therefore well suited for future D3A implementation.","title":"Considering the hierarchical nature of the D3A market structure, do you look for special features on the blockchain for D3A to work more efficiently ?"},{"location":"faq/#grid-singularitys-approach","text":"","title":"Grid Singularity\u2019s Approach"},{"location":"faq/#why-is-the-d3a-open-source","text":"We believe that disruptive innovation that will lead us to new solutions to bring about the energy transition can not be achieved with private projects but rather with an open source community where everyone can contribute value, opportunities and challenges. The GPLv.3 license protects our code in a way that anyone who wishes to pursue proprietary commercialisation of the software would need to apply for a license, while open source applications continue to be free.","title":"Why is the D3A open source ?"},{"location":"faq/#what-is-the-link-between-grid-singularity-and-energy-web-foundation","text":"Grid Singularity, an energy technology startup, and the Rocky Mountain Institute, a nonprofit clean technology organisation, jointly founded the Energy Web Foundation (EWF) in January 2017. EWF is a nonprofit foundation gathering an ecosystem of over 100 energy corporates and startups with a shared, public blockchain platform, the Energy Web Chain. While Grid Singularity has significantly contributed to EWF development and the launch of the Energy Web Chain, its role today is supervisory and advisory, with two Grid Singularity representatives serving on the EWF\u2019s Foundation Council. The Energy Web Chain is the blockchain of choice for D3A\u2019s future blockchain implementation.","title":"What is the link between Grid Singularity and Energy Web Foundation ?"},{"location":"faq/#what-are-the-future-development-plans","text":"We have partnered with innovative energy companies to facilitate further D3A development in the framework of the Odyssey 2020 Energy Singularity Track led by Grid Singularity. We will also work on some specific market simulation studies with partners to demonstrate the value of local energy markets. Following Odyssey Hackathon in June, we plan to deploy the D3A engine on a Testnet by the end of 2020.","title":"What are the future development plans ?"},{"location":"faq/#if-i-have-questions-regarding-the-d3a-use-how-can-i-contact-you","text":"Please first review our wiki page documentation on the UI and the backend code. The best way to engage with us is via the D3A community/ecosystem channel on Slack . For any additional comments/feedback you can also send us an email at d3a@gridsingularity.com .","title":"If I have questions regarding the D3A use, how can I contact you ?"},{"location":"finite-power-plant-strategy/","text":"A finite power plant is an energy supplier that offers a configurable amount of power per time slot at a configured energy rate. energy_rate : the energy rate in cents/kWh. max_available_power_kW = maximum available power in kW, can also be a power profile. Corresponding code: src/3a/models/strategy/finite_power_plant.py How to add a finite power plant to the setup-file : profile_kW = { 0: 0.1, 8: 0.15, 12: 0.2, 19: 0.15, 22: 0.1 } Area('Finite Power Plant', strategy=FinitePowerPlant(energy_rate=31.3, max_available_power_kW=profile_kW), appliance=SwitchableAppliance()),","title":"Finite Power Plant Strategy"},{"location":"general-settings/","text":"General Settings is where the general simulation parameters are set. The configuration will influence all markets and all energy resources in the simulation The following general settings can be set when creating a simulation: Simulation name: Please provide an unique name. Description: Description of the simulation (optional). Project: The user can select a project folder in which this simulation is saved. Start date: Simulation start date (please make sure that the date-stamp of any uploaded data coincides with the start date \u2192 end date). End date: Simulation end date. The user can simulate up to 7 days. Solar profile : Sets the production curve for all PVs in the configuration that don't have individual production curves. Select one the following possible configurations: Sunny (generation profile with 250W panel) Cloudy (generation profile with 250W panel) Partially Cloudy (generation profile with 250W panel) Gaussian (the user can define the power output of the panel) Upload a profile (a custom default PV production curve can be uploaded as described in Upload File Formats ) Spot market type: The user can select one of 3 types of market: One sided pay as offer , Two sided pay as bid and Two sided pay as clear . Number of spot markets: Number of future spot markets in which the energy resources and agents can trade. Length of market slot: Duration of each spot market. Should be between 2 and 60 minutes. Tick length: Amount of time between two \"heartbeats\" of the simulation, influences e.g. the number of price updates. Grid Fees: The user can select on of the 2 types of grid fee : Constant grid fee and Percentage grid fee The interface for selecting general settings is shown below:","title":"General Settings"},{"location":"grid-api/","text":"Market API documentation \u00b6 The D3A API client allows you to create agents that manage different markets. The agent can request and receive information through the API, feed that information into a tariff model, and change grid fees on a live simulated exchange. The grid API is designed for grid operators to manage a specific market. The structure is designed so that multiple markets can be managed with a single script. Notably this allows markets to share information in order to have a better overall grid management. This document covers installation and descriptions of the functions available. API command \u00b6 The grid api can function once at the end of every market slots. When a the current market is finished the client will get notified via an event. It is possible to capture this event and perform operations after it by overriding the on_market_cycle method. Ex: def on_market_cycle(self, market_info): The market API can send batch command, grouping different command, for different markets. 3 different commands are available : market stats \u00b6 This command is used to request information from different market for the last market slot. A batch_command dictionary structure is used and the response is stored in a variable : batch_commands [ area_uuid ] . append ({ \"type\" : \"market_stats\" , \"data\" : { \"market_slots\" : market_slot }}) self . market_stats = self . batch_command ( batch_commands_stats ) dso market stats \u00b6 This command is used to request information from different market for the last market slot. With this command the client receive additional information (e.g. import and export of the market) A batch_command dictionary structure is used and the response is stored in a variable : batch_commands_stats [ area_uuid ] . append ({ \"type\" : \"dso_market_stats\" , \"data\" : { \"market_slots\" : market_slot }}) self . dso_stats = self . batch_command ( batch_commands_stats )[ \"responses\" ] grid fee \u00b6 This command is used to send the new grid fee for a specific market. The grid fee needs to be sent as an integer and the unit is cents/kWh. A batch_command dictionary structure is used : batch_commands [ area_uuid ] . append ({ \"type\" : \"grid_fees\" , \"data\" : { \"fee_const\" : self . next_fee }}) self . batch_command ( batch_commands ) Information \u00b6 The market api receives information concerning the markets that it manages. Different metrics are shared through the API : Minimum, median, average and maximum trade price [\u20ac/kWh] Total energy volume traded [kWh] Self sufficiency [%] Import / Export [kWh] Current market fee [cents/kWh] Next market fee [cents/kWh] Interaction with the running exchange \u00b6 As explained above the Market API function at the end of each market slot. Let's take the following example and operations' order: At the end of the market slot 12:45, the Market API function on_market_cycle is triggered. In results Client will request and receive information of the last market slot (12:45-13:00). Based on these information the Client script set new grid fee for the markets it manages. Since the new grid fees are sent at 13:00 they will be actually applied at 13:15 (15min delay)","title":"Market API"},{"location":"grid-api/#market-api-documentation","text":"The D3A API client allows you to create agents that manage different markets. The agent can request and receive information through the API, feed that information into a tariff model, and change grid fees on a live simulated exchange. The grid API is designed for grid operators to manage a specific market. The structure is designed so that multiple markets can be managed with a single script. Notably this allows markets to share information in order to have a better overall grid management. This document covers installation and descriptions of the functions available.","title":"Market API documentation"},{"location":"grid-api/#api-command","text":"The grid api can function once at the end of every market slots. When a the current market is finished the client will get notified via an event. It is possible to capture this event and perform operations after it by overriding the on_market_cycle method. Ex: def on_market_cycle(self, market_info): The market API can send batch command, grouping different command, for different markets. 3 different commands are available :","title":"API command"},{"location":"grid-api/#market-stats","text":"This command is used to request information from different market for the last market slot. A batch_command dictionary structure is used and the response is stored in a variable : batch_commands [ area_uuid ] . append ({ \"type\" : \"market_stats\" , \"data\" : { \"market_slots\" : market_slot }}) self . market_stats = self . batch_command ( batch_commands_stats )","title":"market stats"},{"location":"grid-api/#dso-market-stats","text":"This command is used to request information from different market for the last market slot. With this command the client receive additional information (e.g. import and export of the market) A batch_command dictionary structure is used and the response is stored in a variable : batch_commands_stats [ area_uuid ] . append ({ \"type\" : \"dso_market_stats\" , \"data\" : { \"market_slots\" : market_slot }}) self . dso_stats = self . batch_command ( batch_commands_stats )[ \"responses\" ]","title":"dso market stats"},{"location":"grid-api/#grid-fee","text":"This command is used to send the new grid fee for a specific market. The grid fee needs to be sent as an integer and the unit is cents/kWh. A batch_command dictionary structure is used : batch_commands [ area_uuid ] . append ({ \"type\" : \"grid_fees\" , \"data\" : { \"fee_const\" : self . next_fee }}) self . batch_command ( batch_commands )","title":"grid fee"},{"location":"grid-api/#information","text":"The market api receives information concerning the markets that it manages. Different metrics are shared through the API : Minimum, median, average and maximum trade price [\u20ac/kWh] Total energy volume traded [kWh] Self sufficiency [%] Import / Export [kWh] Current market fee [cents/kWh] Next market fee [cents/kWh]","title":"Information"},{"location":"grid-api/#interaction-with-the-running-exchange","text":"As explained above the Market API function at the end of each market slot. Let's take the following example and operations' order: At the end of the market slot 12:45, the Market API function on_market_cycle is triggered. In results Client will request and receive information of the last market slot (12:45-13:00). Based on these information the Client script set new grid fee for the markets it manages. Since the new grid fees are sent at 13:00 they will be actually applied at 13:15 (15min delay)","title":"Interaction with the running exchange"},{"location":"grid-setup/","text":"On this page the user can set up the architecture of the grid by adding Areas and Energy Resources. You can define up to 1000 nodes. Each area or energy resource is considered as 1 node. Areas are made up of a spot market in which all connected Energy Resources, sub-areas and parent areas trade energy. Areas can potentially house multiple markets of different market types. This feature will be available in the future. After creating the first area the user has to define a Market Maker . There are 4 different types of basic energy resources available (for detailed settings descriptions follow the individual links): PV Storage Load Power Plant The user can also insert Libraries , which are customized energy resources available from the D3A community. A list of these energy resources with a search function appears when clicking on \"LIBRARY\" on the upper right corner. Once ready, the user can to the Results page and run the simulation. When the simulation is running, the user can : Pause it Abort it (Warning, after aborting the user will not be able to resume the simulation!) The user can duplicate the number of Areas or Energy Resources by clicking on the +/- buttons shown below (energy resource or area settings view).","title":"Initial Grid Setup"},{"location":"how-implement-custom-device-strategies/","text":"It is possible for the user to overwrite some of the functionalities of the three basic strategies ( PVStrategy , StorageStrategy , LoadHoursStrategy ). In order to implement the custom strategies: Go to the desired python file: d3a/models/strategy/custom_.py Change the code of the desired functions accordingly by replacing pass with the desired functionality. There are example files in d3a/setup/jira/ named test_strategy_custom_<device>.py that are also used for integration tests. CustomPvStrategy \u00b6 The user can change the functionality of the following function of the PVStrategy in d3a/models/strategy/custom_pv.py : produced_energy_forecast_kWh Overwrites d3a.models.strategy.pv.produced_energy_forecast_kWh and returns the energy production of the custom PV for each market slot. Is called on every ACTIVATE event. Returns dictionary that describes energy production in kWh for each market slot: self.energy_production_forecast_kW . Note that the dictionary should have as many entries as the number of market slots. calculate_initial_sell_rate Overrides d3a.models.strategy.update_frequency.calculate_initial_sell_rate . Is called on every MARKET_CYCLE event. Returns the initial value of the sell energy rate for each hour of the simulation. Parameter: current_time_h : slot time in hours (e.g. market.time_slot.hour). decrease_energy_price_over_ticks Overrides d3a.models.strategy.update_frequency.decrease_energy_price_over_ticks . Is called on every EVENT_TICK event. Should be used to modify the price decrease over the ticks for the selected market. CustomStorageStrategy \u00b6 The user can change the functionality of the following functions of the StorageStrategy in d3a/setup/jira/test_strategy_custom_storage.py : calculate_energy_to_buy Overrides d3a.models.strategy.storage.calculate_energy_to_buy . Is called by StorageStrategy.buy_energy and runs on every EVENT_TICK event. Clamps to-buy energy to physical or market margins. Returns clamped energy in kWh. calculate_energy_to_sell Overrides d3a.models.strategy.storage.calculate_energy_to_sell . Is called by StorageStrategy.sell_energy and runs on every EVENT_MARKET_CYCLE event. Clamps to-sell energy to physical or market margins. Returns clamped energy in kWh. calculate_selling_rate Overrides d3a.models.strategy.storage.calculate_selling_rate . Is called by StorageStrategy.sell_energy and runs on every EVENT_MARKET_CYCLE event. Returns initial selling rate in ct./kWh. decrease_energy_price_over_ticks Overrides d3a.models.strategy.update_frequency.decrease_energy_price_over_ticks . Is called on every EVENT_TICK event. Should be used to modify the price decrease over the ticks for the selected market. select_market_to_sell Overrides d3a.models.strategy.storage.select_market_to_sell . Is called by StorageStrategy.sell_energy and runs on every EVENT_MARKET_CYCLE event. Returns target market object. update_posted_bids Overwrites d3a.models.strategy.load_hours_fb.update_posted_bids . Is called on every TICK event. Should be used to modify the price of the bids over the ticks for the selected market. In the default implementation, an increase of the energy over the ticks is implemented. CustomLoadStrategy \u00b6 The user can change the functionality of the following functions of the LoadHoursStrategy in d3a/models/strategy/custom_load.py : update_posted_bids Overwrites d3a.models.strategy.load_hours_fb.update_posted_bids . Is called on every TICK event. Should be used to modify the price of the bids over the ticks for the selected market. In the default implementation, an increase of the energy over the ticks is implemented.","title":"How to Implement Custom Device Strategies"},{"location":"how-implement-custom-device-strategies/#custompvstrategy","text":"The user can change the functionality of the following function of the PVStrategy in d3a/models/strategy/custom_pv.py : produced_energy_forecast_kWh Overwrites d3a.models.strategy.pv.produced_energy_forecast_kWh and returns the energy production of the custom PV for each market slot. Is called on every ACTIVATE event. Returns dictionary that describes energy production in kWh for each market slot: self.energy_production_forecast_kW . Note that the dictionary should have as many entries as the number of market slots. calculate_initial_sell_rate Overrides d3a.models.strategy.update_frequency.calculate_initial_sell_rate . Is called on every MARKET_CYCLE event. Returns the initial value of the sell energy rate for each hour of the simulation. Parameter: current_time_h : slot time in hours (e.g. market.time_slot.hour). decrease_energy_price_over_ticks Overrides d3a.models.strategy.update_frequency.decrease_energy_price_over_ticks . Is called on every EVENT_TICK event. Should be used to modify the price decrease over the ticks for the selected market.","title":"CustomPvStrategy"},{"location":"how-implement-custom-device-strategies/#customstoragestrategy","text":"The user can change the functionality of the following functions of the StorageStrategy in d3a/setup/jira/test_strategy_custom_storage.py : calculate_energy_to_buy Overrides d3a.models.strategy.storage.calculate_energy_to_buy . Is called by StorageStrategy.buy_energy and runs on every EVENT_TICK event. Clamps to-buy energy to physical or market margins. Returns clamped energy in kWh. calculate_energy_to_sell Overrides d3a.models.strategy.storage.calculate_energy_to_sell . Is called by StorageStrategy.sell_energy and runs on every EVENT_MARKET_CYCLE event. Clamps to-sell energy to physical or market margins. Returns clamped energy in kWh. calculate_selling_rate Overrides d3a.models.strategy.storage.calculate_selling_rate . Is called by StorageStrategy.sell_energy and runs on every EVENT_MARKET_CYCLE event. Returns initial selling rate in ct./kWh. decrease_energy_price_over_ticks Overrides d3a.models.strategy.update_frequency.decrease_energy_price_over_ticks . Is called on every EVENT_TICK event. Should be used to modify the price decrease over the ticks for the selected market. select_market_to_sell Overrides d3a.models.strategy.storage.select_market_to_sell . Is called by StorageStrategy.sell_energy and runs on every EVENT_MARKET_CYCLE event. Returns target market object. update_posted_bids Overwrites d3a.models.strategy.load_hours_fb.update_posted_bids . Is called on every TICK event. Should be used to modify the price of the bids over the ticks for the selected market. In the default implementation, an increase of the energy over the ticks is implemented.","title":"CustomStorageStrategy"},{"location":"how-implement-custom-device-strategies/#customloadstrategy","text":"The user can change the functionality of the following functions of the LoadHoursStrategy in d3a/models/strategy/custom_load.py : update_posted_bids Overwrites d3a.models.strategy.load_hours_fb.update_posted_bids . Is called on every TICK event. Should be used to modify the price of the bids over the ticks for the selected market. In the default implementation, an increase of the energy over the ticks is implemented.","title":"CustomLoadStrategy"},{"location":"how-strategies-adjust-prices/","text":"In each strategy, the bid or offer is changed according to its energy rate increase or decrease rate per update. Offers \u00b6 Related settings: initial_selling_rate final_selling_rate update_interval energy_rate_decrease_per_update fit_to_limit The following plot shows the energy rate in the frame of on spot market slot ( slot_length = 15mins ) for different combinations of the above mentioned parameters. If fit_to_limit is set to True , energy_rate_decrease_per_update is ignored and a rate decrease per time is calculated that starts at initial_selling_rate and ends at final_selling_rate while updating the rate every update_interval minutes. Bids \u00b6 Related settings: initial_buying_rate final_buying_rate update_interval energy_rate_increase_per_update fit_to_limit The following plot shows the energy rate in the frame of on spot market slot ( slot_length = 15mins ) for different combinations of the above mentioned parameters. If fit_to_limit is set to True , energy_rate_increase_per_update is ignored and a rate increase per time is calculated that starts at initial_buying_rate and ends at final_buying_rate while updating the rate every update_interval minutes.","title":"How Strategies Adjust the Prices of Offers and Bids"},{"location":"how-strategies-adjust-prices/#offers","text":"Related settings: initial_selling_rate final_selling_rate update_interval energy_rate_decrease_per_update fit_to_limit The following plot shows the energy rate in the frame of on spot market slot ( slot_length = 15mins ) for different combinations of the above mentioned parameters. If fit_to_limit is set to True , energy_rate_decrease_per_update is ignored and a rate decrease per time is calculated that starts at initial_selling_rate and ends at final_selling_rate while updating the rate every update_interval minutes.","title":"Offers"},{"location":"how-strategies-adjust-prices/#bids","text":"Related settings: initial_buying_rate final_buying_rate update_interval energy_rate_increase_per_update fit_to_limit The following plot shows the energy rate in the frame of on spot market slot ( slot_length = 15mins ) for different combinations of the above mentioned parameters. If fit_to_limit is set to True , energy_rate_increase_per_update is ignored and a rate increase per time is calculated that starts at initial_buying_rate and ends at final_buying_rate while updating the rate every update_interval minutes.","title":"Bids"},{"location":"infinite-bus-strategy/","text":"This device is the same as the commercial energy producer / infinite power plant in that it produces an infinite amount of energy at the energy_sell_rate . However, the infinite bus can also buy an infinite amount of energy at a predefined price, the energy_buy_rate. Configuration parameters: energy_buy_rate : energy rate for selling in cents/kWh (can be a profile in JSON or dict format as well as a filename) energy_sell_rate : energy rate for buying in cents/kWh (can be a profile in JSON or dict format as well as a filename) Corresponding code: src/3a/models/strategy/infinite_bus.py How to add a infinite power plant to the setup-file: Area('Infinite Bus', strategy=InfiniteBusStrategy(energy_buy_rate=24, energy_sell_rate=25), appliance=SimpleAppliance()),","title":"Infinite Bus Strategy"},{"location":"infinite-power-plant-strategy/","text":"An infinite power plant is coded as a Commercial Energy Producer in the D3A code. The infinite power plant is used to represent the concept of an infinite bus, which has an unchangeable energy supply, unaffected by variations or disturbances caused by connected grids. Similar to its stable energy supply, the selling price of the infinite power plant is also unaffected by competition. This selling price is called the market maker price, as it provides a basis for local markets as other devices to compete against each other and the infinite power plant (or in many cases, the legacy grid). The market maker price is configured globally for a simulation, unassigned to a specific device. But when configuring an infinite power plant, it usually makes sense to assign its energy rate to the market maker price. (The market maker price can be a constant value, a CSV file, or an array of changing values over time, similar to the PV and Load custom profile options). Rate settings include: energy_rate : the energy rate in cents/kWh (can be configured to the market maker price) Corresponding code: src/3a/models/strategy/commercial_producer.py","title":"Infinite Power Plant Strategy"},{"location":"installation-instructions-vm/","text":"How to Install D3A using a Virtual Machine (useful especially on Windows) \u00b6 Prerequisites \u00b6 Windows environment settings (not always required) \u00b6 Enable Intel Virtualization on your computer in BIOS . Go to your Windows Features setting and disable Windows Hypervisor Platform (or Hyper-V) and enable Virtual Machine Platform. Install VirtualBox and Vagrant \u00b6 It is recommended to use Chocolatey as a package management tool for Windows. Open your terminal (cmd.exe) as administrator Install chocolatey by running the following command : @\"%SystemRoot%\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\" -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command \"[System.Net.ServicePointManager]::SecurityProtocol = 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))\" && SET \"PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin\" Install Virtualbox from a Windows console choco install virtualbox Install Vagrant (this is a software wrapper around virtualbox and other supervisors, that allows easy creation, download, and installation of virtual machines. choco install vagrant vagrant plugin install vagrant-disksize Install D3A while sharing a folder between guest and host machine via vagrant \u00b6 Install D3A in a sharing folder \u00b6 Create a new-folder that you want to share across guest & host machine. Add the Vagrantfile from d3a repository into your newly created folder. Open a terminal and go your folder with : cd <path-to-your-folder> If it is your first time do : vagrant up Otherwise do step first : delete old vagrant images via : vagrant destroy --force Remove residues of old vagrant boxes via : vagrant box remove ubuntu/<your-box-name> --all --force At last do (note if the D3A is already installed and updated you don't need to do the steps above): Reload your virtual machine vagrant reload Access terminal of your virtual machine to run D3A vagrant ssh Share folder to windows host \u00b6 To share files between your virtual machine and windows we suggest to run these 3 commands : Share d3a : cp -r /home/vagrant/d3a /vagrant/ Share d3a-api-client : cp -r /home/vagrant/d3a-api-client /vagrant/ If you have results you want to export to windows : cd /home/vagrant/d3a-simulation/ zip -r <your-zip-filename>.zip ./<folder-to-be-zipped>/ cp -r <your-zip-filename>.zip /vagrant/ Run D3A simulation \u00b6 To run a d3a simulation you need to be working under the d3a environment source /home/vagrant/envs/d3a/bin/activate Run simulation with : cd /vagrant/d3a d3a run How to get d3a-api-client in Vagrant \u00b6 To run a d3a api client script you need to be working under the api-client environment source /home/vagrant/envs/api-client/bin/activate To run your API script, run the following command (templates here ) : python your_api_script.py","title":"Virtual Machine"},{"location":"installation-instructions-vm/#how-to-install-d3a-using-a-virtual-machine-useful-especially-on-windows","text":"","title":"How to Install D3A using a Virtual Machine (useful especially on Windows)"},{"location":"installation-instructions-vm/#prerequisites","text":"","title":"Prerequisites"},{"location":"installation-instructions-vm/#windows-environment-settings-not-always-required","text":"Enable Intel Virtualization on your computer in BIOS . Go to your Windows Features setting and disable Windows Hypervisor Platform (or Hyper-V) and enable Virtual Machine Platform.","title":"Windows environment settings (not always required)"},{"location":"installation-instructions-vm/#install-virtualbox-and-vagrant","text":"It is recommended to use Chocolatey as a package management tool for Windows. Open your terminal (cmd.exe) as administrator Install chocolatey by running the following command : @\"%SystemRoot%\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\" -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command \"[System.Net.ServicePointManager]::SecurityProtocol = 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))\" && SET \"PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin\" Install Virtualbox from a Windows console choco install virtualbox Install Vagrant (this is a software wrapper around virtualbox and other supervisors, that allows easy creation, download, and installation of virtual machines. choco install vagrant vagrant plugin install vagrant-disksize","title":"Install VirtualBox and Vagrant"},{"location":"installation-instructions-vm/#install-d3a-while-sharing-a-folder-between-guest-and-host-machine-via-vagrant","text":"","title":"Install D3A while sharing a folder between guest and host machine via vagrant"},{"location":"installation-instructions-vm/#install-d3a-in-a-sharing-folder","text":"Create a new-folder that you want to share across guest & host machine. Add the Vagrantfile from d3a repository into your newly created folder. Open a terminal and go your folder with : cd <path-to-your-folder> If it is your first time do : vagrant up Otherwise do step first : delete old vagrant images via : vagrant destroy --force Remove residues of old vagrant boxes via : vagrant box remove ubuntu/<your-box-name> --all --force At last do (note if the D3A is already installed and updated you don't need to do the steps above): Reload your virtual machine vagrant reload Access terminal of your virtual machine to run D3A vagrant ssh","title":"Install D3A in a sharing folder"},{"location":"installation-instructions-vm/#share-folder-to-windows-host","text":"To share files between your virtual machine and windows we suggest to run these 3 commands : Share d3a : cp -r /home/vagrant/d3a /vagrant/ Share d3a-api-client : cp -r /home/vagrant/d3a-api-client /vagrant/ If you have results you want to export to windows : cd /home/vagrant/d3a-simulation/ zip -r <your-zip-filename>.zip ./<folder-to-be-zipped>/ cp -r <your-zip-filename>.zip /vagrant/","title":"Share folder to windows host"},{"location":"installation-instructions-vm/#run-d3a-simulation","text":"To run a d3a simulation you need to be working under the d3a environment source /home/vagrant/envs/d3a/bin/activate Run simulation with : cd /vagrant/d3a d3a run","title":"Run D3A simulation"},{"location":"installation-instructions-vm/#how-to-get-d3a-api-client-in-vagrant","text":"To run a d3a api client script you need to be working under the api-client environment source /home/vagrant/envs/api-client/bin/activate To run your API script, run the following command (templates here ) : python your_api_script.py","title":"How to get d3a-api-client in Vagrant"},{"location":"installation-instructions/","text":"How to Install D3A on Linux \u00b6 Ubuntu 18.04 \u00b6 Preparations \u00b6 In case you have not installed git, python3.6 and pip yet: \u00b6 sudo apt-get update sudo apt-get install git-core software-properties-common -y sudo add-apt-repository ppa:deadsnakes/ppa sudo apt-get update sudo apt-get install python3.6 -y sudo apt-get install git-core -y sudo apt-get install python3-pip -y Install virtualenv and create a python virtual environment for d3a \u00b6 pip3 install virtualenv mkdir envs cd envs virtualenv -p /usr/bin/python3.6 d3a How to activate the environment: source d3a/bin/activate How to deactivate: deactivate Before you start: \u00b6 Please add the following lines to your .bashrc and reopen the shell: export LC_ALL=C.UTF-8 export LANG=C.UTF-8 Clone the d3a repository to a directory of your choice: git clone https://github.com/gridsingularity/d3a.git Install the D3A: \u00b6 Activate your virtualenvironment and go into the d3a repository Install pip-tools pip3 install pendulum pip-tools Install dependencies pip install -e . Now, if you run d3a run -\u2013help , the help of d3a should be shown. Ubuntu 20.04 \u00b6 Please follow the installation instructions for Ubuntu 18.04 error: command 'x86_64-linux-gnu-gcc' failed with exit status 1 Installing the following packages was fixing the issue in the past: sudo apt-get install build-essential python3.6-dev -y","title":"Linux"},{"location":"installation-instructions/#how-to-install-d3a-on-linux","text":"","title":"How to Install D3A on Linux"},{"location":"installation-instructions/#ubuntu-1804","text":"","title":"Ubuntu 18.04"},{"location":"installation-instructions/#preparations","text":"","title":"Preparations"},{"location":"installation-instructions/#in-case-you-have-not-installed-git-python36-and-pip-yet","text":"sudo apt-get update sudo apt-get install git-core software-properties-common -y sudo add-apt-repository ppa:deadsnakes/ppa sudo apt-get update sudo apt-get install python3.6 -y sudo apt-get install git-core -y sudo apt-get install python3-pip -y","title":"In case you have not installed git, python3.6 and pip yet:"},{"location":"installation-instructions/#install-virtualenv-and-create-a-python-virtual-environment-for-d3a","text":"pip3 install virtualenv mkdir envs cd envs virtualenv -p /usr/bin/python3.6 d3a How to activate the environment: source d3a/bin/activate How to deactivate: deactivate","title":"Install virtualenv and create a python virtual environment for d3a"},{"location":"installation-instructions/#before-you-start","text":"Please add the following lines to your .bashrc and reopen the shell: export LC_ALL=C.UTF-8 export LANG=C.UTF-8 Clone the d3a repository to a directory of your choice: git clone https://github.com/gridsingularity/d3a.git","title":"Before you start:"},{"location":"installation-instructions/#install-the-d3a","text":"Activate your virtualenvironment and go into the d3a repository Install pip-tools pip3 install pendulum pip-tools Install dependencies pip install -e . Now, if you run d3a run -\u2013help , the help of d3a should be shown.","title":"Install the D3A:"},{"location":"installation-instructions/#ubuntu-2004","text":"Please follow the installation instructions for Ubuntu 18.04 error: command 'x86_64-linux-gnu-gcc' failed with exit status 1 Installing the following packages was fixing the issue in the past: sudo apt-get install build-essential python3.6-dev -y","title":"Ubuntu 20.04"},{"location":"inter-area-agent/","text":"The Inter-Area Agent (IAA) plays a crucial role in the architecture of D3A. It is created for each area class (for nodes such as Houses, streets, etc. that do not have configured strategies) and mainly deals with forwarding offers and bids between markets of different hierarchy levels. The IAA class accounts for the direction of the offer, meaning whether the offer is sent from a lower to a higher hierarchy layer or the other way around. This is achieved by creating two separate IAA Engines for each direction. Sample grid setup and the role of the IAA in the hierarchy if nodes, leafs and markets (this scheme only applies for one time slot) : The Inter-Area Agent is responsible for modelling the inter-area operations for an area. The main functionalities of an inter-area agent can be summarized to these points: Forwarding offers from a lower hierarchy (market) to an upper hierarchy. Forwarding bids, in the same fashion as offers Keeping track of the aforementioned forwarded bids and offers Reacting to events coming from neighbouring inter-area agents, in order to propagate the event for an offer/bid that has been forwarded from this IAA. Triggering the matching of offers and bids for the two sided market.","title":"Inter-Area Agent"},{"location":"ios-installation-instructions/","text":"How to Install D3A on macOS \u00b6 Preparations \u00b6 Make sure the command line compiler tools are installed: \u00b6 xcode-select --install (Select 'Install' in the window that opens) Install Homebrew \u00b6 /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" Install some libraries we need later: \u00b6 brew install automake libtool pkg-config libffi gmp openssl readline xz Install pyenv: \u00b6 brew install pyenv echo -e 'if command -v pyenv 1>/dev/null 2>&1; then\\n eval \"$(pyenv init -)\"\\nfi' >> ~/.bash_profile Close and re-open the terminal \u00b6 Install Python 3.6 and set as default: \u00b6 pyenv install 3.6.3 pyenv global 3.6.3 Install virtualenvwrapper: \u00b6 pip install virtualenvwrapper echo -e 'export WORKON_HOME=~/Envs\\nsource ~/.pyenv/versions/3.6.3/bin/virtualenvwrapper.sh' >> ~/.bash_profile Setup paths for compiling python libraries: \u00b6 echo -e 'BREW_PREFIX=\"$(brew --prefix openssl)\"\\nexport CFLAGS=\"-I${BREW_PREFIX}/include\"\\nexport LDFLAGS=\"-L${BREW_PREFIX}/lib\"' >> ~/.bash_profile Installation \u00b6 Close and re-open the terminal \u00b6 Clone d3a repository (do this inside the directory where you want the project to be): \u00b6 git clone \"https://github.com/gridsingularity/d3a.git\" cd d3a Create and initialize d3a virtualenv \u00b6 brew install npm npm install --global ganache-cli mkvirtualenv d3a pip install pendulum pip-tools pip install -e . Install \u00b6 Done, you now should have a working d3a setup. \u00b6 Now, if you run d3a run -\u2013help , the help of d3a should be shown.","title":"Mac"},{"location":"ios-installation-instructions/#how-to-install-d3a-on-macos","text":"","title":"How to Install D3A on macOS"},{"location":"ios-installation-instructions/#preparations","text":"","title":"Preparations"},{"location":"ios-installation-instructions/#make-sure-the-command-line-compiler-tools-are-installed","text":"xcode-select --install (Select 'Install' in the window that opens)","title":"Make sure the command line compiler tools are installed:"},{"location":"ios-installation-instructions/#install-homebrew","text":"/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"","title":"Install Homebrew"},{"location":"ios-installation-instructions/#install-some-libraries-we-need-later","text":"brew install automake libtool pkg-config libffi gmp openssl readline xz","title":"Install some libraries we need later:"},{"location":"ios-installation-instructions/#install-pyenv","text":"brew install pyenv echo -e 'if command -v pyenv 1>/dev/null 2>&1; then\\n eval \"$(pyenv init -)\"\\nfi' >> ~/.bash_profile","title":"Install pyenv:"},{"location":"ios-installation-instructions/#close-and-re-open-the-terminal","text":"","title":"Close and re-open the terminal"},{"location":"ios-installation-instructions/#install-python-36-and-set-as-default","text":"pyenv install 3.6.3 pyenv global 3.6.3","title":"Install Python 3.6 and set as default:"},{"location":"ios-installation-instructions/#install-virtualenvwrapper","text":"pip install virtualenvwrapper echo -e 'export WORKON_HOME=~/Envs\\nsource ~/.pyenv/versions/3.6.3/bin/virtualenvwrapper.sh' >> ~/.bash_profile","title":"Install virtualenvwrapper:"},{"location":"ios-installation-instructions/#setup-paths-for-compiling-python-libraries","text":"echo -e 'BREW_PREFIX=\"$(brew --prefix openssl)\"\\nexport CFLAGS=\"-I${BREW_PREFIX}/include\"\\nexport LDFLAGS=\"-L${BREW_PREFIX}/lib\"' >> ~/.bash_profile","title":"Setup paths for compiling python libraries:"},{"location":"ios-installation-instructions/#installation","text":"","title":"Installation"},{"location":"ios-installation-instructions/#close-and-re-open-the-terminal_1","text":"","title":"Close and re-open the terminal"},{"location":"ios-installation-instructions/#clone-d3a-repository-do-this-inside-the-directory-where-you-want-the-project-to-be","text":"git clone \"https://github.com/gridsingularity/d3a.git\" cd d3a","title":"Clone d3a repository (do this inside the directory where you want the project to be):"},{"location":"ios-installation-instructions/#create-and-initialize-d3a-virtualenv","text":"brew install npm npm install --global ganache-cli mkvirtualenv d3a pip install pendulum pip-tools pip install -e .","title":"Create and initialize d3a virtualenv"},{"location":"ios-installation-instructions/#install","text":"","title":"Install"},{"location":"ios-installation-instructions/#done-you-now-should-have-a-working-d3a-setup","text":"Now, if you run d3a run -\u2013help , the help of d3a should be shown.","title":"Done, you now should have a working d3a setup."},{"location":"kpis/","text":"In the last few years, distributed energy resources concept has gained ground in the power utility scope. Strictly speaking in terms of D3A, it is necessary to know a metric that could aid in visualising local resource utilisation in distributed energy trading platform. In order to do so we have planned to implement some KPIs to give us a good figure of effectiveness of localised distributed energy trading. Self-Sufficiency & Self-Consumption \u00b6 The Self-Sufficiency of an area is its internal consumption of energy (all energy consumed that was produced internally in the area) as a fraction of it's demand of energy (all energy demanded by the area). The Self-Consumption of an area is its internal consumption of energy (all energy consumed that was produced internally in the area) as a fraction of it's production of energy (all energy produced by the area). Strictly speaking in terms of formula: self_sufficiency(area) = self_consumed_energy / total_energy_demanded self_consumption(area) = self_consumed_energy / total_energy_produced If you have a look at the hierarchical energy grid as shown in figure below, the self_consumed energy would be different from the reference point of whole energy grid. Lets consider house 1 where, total_house1_pv_production = 10kWh house1_pv \u2192 house1_load = 1kWh house1_pv \u2192 house1_storage = 5kWh house1_pv \u2192 house2_load = 4kWh house1_storage \u2192 house1_load = 2kWh house1_storage \u2192 house2_load = 3kWh house1_self_consumer_energy = ( house1_pv \u2192 house1_load ) + ( house1_pv \u2192 house1_storage \u2192 house1_load ) = 1 + 2 = 3kWh house1_total_energy_demanded (only includes the demanded energy from house1\u2019s load device) = 3kWh Then, self-sufficiency of the house 1 is self_sufficiency(house1) = house1_self_consumer_energy / house1_total_energy_demanded self_sufficiency(house1) = 3 / 3 = 0.75 \u2192 100% Then, self-consumption of the house 1 is self_consumption(house1) = house1_self_consumer_energy / house1_total_energy_produced self_consumption(house1) = 3 / 10 = 0.3 \u2192 30% From the reference point of GRID where all others areas are its children: self_sufficiency = 10 / 10 = 1 \u2192 100% self_consumption = 10 / 10 = 1 \u2192 100% Peak percentage \u00b6 The energy peak imports/exports is the maximum of the aggregate imports/exports of every node inside an area. The user has the possibility to set a baseline_peak_energy_import_kWh and a baseline_peak_energy_export_kWh that he may have gotten from another simulation in order to calculate the energy peak percentage, a measure of how much the peak imports or exports have changed between a baseline and the current simulation. The user may be interested in the Energy Peak Percentage KPI in order to determine the impact that adding grid fees or energy storage has on the peak imports and exports of an area. The Energy Peak Percentage can be calculated as follows : Import_peak_percentage = import_peak_energy_kWh / import_baseline_peak_energy_kWh * 100 Export_peak_percentage = export_peak_energy_kWh / export_baseline_peak_energy_kWh * 100","title":"Key Performance Indicators (KPIs)"},{"location":"kpis/#self-sufficiency-self-consumption","text":"The Self-Sufficiency of an area is its internal consumption of energy (all energy consumed that was produced internally in the area) as a fraction of it's demand of energy (all energy demanded by the area). The Self-Consumption of an area is its internal consumption of energy (all energy consumed that was produced internally in the area) as a fraction of it's production of energy (all energy produced by the area). Strictly speaking in terms of formula: self_sufficiency(area) = self_consumed_energy / total_energy_demanded self_consumption(area) = self_consumed_energy / total_energy_produced If you have a look at the hierarchical energy grid as shown in figure below, the self_consumed energy would be different from the reference point of whole energy grid. Lets consider house 1 where, total_house1_pv_production = 10kWh house1_pv \u2192 house1_load = 1kWh house1_pv \u2192 house1_storage = 5kWh house1_pv \u2192 house2_load = 4kWh house1_storage \u2192 house1_load = 2kWh house1_storage \u2192 house2_load = 3kWh house1_self_consumer_energy = ( house1_pv \u2192 house1_load ) + ( house1_pv \u2192 house1_storage \u2192 house1_load ) = 1 + 2 = 3kWh house1_total_energy_demanded (only includes the demanded energy from house1\u2019s load device) = 3kWh Then, self-sufficiency of the house 1 is self_sufficiency(house1) = house1_self_consumer_energy / house1_total_energy_demanded self_sufficiency(house1) = 3 / 3 = 0.75 \u2192 100% Then, self-consumption of the house 1 is self_consumption(house1) = house1_self_consumer_energy / house1_total_energy_produced self_consumption(house1) = 3 / 10 = 0.3 \u2192 30% From the reference point of GRID where all others areas are its children: self_sufficiency = 10 / 10 = 1 \u2192 100% self_consumption = 10 / 10 = 1 \u2192 100%","title":"Self-Sufficiency &amp; Self-Consumption"},{"location":"kpis/#peak-percentage","text":"The energy peak imports/exports is the maximum of the aggregate imports/exports of every node inside an area. The user has the possibility to set a baseline_peak_energy_import_kWh and a baseline_peak_energy_export_kWh that he may have gotten from another simulation in order to calculate the energy peak percentage, a measure of how much the peak imports or exports have changed between a baseline and the current simulation. The user may be interested in the Energy Peak Percentage KPI in order to determine the impact that adding grid fees or energy storage has on the peak imports and exports of an area. The Energy Peak Percentage can be calculated as follows : Import_peak_percentage = import_peak_energy_kWh / import_baseline_peak_energy_kWh * 100 Export_peak_percentage = export_peak_energy_kWh / export_baseline_peak_energy_kWh * 100","title":"Peak percentage"},{"location":"launch-sim-via-cli/","text":"Command line arguments include: -d, --duration : Duration of simulation [default: 24h] -t, --tick-length : Length of a tick [default: 1s] -s, --slot-length : Length of a market slot [default: 15m] -c, --cloud-coverage : Cloud coverage, 0 for sunny, 1 for partial coverage, 2 for clouds. [default: 0] -m, --market-count : Number of tradable market slots into the future [default: 5] Example simulation call: \u00b6 d3a -l ERROR run --duration=24h --tick-length=1s --slot-length=15m --cloud-coverage=0 --market-count=5 --setup default_2a Getting help in the command line: \u00b6 d3a --help returns: Usage: d3a [OPTIONS] COMMAND [ARGS]... Options: -l, --log-level [CRITICAL|FATAL|ERROR|WARN|WARNING|INFO|DEBUG|NOTSET|TRACE] Log level [default: INFO] --help Show this message and exit. Commands: run* resume d3a run --help returns: Usage: d3a run [OPTIONS] Options: -d, --duration INTERVAL Duration of simulation [default: 1d] -t, --tick-length INTERVAL Length of a tick [default: 1s] -s, --slot-length INTERVAL Length of a market slot [default: 15m] -c, --cloud-coverage INTEGER Cloud coverage, 0 for sunny, 1 for partial coverage, 2 for clouds. [default: 0] -m, --market-count INTEGER Number of tradable market slots into the future [default: 1] --setup TEXT Simulation setup module use. Available modules: [1000_houses, area_events.cloud_coverage_event, area_events.disable_interval_event, area_events.disconnect_interval_event, area_events.isolated_connect_event, area_events.isolated_disable_event, area_events.isolated_disconnect_event, area_events.isolated_enable_event, area_events.load_event, area_events.pv_event, area_events.storage_event, balancing_market.default_2a, balancing_market.one_load_one_pv, balancing_market.one_load_one_storage, balancing_market.one_storage_one_pv, balancing_market.test_device_registry, balancing_market.two_sided_one_load_one_pv, config_parameter_test, default_2, default_2a, default_2b, default_3, default_3_pv_only, default_3a, default_3b, default_4, default_5, default_addcurve, default_addcurve2, default_csv, graphs_testing, jira.d3asim_1024, jira.d3asim_1139, jira.d3asim_638_custom_load, jira.d3asim_639_custom_storage, jira.d3asim_640_custom_pv, jira.d3asim_778, jira.d3asim_780, jira.d3asim_869, jira.d3asim_871, jira.d3asim_895, jira.d3asim_895_pr1, jira.d3asim_895_pr2, jira.d3asim_895_pr3, jira.d3asim_962, jira.default_2off_d3asim_1475, jira.default_595, jira.default_611, jira.default_613, jira.default_623, jira.default_645, jira.default_737, jira.test_strategy_custom_load, jira.test_strategy_custom_pv, jira.test_strategy_custom_storage, json_arg, json_file, non_compounded_grid_fees, redis_communication_default_2a, sam_config, sam_config_const_load, sam_config_small, strategy_tests.commercial_producer_market_maker_rate, strategy_tests.ess_capacity_based_sell_offer, strategy_tests.ess_sell_offer_decrease_based_on_risk_or_rate, strategy_tests.finite_power_plant, strategy_tests.finite_power_plant_profile, strategy_tests.home_cp_ess_load, strategy_tests.home_hybrid_pv_ess_load, strategy_tests.infinite_bus, strategy_tests.predefined_pv_test, strategy_tests.pv_const_price_decrease, strategy_tests.pv_final_selling_rate, strategy_tests.pv_initial_pv_rate_option, strategy_tests.pv_max_panel_output, strategy_tests.pv_max_panel_power_global, strategy_tests.pv_risk_based_price_decrease, strategy_tests.storage_buys_and_offers, strategy_tests.storage_strategy_break_even_hourly, strategy_tests.user_profile_load_csv, strategy_tests.user_profile_load_csv_multiday, strategy_tests.user_profile_load_dict, strategy_tests.user_profile_pv_csv, strategy_tests.user_profile_pv_dict, strategy_tests.user_profile_wind_csv, strategy_tests.user_rate_profile_load_dict, tobalaba.one_producer_load, two_sided_market.default_2a, two_sided_market.infinite_bus, two_sided_market.offer_reposted_at_old_offer_rate, two_sided_market.one_cep_one_load, two_sided_market.one_load_5_pv_partial, two_sided_market.one_load_one_storage, two_sided_market.one_pv_one_load, two_sided_market.one_pv_one_storage, two_sided_market.one_storage_5_pv_partial, two_sided_market.user_min_rate_profile_load_dict, two_sided_market.with_balancing_market, two_sided_pay_as_clear.default_2a, two_sided_pay_as_clear.test_clearing_energy] -g, --settings-file TEXT Settings file path --slowdown INTEGER Slowdown factor [0 - 10,000]. Where 0 means: no slowdown, ticks are simulated as fast as possible; and 100: ticks are simulated in realtime --seed TEXT Manually specify random seed --paused Start simulation in paused state [default: False] --pause-at TEXT Automatically pause at a certain time. Accepted Input formats: (YYYY-MM-DD, HH:mm) [default: disabled] --repl / --no-repl Start REPL after simulation run. [default: False] --no-export Skip export of simulation data --export-path TEXT Specify a path for the csv export files (default: ~/d3a-simulation) --enable-bc Run simulation on Blockchain --compare-alt-pricing Compare alternative pricing schemes --start-date DATE Start date of the Simulation (YYYY-MM-DD) [default: 2019-09-27] --help Show this message and exit.","title":"How to launch Simulation via Command Line Interface (CLI)"},{"location":"launch-sim-via-cli/#example-simulation-call","text":"d3a -l ERROR run --duration=24h --tick-length=1s --slot-length=15m --cloud-coverage=0 --market-count=5 --setup default_2a","title":"Example simulation call:"},{"location":"launch-sim-via-cli/#getting-help-in-the-command-line","text":"d3a --help returns: Usage: d3a [OPTIONS] COMMAND [ARGS]... Options: -l, --log-level [CRITICAL|FATAL|ERROR|WARN|WARNING|INFO|DEBUG|NOTSET|TRACE] Log level [default: INFO] --help Show this message and exit. Commands: run* resume d3a run --help returns: Usage: d3a run [OPTIONS] Options: -d, --duration INTERVAL Duration of simulation [default: 1d] -t, --tick-length INTERVAL Length of a tick [default: 1s] -s, --slot-length INTERVAL Length of a market slot [default: 15m] -c, --cloud-coverage INTEGER Cloud coverage, 0 for sunny, 1 for partial coverage, 2 for clouds. [default: 0] -m, --market-count INTEGER Number of tradable market slots into the future [default: 1] --setup TEXT Simulation setup module use. Available modules: [1000_houses, area_events.cloud_coverage_event, area_events.disable_interval_event, area_events.disconnect_interval_event, area_events.isolated_connect_event, area_events.isolated_disable_event, area_events.isolated_disconnect_event, area_events.isolated_enable_event, area_events.load_event, area_events.pv_event, area_events.storage_event, balancing_market.default_2a, balancing_market.one_load_one_pv, balancing_market.one_load_one_storage, balancing_market.one_storage_one_pv, balancing_market.test_device_registry, balancing_market.two_sided_one_load_one_pv, config_parameter_test, default_2, default_2a, default_2b, default_3, default_3_pv_only, default_3a, default_3b, default_4, default_5, default_addcurve, default_addcurve2, default_csv, graphs_testing, jira.d3asim_1024, jira.d3asim_1139, jira.d3asim_638_custom_load, jira.d3asim_639_custom_storage, jira.d3asim_640_custom_pv, jira.d3asim_778, jira.d3asim_780, jira.d3asim_869, jira.d3asim_871, jira.d3asim_895, jira.d3asim_895_pr1, jira.d3asim_895_pr2, jira.d3asim_895_pr3, jira.d3asim_962, jira.default_2off_d3asim_1475, jira.default_595, jira.default_611, jira.default_613, jira.default_623, jira.default_645, jira.default_737, jira.test_strategy_custom_load, jira.test_strategy_custom_pv, jira.test_strategy_custom_storage, json_arg, json_file, non_compounded_grid_fees, redis_communication_default_2a, sam_config, sam_config_const_load, sam_config_small, strategy_tests.commercial_producer_market_maker_rate, strategy_tests.ess_capacity_based_sell_offer, strategy_tests.ess_sell_offer_decrease_based_on_risk_or_rate, strategy_tests.finite_power_plant, strategy_tests.finite_power_plant_profile, strategy_tests.home_cp_ess_load, strategy_tests.home_hybrid_pv_ess_load, strategy_tests.infinite_bus, strategy_tests.predefined_pv_test, strategy_tests.pv_const_price_decrease, strategy_tests.pv_final_selling_rate, strategy_tests.pv_initial_pv_rate_option, strategy_tests.pv_max_panel_output, strategy_tests.pv_max_panel_power_global, strategy_tests.pv_risk_based_price_decrease, strategy_tests.storage_buys_and_offers, strategy_tests.storage_strategy_break_even_hourly, strategy_tests.user_profile_load_csv, strategy_tests.user_profile_load_csv_multiday, strategy_tests.user_profile_load_dict, strategy_tests.user_profile_pv_csv, strategy_tests.user_profile_pv_dict, strategy_tests.user_profile_wind_csv, strategy_tests.user_rate_profile_load_dict, tobalaba.one_producer_load, two_sided_market.default_2a, two_sided_market.infinite_bus, two_sided_market.offer_reposted_at_old_offer_rate, two_sided_market.one_cep_one_load, two_sided_market.one_load_5_pv_partial, two_sided_market.one_load_one_storage, two_sided_market.one_pv_one_load, two_sided_market.one_pv_one_storage, two_sided_market.one_storage_5_pv_partial, two_sided_market.user_min_rate_profile_load_dict, two_sided_market.with_balancing_market, two_sided_pay_as_clear.default_2a, two_sided_pay_as_clear.test_clearing_energy] -g, --settings-file TEXT Settings file path --slowdown INTEGER Slowdown factor [0 - 10,000]. Where 0 means: no slowdown, ticks are simulated as fast as possible; and 100: ticks are simulated in realtime --seed TEXT Manually specify random seed --paused Start simulation in paused state [default: False] --pause-at TEXT Automatically pause at a certain time. Accepted Input formats: (YYYY-MM-DD, HH:mm) [default: disabled] --repl / --no-repl Start REPL after simulation run. [default: False] --no-export Skip export of simulation data --export-path TEXT Specify a path for the csv export files (default: ~/d3a-simulation) --enable-bc Run simulation on Blockchain --compare-alt-pricing Compare alternative pricing schemes --start-date DATE Start date of the Simulation (YYYY-MM-DD) [default: 2019-09-27] --help Show this message and exit.","title":"Getting help in the command line:"},{"location":"libraries/","text":"Libraries are pre-configured devices, Areas, and even small grids that can be reused in different simulations. The List of libraries is paginated. You can either click through the pages by pressing the \"Prev\" or \"Next\" button on the bottom right corner or use the search field on the top right to filter the list by the library names. The following buttons and labels can be seen in the Library page: Denotes public Libraries (other users can see the Library and the uploaded profiles): & (in the search bar) Quicklook labels for showing which kind of devices (and how many) are used in the library and whether they are areas: With this button the user can edit the library (or view public libraries): With this button the user can rename, duplicate or delete the library (only his own library): The user can also create a new library (redirects to Grid setup ):","title":"Libraries"},{"location":"load-strategy/","text":"In the one sided market, loads buy the cheapest offers available to them. However, they can also set a limit to the maximum price they are willing to pay. To configure a load, the user can input the following parameters: avg_power_W : average consuming power of the load. Unit is Watts. This is a required parameter. hrs_of_day : list representing a daily schedule that contains the hours where the load is allowed to consume energy. Default value is None , meaning that the load is allowed to consume energy during every hour of the day. See addendum below for more information. hrs_per_day : number of hours per day that the load is consuming power. The initial value is None , meaning that the load will consume energy for all the hours listed in the hrs_of_day parameter. See addendum below for more information. update_interval : time after which the rate should be updated (type: pendulum duration object). Range \u2192 [1:(slot_length_minute-1)] initial_buying_rate : initial rate in ct/kWh. final_buying_rate : final rate in ct/kWh. use_market_maker_rate: If this flag is set True , then agent's final_buying_rate would be overwritten with Market Maker Strategy 's defined energy_rate. energy_rate_increase_per_update : explicit rate decrease increment in cents. fit_to_limit: derive bidding behaviour from a linear fitted curve of a buying rate between initial_buying_rate and final_buying_rate (boolean value) within the bidding interval. If activated, energy_rate_increase_per_update = (final_buying_rate - initial_buying_rate) / max(int((slot_length / update_interval) -1), 1) In order to enable the load to participate in balancing market, a prerequisite is to add the load device in \" Device Registry \" and set the following parameters: balancing_energy_ratio : tuple with 2 values. The first value dictates the ratio of energy to be demanded in balancing market, i.e. committing to voluntary ramping-up consumption. The second value dictates the ratio of energy to be supplied in balancing market, i.e. committing to voluntary ramping down of consumption (default value: tuple(0.1, 0.1)). The Load will increase its acceptable energy rate linearly in the frame of a market slot of a one-sided market. It will start at the initial_buying_rate and end at final_buying_rate . Corresponding code: src/ 3a/models/strategy/load_hours.py How to add load device to setup-file: Area ( 'Load' , strategy = LoadHoursStrategy ( avg_power_W = 200 , hrs_per_day = 6 , hrs_of_day = list ( range ( 12 , 18 )), initial_buying_rate = 0 , final_buying_rate = 35 ), appliance = SwitchableAppliance ()) Addendum: hrs_of_day and hrs_per_day hrs_of_day defines the allowed time-window in which the load has to consume for a time defined by hrs_per_day . For example, a user can input 5 hrs_per_day , for example and give a wider range for hrs_of_day like (2,18). The 5 programmed hours will be consumed \"greedily\" during this period, meaning that the Load will try to consume as fast as possible if there are any offered energy to purchase within the limits of initial_buying_rate and final_buying_rate set parameters . So if there is sufficient energy with affordable rates, the load will consume in the hours first 5 hours, i.e. from 02:00 until 07:00, with no energy demand being unmatched. In case energy prices would be too high during the time-interval from 04:00 to 16:00, the load will consume from 02:00 until 04:00, turn off, and consume from 16:00 until 18:00, resulting in 1 hour of energy demand being unmatched. For information on buying rate decrease behaviour, please see: Energy Rate Settings and Behaviour . Relation of different parameters for energy pricing \u00b6 Let's assume the user has configured its LoadStrategy with these parameters (initial_buying_rate=0, final_buying_rate=30, fit_to_limit=True, update_interval=5mins) and slot_length=15min . At the start of market, LOAD would place its initial bid at the rate of initial_buying_rate . If fit_to_limit is set to True , it will gradually increase its bid_rate linearly such that its final_bid before the end of market_slot should be equal to final_buying_rate . Number of available updates in such a case is (slot_length / update_interval) -1) \u2192 (15/5 -1)=2 . Therefore, it is possible for a user to update its offer two times inside the same market_slot . The first update would happen at 5mins. The calculated energy_rate_decrease_per_update \u2192 (30 - 0) / 2 \u2192 15 . So, the Load will increase its buying_rate at the 5th min from 0 to 15 cts/kWh and at the 10th min from 15 to 30 cts/kWh.","title":"Load Strategy"},{"location":"load-strategy/#relation-of-different-parameters-for-energy-pricing","text":"Let's assume the user has configured its LoadStrategy with these parameters (initial_buying_rate=0, final_buying_rate=30, fit_to_limit=True, update_interval=5mins) and slot_length=15min . At the start of market, LOAD would place its initial bid at the rate of initial_buying_rate . If fit_to_limit is set to True , it will gradually increase its bid_rate linearly such that its final_bid before the end of market_slot should be equal to final_buying_rate . Number of available updates in such a case is (slot_length / update_interval) -1) \u2192 (15/5 -1)=2 . Therefore, it is possible for a user to update its offer two times inside the same market_slot . The first update would happen at 5mins. The calculated energy_rate_decrease_per_update \u2192 (30 - 0) / 2 \u2192 15 . So, the Load will increase its buying_rate at the 5th min from 0 to 15 cts/kWh and at the 10th min from 15 to 30 cts/kWh.","title":"Relation of different parameters for energy pricing"},{"location":"load/","text":"The following parameters can be set in the Load Strategy: Name: Must be unique. When number of duplicates greater than 1, a number is appended to the individual names. Load profile : The user can choose between two options: User configured profile (in which case a load profile can be uploaded that is compliant with Upload File Formats ) User Upload Profile (in which case the user has to provide the Average Power of the load) Average power: Average power consumed by the load. Hours per day: The number of hours the Load operates per day. Hours of day: The time range in which the load operates. Initial buying rate: Initial energy buying rate at the beginning of each market slot. Final buying rate: Final energy buying rate at the end of each market slot. Rate increase: Explicit rate increase increment Fit to limits: Derive bidding behavior from a linear fitted curve of a buying rate between initial_buying_rate and final_buying_rate within the bidding interval. If activated, energy rate_increase = (final_buying_rate - initial_buying_rate) / max(int((slot_length / update_interval) -1), 1) Update interval: The frequency at which the rate is updated. For further general information about this strategy follow the backend Load Strategy manual. The configuration interface is shown below:","title":"Load"},{"location":"market-maker-strategy/","text":"The Market Maker Strategy mimics the behaviour of a typical energy utility and is used as a reference point. It can work in following modes: grid_connected : In this mode, it has the ability to meet the infinite energy demands of consumers at the most expensive 'energy_rate' that could exist in that grid. islanded : In this mode, it won\u2019t fulfill the energy demands of any consumer but would only be used as a reference point of the highest possible energy_rate that could exist in that grid. Following are the parameters needed for its configuration: energy_rate : It could be a float value OR a time-series value that gives the ability to have different value for every market_slot . grid_connected : If set to True , enables it to work in grid_connected' mode as explained above. OTHERWISE, it would operate in islanded mode. Corresponding code: src/d3a/setup/strategy_tests/market_maker_strategy.py How to add Market Maker to the setup-file: Area('Market Maker', strategy=MarketMakerStrategy(energy_rate=35, grid_connected=True), appliance=SimpleAppliance()),","title":"Market Maker Strategy"},{"location":"market-maker/","text":"The following parameters can be set in the Market Maker. Name: The name of the Market Maker. Mode The user has two options: Infinite power plant: In this mode, it has the ability to meet the infinite energy demands of consumers at the most expansive rate that could exist in that grid. Infinite bus: In this mode, the Market Maker has not only the ability to meet the infinite energy demands of consumer but can also absorb the infinite generation excess of prosumers/producers at the lowest rate the could exist in that grid. Role: The user has two options: Grid connected: In this role, the Market Maker is connected to the grid and thus can fulfill the energy demands of any consumer and absorb the excess of generation (if infinite bus mode selected) Islanded: In this role, it won\u2019t fulfill the energy demands of any consumer but would only be used as a reference point of highest possible energy_rate that could exist in that grid. Selling rate type: The user can choose either User Input to define a fixed rate defined by the Selling rate or to upload their own selling rate profile. Selling rate: The fixed rate the Market Maker will enforce, if User Input is chosen for the selling rate type . Buying rate type (infinite bus only): The user can choose either User Input to define a fixed rate defined by the buying rate or to upload their own buying rate profile. Buying rate (infinite bus only): The fixed rate the Market Maker will enforce, if User Input is chosen for the buying rate type . For further general information about this strategy, follow the backend Market Maker Strategy and Infinite Bus Strategy manual. The configuration interface is shown below:","title":"Market Maker"},{"location":"market-slots-and-ticks/","text":"Spot Market Slots \u00b6 The energy spot market is broken into slots, the default is set to 15 minutes of simulation time. For a one day simulation, 96 market slots would occur with the default setting. See How to launch Simulation via Command Line Interface for how to adjust market slot length. Depending on the market type, bids and asks are either matched within or at the end of each slot. Bids and asks that remain unmatched at the end of a market slot are deleted. Market Ticks \u00b6 Each slot is further incremented into ticks. The default setting for a tick is 15 seconds of simulation time, but is configurable . The default 15 minute market slot is made up of 60 15-second ticks. The real-time length of both market slots and ticks is determined by the configurable simulation time scale (e.g. 1 simulation-time hour = 1 real-time minute) With the API, agents are limited to one update to their bids and asks per tick (60 per market slot). In a pay-as-bid market, the market is cleared at the end of each tick. An order submitted in a tick could be matched at the end of that tick. If the order is not matched, it is propogated to all adjacent markets by the Inter-Area Agent for the next tick. If it is not matched at the end of that tick, it is further propagated to connected markets in the subsequent ticks following the same logic. For example, assume a bid is created in market A in tick t1 . If markets A and D are separated by markets B and C , market D would see an unmatched offer from market A in t4 . If a match is found in market D , the orders would simultaneously clear in both markets at the end of t4 in a pay-as-bid market. In a pay-as-clear market, offers still propagate to adjacent markets each tick. However, clearing happens at the determined clear frequency (default is 3 times per market slot).","title":"Market Slots and Ticks"},{"location":"market-slots-and-ticks/#spot-market-slots","text":"The energy spot market is broken into slots, the default is set to 15 minutes of simulation time. For a one day simulation, 96 market slots would occur with the default setting. See How to launch Simulation via Command Line Interface for how to adjust market slot length. Depending on the market type, bids and asks are either matched within or at the end of each slot. Bids and asks that remain unmatched at the end of a market slot are deleted.","title":"Spot Market Slots"},{"location":"market-slots-and-ticks/#market-ticks","text":"Each slot is further incremented into ticks. The default setting for a tick is 15 seconds of simulation time, but is configurable . The default 15 minute market slot is made up of 60 15-second ticks. The real-time length of both market slots and ticks is determined by the configurable simulation time scale (e.g. 1 simulation-time hour = 1 real-time minute) With the API, agents are limited to one update to their bids and asks per tick (60 per market slot). In a pay-as-bid market, the market is cleared at the end of each tick. An order submitted in a tick could be matched at the end of that tick. If the order is not matched, it is propogated to all adjacent markets by the Inter-Area Agent for the next tick. If it is not matched at the end of that tick, it is further propagated to connected markets in the subsequent ticks following the same logic. For example, assume a bid is created in market A in tick t1 . If markets A and D are separated by markets B and C , market D would see an unmatched offer from market A in t4 . If a match is found in market D , the orders would simultaneously clear in both markets at the end of t4 in a pay-as-bid market. In a pay-as-clear market, offers still propagate to adjacent markets each tick. However, clearing happens at the determined clear frequency (default is 3 times per market slot).","title":"Market Ticks"},{"location":"market-smart-contract/","text":"The market smart contract is used for performing energy transactions, in exactly the same manner as the Market Python class. There are 3 main non-view functions/transactions (functions that actually mutate the state of the blockchain) on the contract: offer() : Places an energy offer to the market. Needs the offered energy and the offer price as arguments. The smart contract generates an offer id and stores the offer in its 'offers' mapping, similar to its Python counterpart. Emits a NewOffer event on success, which will notify the listeners of the contract about the new offer that was created. cancel() : Removes a previously created offer from the market. Needs the offer id in bytes as argument. This function removes the offer id from the 'offers' mapping. Emits a CancelOffer event to notify the listeners about the deleted offer. trade() : Performs an energy trade. Needs the selected offer id and the desired traded energy as arguments. Similar to the accept_offer Python function, it checks whether the selected offer is eligible for this trade and performs the actual trade. In case the desired energy is less than the offer energy, a partial trade is performed and a new residual offer is generated. The listeners get notified for the offer change by an OfferChanged event that gets emitted, which notifies the listeners about the new and the old offer ids, along with the new offer energy and price. On a successful trade, a NewTrade event is also emitted, which notifies the listeners about the trade that was performed. This contract is also responsible for the energy and token balance of the devices registered in it. For the energy balance, it is stored directly on the market contract ('balances' mapping). As for the token balance, a separate smart contract is responsible ( ClearingToken ) which is invoked via an external function during the trade function, in order to update the price/token balances of the buyer and the seller of the trade.","title":"Market Smart Contract"},{"location":"markets/","text":"Status Quo \u00b6 To give a better overview of the interaction of the D3A with the existing electrical grid, we first discuss a typical market structure: The main goal of an electricity market is always to balance the grid in terms of demand and supply. Since massive storage of energy is currently not economically feasible and electrical current varies within seconds, a market structure that efficiently allocates production and consumption is necessary. Generally, trading occurs in three different kind of markets that each have different time intervals: Futures market: futures (long term trades) between consumption and production are agreed upon. This market is currently left outside the scope of D3A implementation. Spot market: typically 15 minutes, agents within the grid are trading through a one-sided pay-as-offer, double-sided pay-as-bid or double-sided pay-as-clear auction. Grid balancing market: imbalances that occur between agreements in the spot market due to changes in consumption and production are absorbed by balance responsible parties that are reimbursed for their service. D3A \u00b6 The current implementation of the D3A focuses on the spot & balancing market. In contrast to the status quo, balancing markets take place in parallel to the spot markets (if enabled). The duration of the markets can be configured. Currently, three spot market types are implemented: One sided pay-as-offer Two sided pay-as-bid Two sided pay-as-clear In the d3a setup file, the spot market type can be defined by the following line (example for one sided pay-as-offer): ConstSettings.IAASettings.MARKET_TYPE = 1 Setting the market type influences the behaviour of both the markets as well as the behaviour of the devices or agents. For individual behaviour of the device strategies please refer to Strategies documentation.","title":"Markets Overview"},{"location":"markets/#status-quo","text":"To give a better overview of the interaction of the D3A with the existing electrical grid, we first discuss a typical market structure: The main goal of an electricity market is always to balance the grid in terms of demand and supply. Since massive storage of energy is currently not economically feasible and electrical current varies within seconds, a market structure that efficiently allocates production and consumption is necessary. Generally, trading occurs in three different kind of markets that each have different time intervals: Futures market: futures (long term trades) between consumption and production are agreed upon. This market is currently left outside the scope of D3A implementation. Spot market: typically 15 minutes, agents within the grid are trading through a one-sided pay-as-offer, double-sided pay-as-bid or double-sided pay-as-clear auction. Grid balancing market: imbalances that occur between agreements in the spot market due to changes in consumption and production are absorbed by balance responsible parties that are reimbursed for their service.","title":"Status Quo"},{"location":"markets/#d3a","text":"The current implementation of the D3A focuses on the spot & balancing market. In contrast to the status quo, balancing markets take place in parallel to the spot markets (if enabled). The duration of the markets can be configured. Currently, three spot market types are implemented: One sided pay-as-offer Two sided pay-as-bid Two sided pay-as-clear In the d3a setup file, the spot market type can be defined by the following line (example for one sided pay-as-offer): ConstSettings.IAASettings.MARKET_TYPE = 1 Setting the market type influences the behaviour of both the markets as well as the behaviour of the devices or agents. For individual behaviour of the device strategies please refer to Strategies documentation.","title":"D3A"},{"location":"one-sided-pay-as-offer/","text":"The market object collects offers and serves the functionality of accepting and deleting offers as well as dispatching these offer events to its listeners (other areas and their markets). The auction is continuous, meaning that once an offer is posted, it can be accepted right away, even before the end of the slot market. Energy producing agents (or \u201csellers\u201d) post offers in the market with an energy price determined by the devices' strategy. Consuming agents (or \u201cbuyers\u201d) can see the offers available in their local market, filter the affordable offers and then select the cheapest offer among them. The energy rate by which the seller and buyer settle is the price of the offer (pay-as-offer). Consequently, the trade rate may be different than other trades settled in the same slot. An Inter-Area Agent is created and operated by each area. Its job is to forward offers to the connected markets. It does not have any strategy allocated to it.","title":"One Sided Pay-As-Offer"},{"location":"percentage-fees/","text":"Configuration Model \u00b6 Introduction and definitions \u00b6 We will use the grid configuration example above to go into detail about how the grid fees in the D3A work. Grid fees can be configured as percentages or as euro cents (constant fees are not yet implemented). Please see how to configure the grid fee here . Fees are configured based on the clearing price of the trade. We have agreed that the buyer should pay all of the fees, at least for this implementation. Any fee that a seller has to pay is ultimately the burden of the buyer. A seller with additional operational costs or taxes will have to raise their prices in a competitive market. The fees are typically configured as percentages or euro cents in order to map the D3A fees in a way similar to the energy fees found on a customer's energy bill in the traditional/legacy electricity system. For example, in Germany the federal network agency charges 24% of the total bill as usage fees. Additional fees are subtracted for: Renewable energy surcharge (21%), Sales Tax (16%), Electricity Tax (7%), Concession levy (5%), Offshore liability levy (1.3%), Surcharge for combined heat and power plants (0.1%) and Levy for industry rebate on grid fees (1%). See Clean Energy Wire for more info. When running D3A simulations, we consider the current grid fees and propose which fees need to be added at which layers in the D3A. Configuring separate grid fees in separate markets or areas helps to accomplish this. The grid fee is a part of the energy trade price and is cumulative so that the fees in each market a trade passes through can be added cumulatively together to get the entire grid fee, often as a percentage of the clearing price. The Clearing Price is the price that the market clears at. The Trade Price is the price the buyer pays (revenue to the seller plus the grid fees). As seen in the examples below, the price of a bid or offer changes as it is propagated into different markets. The price of an offer increases to account for the added fees of the market. This helps an agent submitting an offer to receive equal or greater revenue than the value of the offer. The price of a bid decreases for the same reason. This helps an agent submitting a bid to pay equal or less than the value of the bid. This way, an agent making an offer will never receive less than their offer and an agent making a bid will never pay more than the bid. One Sided Pay as Offer \u00b6 In the One Sided Pay as Offer market, there are no bids and only offers exist. The offers are propagated throughout the markets in the hierarchy. The grid fees are taken into account when an offer is forwarded to the higher market, by the higher market itself. Therefore the agent is not responsible for adapting the offer price to include the grid fees. The grid fees' unit is a ratio of the original offer price, therefore the formula to calculate the new offer price when placing an offer to a market is the following: offer_price_after_fees = offer_price + original_offer_price * grid_fee_ratio If the offer is not purchased after one tick, it is moved into the next market. When entering a new market, the offer's price is increased according that that market's grid fee. The PV offer of \u20ac 0.10 is first placed into the House 2 Market where it gains zero fees. Then it moves into the Neighborhood 2 Market, gaining a fee of 5% of the original offer 0.10*0.05+0.10=0.105 to become \u20ac 0.105. Then if not purchased it moves into the Grid Market, gaining a fee of 10% of the original offer 0.10*0.10+0.105=0.115 to become \u20ac 0.115. Continuing into the Neighborhood 1 Market, the offer gains a fee of 5% 0.10*0.05+0.115=0.12 to become \u20ac 0.12. Continuing into the House 1 Market, the offer gains zero fees. The Load buys the offer in the House 1 Market at the Clearing Price of \u20ac 0.12. From the initial offer price, the total fees are calculated 0.10*(1+0.05+0.10+0.05) to yield the Trade Price of \u20ac 0.12. The Load pays the Trade Price of \u20ac 0.12, which includes \u20ac 0.10 revenue to the PV, \u20ac 0.005 fees to Neighborhood Market 1, \u20ac 0.01 fees to Grid Market, and \u20ac 0.005 fees to Neighborhood Market 2. Since the market is pay-as-offer, the offer prices are used as 'clearing' prices. On each market trade, the grid fee is calculated based on the original offer price (according to the accepted energy to cover partial trades) and subtracted from the offer price, in order to calculate the trade price after fees. However, the trade price includes the grid fees. The following formula is used: market_fees = grid_fee_ratio * original_price * energy_portion trade_price_after_fees = energy * trade_rate - market_fees trade_price = energy * trade_rate Two Sided Pay as Bid \u00b6 In the Two Sided Pay as Bid market, there are both bids and offers, which are both propagated throughout the markets in the hierarchy. If a bid or offer is not purchased after one tick, it is moved into the next market. In order to prevent the double accounting of a market's grid fee when a bid and an offer are matched in that market, market fees are added to offers when they enter that market ( target market ) and market fees are subtracted from bids when they leave that market and enter the another one ( source market ). The formula for propagating the offers is exactly the same as on the one-sided market : offer_price_after_fees = offer_price + original_offer_price * grid_fee_ratio The bids are not adapted by the market itself, but the area/IAA is responsible to subtract the fees from the bid before propagating the bid to the higher market. As mentioned above, the difference in behavior compared to offers is to avoid double accounting of the grid fee on one market. The formula for an area to update the bid to include grid fees is the following: bid_price_after_fees = bid_price - original_bid_price * grid_fee_ratio In the case of the Two Sided Pay as Bid market, the offer has moved into the Grid Market by the same mechanism as explained in the One Sided Pay as Offer market. The bid of \u20ac 0.30 follows a similar mechanism and is placed into the House 1 Market where there are zero fees. If the bid is not purchased after one tick, it is moved into the Neighborhood 1 Market. As explained above, only the fees from the source market are added, which are zero in this case. So the bid remains at \u20ac 0.30. Next the bid moves into the Grid Market, where it its value is lowered according to the fees of its source market, the Neighborhood 1 Market at 5%. With the Neighborhood 1 Market fee, the bid is lowered to 0.30-0.30*0.05=0.285 \u20ac 0.285 as it enters the Grid Market. In the example above, the bid and offer are matched in the Grid Market. However, when the offer entered the Grid Market, its price was immediately updated to account for the Grid Market's fees 0.10*0.10+0.105=0.115 . The bid on the other hand did not add the 10% fee. In the case that the bid was not matched in the Grid Market and moved into the Neighborhood 2 Market, the 10% fee from the Grid Market would be added. In this case the bid would become 0.285-0.30*0.10=0.255 \u20ac 0.255. The fees from the Neighborhood 2 Market would not be added to the bid unless it entered the House 2 Market (fees added according to the source market). In the Grid Market, the Load bid is listed as \u20ac 0.285 and the PV offer is listed as \u20ac 0.115. As the bid is greater than the offer a trade can be scheduled. The trade clears at the bid price, giving a Clearing Price of \u20ac 0.285. There is a separate algorithm that calculates the grid fee according to the clearing price. This allows the markets to act more independently and in a decentralized manner, without having to share information regarding their fees with other markets. In order to calculate the fee correctly based on the original price, the algorithm needs to be able to calculate the supply side and demand side tax. It is easy to calculate this, since the original bid/offer prices are available: demand_side_tax = 1 - (forwarded_bid_rate / original_bid_rate) supply_side_tax = (forwarded_offer_rate / original_offer_rate) - 1 For the example, we have the following values: supply_side_tax=(0.115/0.1)-1=0.15 , demand_side_tax=1-(0.285/0.3)=0.05 . After calculating the supply and demand side tax, we can calculate the revenue of the trade. Note the original_trade_rate is the amount that the original buyer (in our case the Load) will need to pay, therefore for pay as bid this is the original bid price. The calculation is the following: total_tax_ratio = supply_side_tax + demand_side_tax revenue = original_trade_rate / (1 + total_tax_ratio) For the example, the revenue will be: revenue = 0.30/(1+0.15+0.05)=0.25 The grid fees are then calculated based on the revenue and the individual market fees. fees = revenue * grid_fee_ratio For the case of the Grid Market in our example, the fees are 0.25*0.1=0.025 , and for each Neighborhood market, the fees are 0.25*0.05=0.0125 . Finally, the trade rate is adapted according to the supply side tax, in order to include the fees of the current market: trade_rate = revenue * (1 + supply_side_tax) trade_price = energy * trade_rate For our example, the trade price for each market is: Grid Market = 0.25 * (1 + 0.15) = 0.2875 Neighborhood 2 Market = 0.25 * (1 + 0.05) = 0.2625 Neighborhood 1 Market = 0.25 * (1 + 0.2) = 0.3 House 1 Market = 0.25 * (1 + 0.2) = 0.3 House 2 Market = 0.25 * (1 + 0) = 0.25 The Load pays the Trade Price of \u20ac 0.30, which includes \u20ac 0.25 revenue to the PV, \u20ac 0.0125 fees to Neighborhood Market 1, \u20ac 0.025 fees to Grid Market, and \u20ac 0.0125 fees to Neighborhood Market 2. Two Sided Pay as Clear \u00b6 In construction...","title":"Percentage fees"},{"location":"percentage-fees/#configuration-model","text":"","title":"Configuration Model"},{"location":"percentage-fees/#introduction-and-definitions","text":"We will use the grid configuration example above to go into detail about how the grid fees in the D3A work. Grid fees can be configured as percentages or as euro cents (constant fees are not yet implemented). Please see how to configure the grid fee here . Fees are configured based on the clearing price of the trade. We have agreed that the buyer should pay all of the fees, at least for this implementation. Any fee that a seller has to pay is ultimately the burden of the buyer. A seller with additional operational costs or taxes will have to raise their prices in a competitive market. The fees are typically configured as percentages or euro cents in order to map the D3A fees in a way similar to the energy fees found on a customer's energy bill in the traditional/legacy electricity system. For example, in Germany the federal network agency charges 24% of the total bill as usage fees. Additional fees are subtracted for: Renewable energy surcharge (21%), Sales Tax (16%), Electricity Tax (7%), Concession levy (5%), Offshore liability levy (1.3%), Surcharge for combined heat and power plants (0.1%) and Levy for industry rebate on grid fees (1%). See Clean Energy Wire for more info. When running D3A simulations, we consider the current grid fees and propose which fees need to be added at which layers in the D3A. Configuring separate grid fees in separate markets or areas helps to accomplish this. The grid fee is a part of the energy trade price and is cumulative so that the fees in each market a trade passes through can be added cumulatively together to get the entire grid fee, often as a percentage of the clearing price. The Clearing Price is the price that the market clears at. The Trade Price is the price the buyer pays (revenue to the seller plus the grid fees). As seen in the examples below, the price of a bid or offer changes as it is propagated into different markets. The price of an offer increases to account for the added fees of the market. This helps an agent submitting an offer to receive equal or greater revenue than the value of the offer. The price of a bid decreases for the same reason. This helps an agent submitting a bid to pay equal or less than the value of the bid. This way, an agent making an offer will never receive less than their offer and an agent making a bid will never pay more than the bid.","title":"Introduction and definitions"},{"location":"percentage-fees/#one-sided-pay-as-offer","text":"In the One Sided Pay as Offer market, there are no bids and only offers exist. The offers are propagated throughout the markets in the hierarchy. The grid fees are taken into account when an offer is forwarded to the higher market, by the higher market itself. Therefore the agent is not responsible for adapting the offer price to include the grid fees. The grid fees' unit is a ratio of the original offer price, therefore the formula to calculate the new offer price when placing an offer to a market is the following: offer_price_after_fees = offer_price + original_offer_price * grid_fee_ratio If the offer is not purchased after one tick, it is moved into the next market. When entering a new market, the offer's price is increased according that that market's grid fee. The PV offer of \u20ac 0.10 is first placed into the House 2 Market where it gains zero fees. Then it moves into the Neighborhood 2 Market, gaining a fee of 5% of the original offer 0.10*0.05+0.10=0.105 to become \u20ac 0.105. Then if not purchased it moves into the Grid Market, gaining a fee of 10% of the original offer 0.10*0.10+0.105=0.115 to become \u20ac 0.115. Continuing into the Neighborhood 1 Market, the offer gains a fee of 5% 0.10*0.05+0.115=0.12 to become \u20ac 0.12. Continuing into the House 1 Market, the offer gains zero fees. The Load buys the offer in the House 1 Market at the Clearing Price of \u20ac 0.12. From the initial offer price, the total fees are calculated 0.10*(1+0.05+0.10+0.05) to yield the Trade Price of \u20ac 0.12. The Load pays the Trade Price of \u20ac 0.12, which includes \u20ac 0.10 revenue to the PV, \u20ac 0.005 fees to Neighborhood Market 1, \u20ac 0.01 fees to Grid Market, and \u20ac 0.005 fees to Neighborhood Market 2. Since the market is pay-as-offer, the offer prices are used as 'clearing' prices. On each market trade, the grid fee is calculated based on the original offer price (according to the accepted energy to cover partial trades) and subtracted from the offer price, in order to calculate the trade price after fees. However, the trade price includes the grid fees. The following formula is used: market_fees = grid_fee_ratio * original_price * energy_portion trade_price_after_fees = energy * trade_rate - market_fees trade_price = energy * trade_rate","title":"One Sided Pay as Offer"},{"location":"percentage-fees/#two-sided-pay-as-bid","text":"In the Two Sided Pay as Bid market, there are both bids and offers, which are both propagated throughout the markets in the hierarchy. If a bid or offer is not purchased after one tick, it is moved into the next market. In order to prevent the double accounting of a market's grid fee when a bid and an offer are matched in that market, market fees are added to offers when they enter that market ( target market ) and market fees are subtracted from bids when they leave that market and enter the another one ( source market ). The formula for propagating the offers is exactly the same as on the one-sided market : offer_price_after_fees = offer_price + original_offer_price * grid_fee_ratio The bids are not adapted by the market itself, but the area/IAA is responsible to subtract the fees from the bid before propagating the bid to the higher market. As mentioned above, the difference in behavior compared to offers is to avoid double accounting of the grid fee on one market. The formula for an area to update the bid to include grid fees is the following: bid_price_after_fees = bid_price - original_bid_price * grid_fee_ratio In the case of the Two Sided Pay as Bid market, the offer has moved into the Grid Market by the same mechanism as explained in the One Sided Pay as Offer market. The bid of \u20ac 0.30 follows a similar mechanism and is placed into the House 1 Market where there are zero fees. If the bid is not purchased after one tick, it is moved into the Neighborhood 1 Market. As explained above, only the fees from the source market are added, which are zero in this case. So the bid remains at \u20ac 0.30. Next the bid moves into the Grid Market, where it its value is lowered according to the fees of its source market, the Neighborhood 1 Market at 5%. With the Neighborhood 1 Market fee, the bid is lowered to 0.30-0.30*0.05=0.285 \u20ac 0.285 as it enters the Grid Market. In the example above, the bid and offer are matched in the Grid Market. However, when the offer entered the Grid Market, its price was immediately updated to account for the Grid Market's fees 0.10*0.10+0.105=0.115 . The bid on the other hand did not add the 10% fee. In the case that the bid was not matched in the Grid Market and moved into the Neighborhood 2 Market, the 10% fee from the Grid Market would be added. In this case the bid would become 0.285-0.30*0.10=0.255 \u20ac 0.255. The fees from the Neighborhood 2 Market would not be added to the bid unless it entered the House 2 Market (fees added according to the source market). In the Grid Market, the Load bid is listed as \u20ac 0.285 and the PV offer is listed as \u20ac 0.115. As the bid is greater than the offer a trade can be scheduled. The trade clears at the bid price, giving a Clearing Price of \u20ac 0.285. There is a separate algorithm that calculates the grid fee according to the clearing price. This allows the markets to act more independently and in a decentralized manner, without having to share information regarding their fees with other markets. In order to calculate the fee correctly based on the original price, the algorithm needs to be able to calculate the supply side and demand side tax. It is easy to calculate this, since the original bid/offer prices are available: demand_side_tax = 1 - (forwarded_bid_rate / original_bid_rate) supply_side_tax = (forwarded_offer_rate / original_offer_rate) - 1 For the example, we have the following values: supply_side_tax=(0.115/0.1)-1=0.15 , demand_side_tax=1-(0.285/0.3)=0.05 . After calculating the supply and demand side tax, we can calculate the revenue of the trade. Note the original_trade_rate is the amount that the original buyer (in our case the Load) will need to pay, therefore for pay as bid this is the original bid price. The calculation is the following: total_tax_ratio = supply_side_tax + demand_side_tax revenue = original_trade_rate / (1 + total_tax_ratio) For the example, the revenue will be: revenue = 0.30/(1+0.15+0.05)=0.25 The grid fees are then calculated based on the revenue and the individual market fees. fees = revenue * grid_fee_ratio For the case of the Grid Market in our example, the fees are 0.25*0.1=0.025 , and for each Neighborhood market, the fees are 0.25*0.05=0.0125 . Finally, the trade rate is adapted according to the supply side tax, in order to include the fees of the current market: trade_rate = revenue * (1 + supply_side_tax) trade_price = energy * trade_rate For our example, the trade price for each market is: Grid Market = 0.25 * (1 + 0.15) = 0.2875 Neighborhood 2 Market = 0.25 * (1 + 0.05) = 0.2625 Neighborhood 1 Market = 0.25 * (1 + 0.2) = 0.3 House 1 Market = 0.25 * (1 + 0.2) = 0.3 House 2 Market = 0.25 * (1 + 0) = 0.25 The Load pays the Trade Price of \u20ac 0.30, which includes \u20ac 0.25 revenue to the PV, \u20ac 0.0125 fees to Neighborhood Market 1, \u20ac 0.025 fees to Grid Market, and \u20ac 0.0125 fees to Neighborhood Market 2.","title":"Two Sided Pay as Bid"},{"location":"percentage-fees/#two-sided-pay-as-clear","text":"In construction...","title":"Two Sided Pay as Clear"},{"location":"power-plant/","text":"The following parameters can be set in the Power Plant Strategy. Name: Must be unique. When number of duplicates greater than 1, a number is appended to the individual names. Energy rate: Selling price of the power plant. Maximum available power: Maximum power that the power plant can supply. For further general information about this strategy, follow the backend Finite Power Plant Strategy manual. The configuration interface is shown below:","title":"Power Plant"},{"location":"projects-home-page/","text":"After logging in, the user lands on the home page. It shows an overview of all projects and configurations. Projects can be either private or public. Projects can be set up as separate use cases or grid locations in order to keep versions organized in one project folder. Within a project, the user can make several versions by creating duplicates of simulations and thus iteratively optimizing a particular grid configuration or use case. Public projects will appear on the user's home page. The simulations in these projects can be viewed by the user as examples and also duplicated to a new project made by the user. As a duplicated simulation in a user's own project, the user can edit the simulation. Projects \u00b6 Projects can be used to group simulations. They can be seen as folders in which simulations are located. Before creating a simulation, a project has to be created by selecting the New Project button: The following symbol notifies the user that a project is public : Simulations \u00b6 To create a new simulation, select the New Simulation button shown below. The user will then be redirected to the General Settings . The following quick links are available for each simulation: Redirects the user to the Results Page . On this latter the user can launch the simulation, pause it and abort it. Edit the General Settings of the simulation Model the grid setup of the simulation Duplicate the configuration, download the results or delete the simulation Search \u00b6 Projects and simulation can be filtered by name, using this search field found on the upper right: Compare \u00b6 The user can compare 2 simulations results side by side by clicking on the compare icon:","title":"Projects (Home Page)"},{"location":"projects-home-page/#projects","text":"Projects can be used to group simulations. They can be seen as folders in which simulations are located. Before creating a simulation, a project has to be created by selecting the New Project button: The following symbol notifies the user that a project is public :","title":"Projects"},{"location":"projects-home-page/#simulations","text":"To create a new simulation, select the New Simulation button shown below. The user will then be redirected to the General Settings . The following quick links are available for each simulation: Redirects the user to the Results Page . On this latter the user can launch the simulation, pause it and abort it. Edit the General Settings of the simulation Model the grid setup of the simulation Duplicate the configuration, download the results or delete the simulation","title":"Simulations"},{"location":"projects-home-page/#search","text":"Projects and simulation can be filtered by name, using this search field found on the upper right:","title":"Search"},{"location":"projects-home-page/#compare","text":"The user can compare 2 simulations results side by side by clicking on the compare icon:","title":"Compare"},{"location":"pv-strategy/","text":"The PV strategy determines the price of the PV offers on the spot market. It also determines what to do when its offer is not immediately accepted by a buyer. Initial parameters that can be defined include: panel_count : The number of panels in the simulation max_panel_power_W : Peak power rating per panel update_interval : time after which the rate should be updated (type: pendulum duration object). Range[1:(slot_length_minute-1)] final_selling_rate : The minimum offer rate (ct/kWh) initial_selling_rate : The maximum offer rate (ct/kWh) use_market_maker_rate : If this flag is set True , then agent's initial_selling_rate would be overwritten with Market Maker Strategy 's defined energy_rate energy_rate_decrease_per_update : It is configured as the cents/kWh decrease per update. fit_to_limit : derive bidding behaviour from a linear fitted curve of a buying rate between initial_selling_rate and final_selling_rate (boolean value) within the bidding interval. If activated, energy_rate_decrease_per_update = (initial_selling_rate - final_selling_rate) / max(int((slot_length / update_interval) -1), 1) . For information buying rate decrease behaviour, please see: Energy Rate Settings and Behaviour . The PV profile can be configured as a saved profile here (via choosing the PVPredefinedStrategy ): cloud_coverage : (0: sunny; 1: partially cloudy; 2: cloudy). Using this parameter, the simulation allows the user to choose between three solar curves that are stored in the simulation for convenience. No default value for this parameter. Corresponding code: src/d3a/models/strategy/pv.py or for the predefined PV: src/d3a/models/strategy/predefined_pv.py How to add a PV device to the setup-file: Area('H2 PV', strategy=PVStrategy(panel_count=4, initial_selling_rate=30, final_selling_rate=5, fit_to_limit=True, update_interval=duration(minutes=5)), appliance=PVAppliance()), In order to understand how the strategy is actually decreasing its offered_rate in the case of not getting traded, see the following diagram. Relation of different parameters for energy pricing \u00b6 Lets assume the user has configured its PVStrategy with these parameters (initial_selling_rate=30, final_selling_rate=0, fit_to_limit=True, update_interval=5mins) and slot_length=15min At the start of market, PV would place its initial offer at the rate of initial_selling_rate . If fit_to_limit is set to True , it will reduce its offer_rate linearly such that its final_offer before the end of market_slot should be equal to final_selling_rate . Number of available updates in such a case is (slot_length / update_interval) -1) \u2192 (15/5 -1)=2 . Therefore, it is possible for a user to update its offer two times inside the same market_slot . The first update would happen at 5mins. The calculated energy_rate_decrease_per_update \u2192 (30 - 0) / 2 \u2192 15 . So, the PV will reduce it selling_rate at 5th min from 30 to 15 cts/kWh and at 10th min from 15 to 0 cts/kWh.","title":"PV Strategy"},{"location":"pv-strategy/#relation-of-different-parameters-for-energy-pricing","text":"Lets assume the user has configured its PVStrategy with these parameters (initial_selling_rate=30, final_selling_rate=0, fit_to_limit=True, update_interval=5mins) and slot_length=15min At the start of market, PV would place its initial offer at the rate of initial_selling_rate . If fit_to_limit is set to True , it will reduce its offer_rate linearly such that its final_offer before the end of market_slot should be equal to final_selling_rate . Number of available updates in such a case is (slot_length / update_interval) -1) \u2192 (15/5 -1)=2 . Therefore, it is possible for a user to update its offer two times inside the same market_slot . The first update would happen at 5mins. The calculated energy_rate_decrease_per_update \u2192 (30 - 0) / 2 \u2192 15 . So, the PV will reduce it selling_rate at 5th min from 30 to 15 cts/kWh and at 10th min from 15 to 0 cts/kWh.","title":"Relation of different parameters for energy pricing"},{"location":"pv/","text":"The following parameters can be configured in the PV Strategy: Name: Must be unique. When number of duplicates greater than 1, a number is appended to the individual names. Panel count: How many PV panels should be attached, each panel creates a power of 250W. Solar Profile: The user can choose between multiple solar profiles ( sunny, partially cloudy or cloudy ). If the user wants to use a different power output per panel, they can create a Gaussian curve or upload their own generation profile. Initial selling rate: Initial energy rate that the PV offers at the beginning of each market slot. The initial selling rate is defined and frozen by the marker maker rate. Final selling rate: Final energy rate that the PV offers at the end of each market slot. Rate decrease: Explicit rate decrease increment. Fit to limits: Derive bidding behavior from a linear fitted curve of a selling rate between initial_selling_rate and final_selling_rate within the bidding interval. If activated, energy_rate_decrease_per_update = (initial_selling_rate - final_selling_rate) / max(int((slot_length / update_interval) -1), 1) Update interval: The frequency at which the rate is updated. For further general information about this strategy, follow the backend PV Strategy manual. The configuration interface is shown below:","title":"PV"},{"location":"results/","text":"Navigating your configuration grid \u00b6 The D3A allows energy resources to trade inside energy markets. During trading, the user can view what is happening at the energy resource level and at the market level. Since a D3A grid is build up into a hierarchy of multiple markets, we use a folder structure to navigate through the grid simulation results. The user can select a market , which brings the user to the result page of this specific market; or, you can select an energy resource (located inside a market) to bring the user to the results page of this specific energy resource. In the above figure, the community market is selected. Simulation Results \u00b6 When selecting a market, the results page will show you various relevant plots and tables. You also have the possibility to select which one you want to view/hide (by default all of them are visible). This section will discuss each of these results. Energy Availability \u00b6 This plot shows whether or not each energy resource inside the selected market had access to the energy it needed. On the x-axis, the time is given. If the participating agent was able to get the energy it wants, at a certain time, the block at that time will appear green. If not, it will appear purple. The granularity of the plot is 1 hour, so if there has been a trade interval (possibly <1 hour length) within the hour in which the agent was not able to buy the demanded energy, the whole block will turn purple. The user can hover over a purple block to see a list of the energy resources not able to buy for that time slot. Self sufficiency and consumption \u00b6 These 2 pie charts shows the Self Sufficiency and Self Consumption of the selected area. Please see Key Performance Indicators for more information. Cumulative trading \u00b6 This plot shows the total trade volumes that have been traded between market participants in the selected market over the simulation's duration. Market participants are the agents (representing an energy resource or an area) immediately inside the selected market. Each bar has its own color to represent its sold energy. Energy sold is negative and energy bought is positive. In this example, the energy sold by House 1 is purple. House 1 also has a positive purple bar, meaning that it bought some of its own energy production. The rest of its energy production was sold as the thin purple layer shown in the bar of the other market participants. By using this color coding, the user can visually track how energy has flowed in a specific market. The external trades represent energy produced in this market, but sold to an outside market (the positive bar layers containing the colors of each participant) and the energy bought from an external source and sold to a participant in this market. The energy bought externally is teal in this example and is the negative bar for External Trades. This energy was sold to the other participants where a positive teal colored bar can be seen (all participants). Energy bills and net energy \u00b6 The energy bills provide information on the cumulative trade volumes of all market participants and the costs associated with these trades. For each agent, including the external trades, the energy bought and sold during the simulation is listed, along with a total net consumption. The Totals column can be considered as the net energy consumption and final bill to the listed agent, which may represent an energy resource or an area of ownership. External Trades represents the import/export from/to a higher level market by the inter-area agent of the selected market, and hence represents the difference between energy traded inside the community and the total accumulated trades. The Totals row represents the total of trades that are made by the agents inside the selected area. In this example, we have the Community market selected. In the Community market, the participating agents are the inter-area agents of the houses that lie inside of the community area. Energy trade profile \u00b6 The energy profile shows both the demand-side as supply-side of the trades made inside the selected market for every market interval of the simulation. The negative side of the y-axis represents the energy sold, and the positive y-axis shows the energy bought. The different colors represent the different agents. As all buyers and sellers of each trade are accounted for in a select market, the supply and demand sides should be exact mirrors of each other in terms of volume. If peak analysis is switched on the external trades are hidden and only the demand and supply of the current area's agents remain. On this plot 2 lines are shown : the current peak imports and the current peak exports which represent the maximum energy imported and exported for the selected area (here the Community ). Detailed energy trade profile \u00b6 This graph is a high resolution energy trade profile. With this graph the user can select a specific market slot in order to see precisely when each trade was cleared during that slot, with a resolution of 1 minute. The graph's length is the market slot length (15 minutes by default). Every market slot of the simulation can be selected with the drop down (for the date) and the slider (for the time). Energy pricing \u00b6 In this plot, energy pricing is shown. In case of multiple clearing moments within a market interval (depending on market design and grid configuration), there could be different prices for different trades in the market interval. In this case, an average of the trade price is shown. In addition, the minimum and maximum price on that time of the day for all days of simulation is provided. If there was no trade happening during a certain market interval, the price is set to zero at that time. Bids, Offers, and Trades per Market Slot \u00b6 In this plot every bids, offers and trades posted in the selected market is shown according to their posting time. With this graph the user can understand why specific offers/bids were matched or not and thus adapt their trading strategy. The range of this graph is the market slot length (15 minutes by default). Every market slot of the simulation can be selected with the drop down (days) and the slider (hours & minutes). Compare results \u00b6 The user has the possibility to compare the results to another simulation (in order to compare results, the simulation should already have been run). The user can also download the results using the interface shown below: Settings \u00b6 The user have the possibility to duplicate the setup, download the results of their simulation or delete the configuration:","title":"Results"},{"location":"results/#navigating-your-configuration-grid","text":"The D3A allows energy resources to trade inside energy markets. During trading, the user can view what is happening at the energy resource level and at the market level. Since a D3A grid is build up into a hierarchy of multiple markets, we use a folder structure to navigate through the grid simulation results. The user can select a market , which brings the user to the result page of this specific market; or, you can select an energy resource (located inside a market) to bring the user to the results page of this specific energy resource. In the above figure, the community market is selected.","title":"Navigating your configuration grid"},{"location":"results/#simulation-results","text":"When selecting a market, the results page will show you various relevant plots and tables. You also have the possibility to select which one you want to view/hide (by default all of them are visible). This section will discuss each of these results.","title":"Simulation Results"},{"location":"results/#energy-availability","text":"This plot shows whether or not each energy resource inside the selected market had access to the energy it needed. On the x-axis, the time is given. If the participating agent was able to get the energy it wants, at a certain time, the block at that time will appear green. If not, it will appear purple. The granularity of the plot is 1 hour, so if there has been a trade interval (possibly <1 hour length) within the hour in which the agent was not able to buy the demanded energy, the whole block will turn purple. The user can hover over a purple block to see a list of the energy resources not able to buy for that time slot.","title":"Energy Availability"},{"location":"results/#self-sufficiency-and-consumption","text":"These 2 pie charts shows the Self Sufficiency and Self Consumption of the selected area. Please see Key Performance Indicators for more information.","title":"Self sufficiency and consumption"},{"location":"results/#cumulative-trading","text":"This plot shows the total trade volumes that have been traded between market participants in the selected market over the simulation's duration. Market participants are the agents (representing an energy resource or an area) immediately inside the selected market. Each bar has its own color to represent its sold energy. Energy sold is negative and energy bought is positive. In this example, the energy sold by House 1 is purple. House 1 also has a positive purple bar, meaning that it bought some of its own energy production. The rest of its energy production was sold as the thin purple layer shown in the bar of the other market participants. By using this color coding, the user can visually track how energy has flowed in a specific market. The external trades represent energy produced in this market, but sold to an outside market (the positive bar layers containing the colors of each participant) and the energy bought from an external source and sold to a participant in this market. The energy bought externally is teal in this example and is the negative bar for External Trades. This energy was sold to the other participants where a positive teal colored bar can be seen (all participants).","title":"Cumulative trading"},{"location":"results/#energy-bills-and-net-energy","text":"The energy bills provide information on the cumulative trade volumes of all market participants and the costs associated with these trades. For each agent, including the external trades, the energy bought and sold during the simulation is listed, along with a total net consumption. The Totals column can be considered as the net energy consumption and final bill to the listed agent, which may represent an energy resource or an area of ownership. External Trades represents the import/export from/to a higher level market by the inter-area agent of the selected market, and hence represents the difference between energy traded inside the community and the total accumulated trades. The Totals row represents the total of trades that are made by the agents inside the selected area. In this example, we have the Community market selected. In the Community market, the participating agents are the inter-area agents of the houses that lie inside of the community area.","title":"Energy bills and net energy"},{"location":"results/#energy-trade-profile","text":"The energy profile shows both the demand-side as supply-side of the trades made inside the selected market for every market interval of the simulation. The negative side of the y-axis represents the energy sold, and the positive y-axis shows the energy bought. The different colors represent the different agents. As all buyers and sellers of each trade are accounted for in a select market, the supply and demand sides should be exact mirrors of each other in terms of volume. If peak analysis is switched on the external trades are hidden and only the demand and supply of the current area's agents remain. On this plot 2 lines are shown : the current peak imports and the current peak exports which represent the maximum energy imported and exported for the selected area (here the Community ).","title":"Energy trade profile"},{"location":"results/#detailed-energy-trade-profile","text":"This graph is a high resolution energy trade profile. With this graph the user can select a specific market slot in order to see precisely when each trade was cleared during that slot, with a resolution of 1 minute. The graph's length is the market slot length (15 minutes by default). Every market slot of the simulation can be selected with the drop down (for the date) and the slider (for the time).","title":"Detailed energy trade profile"},{"location":"results/#energy-pricing","text":"In this plot, energy pricing is shown. In case of multiple clearing moments within a market interval (depending on market design and grid configuration), there could be different prices for different trades in the market interval. In this case, an average of the trade price is shown. In addition, the minimum and maximum price on that time of the day for all days of simulation is provided. If there was no trade happening during a certain market interval, the price is set to zero at that time.","title":"Energy pricing"},{"location":"results/#bids-offers-and-trades-per-market-slot","text":"In this plot every bids, offers and trades posted in the selected market is shown according to their posting time. With this graph the user can understand why specific offers/bids were matched or not and thus adapt their trading strategy. The range of this graph is the market slot length (15 minutes by default). Every market slot of the simulation can be selected with the drop down (days) and the slider (hours & minutes).","title":"Bids, Offers, and Trades per Market Slot"},{"location":"results/#compare-results","text":"The user has the possibility to compare the results to another simulation (in order to compare results, the simulation should already have been run). The user can also download the results using the interface shown below:","title":"Compare results"},{"location":"results/#settings","text":"The user have the possibility to duplicate the setup, download the results of their simulation or delete the configuration:","title":"Settings"},{"location":"run-d3a-on-tobalaba/","text":"Following are the prequisite to run D3A on tobalaba: Please install Parity client . Open your terminal and launch the tobalaba node with: parity --chain tobalaba --jsonrpc-apis=all --jsonrpc-cors=all Goto /Users/<user>/Library/Application Support/io.parity.ethereum/keys and overwrite Tobalaba.zip after unzipping it (PS: Do backup your already existing keys, if you need them later). Launch the simulation on tobalaba via cli: d3a -l INFO run -t 15s -s 60m -m 1 --enable-bc --setup tobalaba.<setup_file_name>","title":"Steps to Run D3A on Tobalaba"},{"location":"simulation-configuration/","text":"To start building a simulation, the user is guided through the simulation configuration pages. These pages allow a user to model their use-case and D3A market structure that the energy resources in their model will use to trade energy. The simulation configuration consists of two steps: General Settings , where general simulation parameters can be set. Grid setup , where the user can build the grid configuration for their use-case.","title":"Simulation Configuration Overview"},{"location":"simulation-events/","text":"Simulation events are changes in the configuration/setup that take place during normal execution of a simulation. They have to be defined by the user in the setup files before the start of the simulation, and they are associated with a specific point in time (or duration), at which point the event is triggered. An event has to be associated with an area, thus there is a new constructor parameter on the area, namely ' event_list ', that accepts a list of events for this specific area. There are 4 different event types: Add/Remove area event Connect/Disconnect area event Strategy events Config events Each is described in detail below. Add/Remove area event \u00b6 This event is associated with an area, and dictates that this area (and its children) will be added or removed from the grid at a specific point in time. There are 2 ways to configure this behaviour, either via individual events ( EnableAreaEvent and DisableAreaEvent ) or to configure this area to be disabled for a time interval ( DisableIntervalAreaEvent ). EnableAreaEvent / DisableAreaEvent accept only one argument, which is the hour that this event is triggered (hourly resolution is supported in events for now, minute resolution is under consideration if we see the need for it), and this area will be enabled/disabled at this specific point in time no matter its current state. DisableIntervalAreaEvent on the other hand, accepts 2 arguments, which denote the start hour and the end hour that the area is disabled. The term 'disabled area' means that the area and all the areas under it are not performing any trading, meaning that the entire sub-tree based on this area is taken off the simulation for the time that the area is disabled. Once the area is enabled, the sub-tree will continue to operate. It is designed this way in order to simulate areas being added or removed from the grid, since it is easier to configure and much more optimal for the UI and D3A to have one configuration scenario with parts of it being disabled at certain points in time, instead of creating new areas during the simulation. You can find examples for these events on github: EnableAreaEvent : isolated_enable_event.py DisableAreaEvent : isolated_disable_event.py DisableIntervalAreaEvent : disable_interval_event.py Connect/Disconnect area event \u00b6 These events are similar to the enable/disable event, both event types have a similar API and both are used for removing an area from the grid. The difference between the 2 is that the Connect/Disconnect events are decoupling their children from the main grid, meaning that during the time that the event is enabled, there are going to be 2 independent grids both trading energy internally, but not trading energy to each other. This is contrary to enable/disable event, where the sub-tree is not performing any trades at all. This is useful to showcase examples from grids that are abruptly decoupled from the main grid, but manage to self-sustain their devices by continuing to trade energy even after they are disconnected from the main grid. You can find examples for these events on github: ConnectAreaEvent : isolated_connect_event.py DisconnectAreaEvent : isolated_disconnect_event.py DisconnectIntervalAreaEvent : disconnect_interval_event.py Strategy events \u00b6 These events are used to change the parameters of the strategy of an area during the simulation runtime. They are applicable for all types of strategies (Load, Storage and PV) and are able to modify different parameters according to the target strategy. These are distinct events and no interval event is provided for strategy events. Load StrategyEvent : load_event.py PV StrategyEvent : pv_event.py Storage StrategyEvent : storage_event.py Config events \u00b6 These events are used to change the config of an area during runtime. This event is also applied to all children of this area, meaning that if a config parameter is changed on one area, the same config parameter will be changed for its children, but not for its parents. A useful application for this is to be able to set different weather conditions for a subset of the grid. The config parameters that are available as events are cloud coverage and the PV user profile (for now, if there is a need to modify other config parameters during the simulation these will be added). Furthermore, config events are distinct and no interval event is provided. Cloud Coverage Event : cloud_coverage_event.py","title":"Simulation Events"},{"location":"simulation-events/#addremove-area-event","text":"This event is associated with an area, and dictates that this area (and its children) will be added or removed from the grid at a specific point in time. There are 2 ways to configure this behaviour, either via individual events ( EnableAreaEvent and DisableAreaEvent ) or to configure this area to be disabled for a time interval ( DisableIntervalAreaEvent ). EnableAreaEvent / DisableAreaEvent accept only one argument, which is the hour that this event is triggered (hourly resolution is supported in events for now, minute resolution is under consideration if we see the need for it), and this area will be enabled/disabled at this specific point in time no matter its current state. DisableIntervalAreaEvent on the other hand, accepts 2 arguments, which denote the start hour and the end hour that the area is disabled. The term 'disabled area' means that the area and all the areas under it are not performing any trading, meaning that the entire sub-tree based on this area is taken off the simulation for the time that the area is disabled. Once the area is enabled, the sub-tree will continue to operate. It is designed this way in order to simulate areas being added or removed from the grid, since it is easier to configure and much more optimal for the UI and D3A to have one configuration scenario with parts of it being disabled at certain points in time, instead of creating new areas during the simulation. You can find examples for these events on github: EnableAreaEvent : isolated_enable_event.py DisableAreaEvent : isolated_disable_event.py DisableIntervalAreaEvent : disable_interval_event.py","title":"Add/Remove area event"},{"location":"simulation-events/#connectdisconnect-area-event","text":"These events are similar to the enable/disable event, both event types have a similar API and both are used for removing an area from the grid. The difference between the 2 is that the Connect/Disconnect events are decoupling their children from the main grid, meaning that during the time that the event is enabled, there are going to be 2 independent grids both trading energy internally, but not trading energy to each other. This is contrary to enable/disable event, where the sub-tree is not performing any trades at all. This is useful to showcase examples from grids that are abruptly decoupled from the main grid, but manage to self-sustain their devices by continuing to trade energy even after they are disconnected from the main grid. You can find examples for these events on github: ConnectAreaEvent : isolated_connect_event.py DisconnectAreaEvent : isolated_disconnect_event.py DisconnectIntervalAreaEvent : disconnect_interval_event.py","title":"Connect/Disconnect area event"},{"location":"simulation-events/#strategy-events","text":"These events are used to change the parameters of the strategy of an area during the simulation runtime. They are applicable for all types of strategies (Load, Storage and PV) and are able to modify different parameters according to the target strategy. These are distinct events and no interval event is provided for strategy events. Load StrategyEvent : load_event.py PV StrategyEvent : pv_event.py Storage StrategyEvent : storage_event.py","title":"Strategy events"},{"location":"simulation-events/#config-events","text":"These events are used to change the config of an area during runtime. This event is also applied to all children of this area, meaning that if a config parameter is changed on one area, the same config parameter will be changed for its children, but not for its parents. A useful application for this is to be able to set different weather conditions for a subset of the grid. The config parameters that are available as events are cloud coverage and the PV user profile (for now, if there is a need to modify other config parameters during the simulation these will be added). Furthermore, config events are distinct and no interval event is provided. Cloud Coverage Event : cloud_coverage_event.py","title":"Config events"},{"location":"simulation-results/","text":"After a successful simulation run, in order to draw some conclusions over the simulation, D3A has the ability to export the simulation results. This functionality is enabled by default. If you want to disable the export of simulation results, use the --no-export flag for the simulation run. Another useful parameter is: --export-path . It changes the output path of the simulation results. The default path is $HOME/d3a-simulation/ . The simulation results include analytical information about the trades, offers, bids and balancing offers that took place in the course of the simulation. Also information about energy characteristics of each device and area agent are included (eg. battery SOC, energy traded/requested/deficit for the agents). In addition to text files, some graphs that display aggregated area information during the course of the simulation are also exposed. These can be found under 'plot' directory.","title":"Simulation Results Overview"},{"location":"storage/","text":"The following parameters can be set in the Energy Storage Strategy (ESS): Name: Must be unique. When number of duplicates greater than 1, a number is appended to the individual names. Battery capacity: Total energy capacity. Initial capacity: Can be set in two ways: Initial state of charge (in %) Initial Energy (in kWh) Minimum state of charge: Minimum energy to leave in the storage. Max power rating for battery: Power limit for each market slot for sold and bought energy. Initial selling rate: Initial energy rate for selling energy at the beginning of each market slot. Final selling rate: Final energy rate for selling energy at the end of each market slot. Rate decrease: Explicit rate decrease increment. Initial buying rate: Initial energy rate for buying energy at the beginning of each market slot. Final buying rate: Final energy rate for buying energy at the end of each market slot. Rate increase: Explicit rate increase increment. Fit to limits: Derive bidding behavior from a linear fitted curve of a buying rate between initial_buying_rate and final_buying_rate and a selling rate between initial_selling_rate and final_selling_rate within the bidding interval. If activated: energy_rate_increase = (final_buying_rate - initial_buying_rate) / max(int((slot_length / update_interval) -1), 1) energy_rate_decrease_per_update = (initial_selling_rate - final_selling_rate) / max(int((slot_length / update_interval) -1), 1) Update interval: The frequency at which the rate is updated. Capacity based method: The ESS can trade energy based on a capacity dependent sell price. For further general information about this strategy, follow the backend Energy Storage System (ESS) Strategy manual. The configuration interface is shown below:","title":"Storage"},{"location":"two-sided-pay-as-bid/","text":"In the two-sided market, buyers are able to place bids in the market, alongside the offers placed by sellers (as seen in the one-sided market). The market collects offers and bids and serves the functionality of accepting and deleting offers and bids as well as dispatching these offer and bids to other markets via the Inter-Area Agent . The auction is continuous, meaning that once an offer or bid is posted, it can be matched right away, even before the end of the slot market. An Inter-Area Agent (IAA) is created and operated by each area to deal with forwarding offers and bids to the connected markets. The area constantly triggers the matching between bids and offers according to the matching algorithm.","title":"Two Sided Pay-As-Bid"},{"location":"two-sided-pay-as-clear/","text":"In the two-sided market, buyers are able to place bids in the market, alongside the offers placed by sellers (as seen in the one-sided market). The Two Sided Pay-As-Clear behaves the same as the Two Sided Pay-As-Bid market The only difference is the offer/bid matching algorithm. Currently, there is a so-called merit-order-effect mechanism implemented that works like the following: Bids and offers are aggregated in a specified discrete interval (clearing interval). At the end of that interval, bids are arranged in a descending order, offers in an ascending order and the equilibrium quantity of energy and price is calculated. The clearing point (the amount of energy that is accepted [ trade volume ] for a specific energy rate [ clearing price ]) is determined by point where arranged bid curve for the Consumers drops below the offer curve for the Producers. All offers that have an energy rate below or equal to the clearing price are accepted and matched randomly with all bids that have an energy rate higher or equal to the clearing price. The remaining bids and offers (right of the clearing point in the plot above) are not cleared at this clearing point and stay in the market for later matching.","title":"Two Sided Pay-As-Clear"},{"location":"ui-releases/","text":"Version 0.9.0 \u00b6 The following features were implemented : Market API , which allows grid operators and researchers to monitor metrics and set grid fees in the select local energy market simulation collaboration Easier registration for researchers and grid operators to manage multiple assets and use market API through the Registry page. Bids and offers are prioritised in their first market by setting a wait time of 2 ticks before allowing them to propagate to higher markets in the grid hierarchy. This wait time is set in the backend as the minimum bid or offer age parameter. Grid fees integrated in the Results page - Energy Pricing graph for each market Total grid fees reported in the Scoreboard page that demonstrates market performance metrics for each collaboration simulation. Net Energy calculation added to Results page - Energy Trade Profile graph in order to calculate the peak energy at a market node in the simulation. The current peak imports and exports were previously calculated based on the cumulative trades, but are now calculated from the net energy consumption, which can be a net import or export. Updated load final selling rate and PV initial buying rate in the template strategies now take the total grid fees into account in addition to the market maker (usually utility) rate. Users can now run three simulations and/or collaborations at once (previous limit was two) Version 0.8.0 \u00b6 The following features were implemented : Simulation Location Map. Users can geo-tag all energy resources and markets in their simulation to make a map view of the simulation and results. A summary of all simulations can be viewed in a global map, to see where Grid Singularity is running simulations all over the world! Version 0.7.0 \u00b6 The following features were implemented : Detailed energy trade profile graph . Zoom in to each 15 minute market slot to view the scheduled trades with 1 minute resolution. Grid Operator user can change grid parameters inside a collaboration and while it is running, like grid fees or the transformer capacity. Allow collaboration participants to register for events while the simulation is running. Allows users to simulate a growing community. Information Aggregator to compile and send average market measurements to assist data scientists in building smart strategies to trade through the API . Version 0.6.0 \u00b6 The following features were implemented : Bid and Offer matching graph Analyze all bids, offers, and trades in a market and see why they match based on their strategies. Simulation events Add, delete, or update areas or energy resources in a simulation while it is running. This allows users to grow their simulations in real-time and analyze the impacts of energy resources coming online and changes to grid parameters such as grid fees. Timeline to view events and zoom in View all events in a timeline and click on each event to view its relevant grid configuration and results. Zoom in to view results for a specific day. Pause or stop a simulation Pause a simulation to freeze it while adding an event. Stop a simulation pre-maturely in order to run another version sooner. Configure an infinite bus as part of the Market Maker Configure an Infinite Bus in order to add a feed-in-tariff to the simulation. Version 0.5.0 \u00b6 The following features were implemented : Constant based Grid Fees Self Sufficiency, Self Consumption, and Energy Peak Percentage KPIs Simulation runtime status indicator Increased node limit to 1000 nodes Collaborations Scoreboard Select visible charts on Results page Colors for Energy Bills Bought and Sold Version 0.4.0 \u00b6 The following features were implemented : Grid fees configuration User roles, including 'Collaborations' feature for multi user testing and Grid Singularity-hosted challenges API connection to energy devices allowing bids and offers to be submitted by external algorithms Version 0.3.0 \u00b6 The following features were implemented : Run simulations with up to 250 nodes Compare results of two simulations side by side New navigation side bar with Home, Projects, and Library easily accessible Version 0.2.0 \u00b6 The following features were implemented : Run simulations for one week Choose your market type: additional access to two-sided pay as bid and two-sided pay as clear market types New user friendly device strategies Configure your market maker Scrollable graphs on the results page optimized for longer simulations Download simulation results","title":"Releases"},{"location":"ui-releases/#version-090","text":"The following features were implemented : Market API , which allows grid operators and researchers to monitor metrics and set grid fees in the select local energy market simulation collaboration Easier registration for researchers and grid operators to manage multiple assets and use market API through the Registry page. Bids and offers are prioritised in their first market by setting a wait time of 2 ticks before allowing them to propagate to higher markets in the grid hierarchy. This wait time is set in the backend as the minimum bid or offer age parameter. Grid fees integrated in the Results page - Energy Pricing graph for each market Total grid fees reported in the Scoreboard page that demonstrates market performance metrics for each collaboration simulation. Net Energy calculation added to Results page - Energy Trade Profile graph in order to calculate the peak energy at a market node in the simulation. The current peak imports and exports were previously calculated based on the cumulative trades, but are now calculated from the net energy consumption, which can be a net import or export. Updated load final selling rate and PV initial buying rate in the template strategies now take the total grid fees into account in addition to the market maker (usually utility) rate. Users can now run three simulations and/or collaborations at once (previous limit was two)","title":"Version 0.9.0"},{"location":"ui-releases/#version-080","text":"The following features were implemented : Simulation Location Map. Users can geo-tag all energy resources and markets in their simulation to make a map view of the simulation and results. A summary of all simulations can be viewed in a global map, to see where Grid Singularity is running simulations all over the world!","title":"Version 0.8.0"},{"location":"ui-releases/#version-070","text":"The following features were implemented : Detailed energy trade profile graph . Zoom in to each 15 minute market slot to view the scheduled trades with 1 minute resolution. Grid Operator user can change grid parameters inside a collaboration and while it is running, like grid fees or the transformer capacity. Allow collaboration participants to register for events while the simulation is running. Allows users to simulate a growing community. Information Aggregator to compile and send average market measurements to assist data scientists in building smart strategies to trade through the API .","title":"Version 0.7.0"},{"location":"ui-releases/#version-060","text":"The following features were implemented : Bid and Offer matching graph Analyze all bids, offers, and trades in a market and see why they match based on their strategies. Simulation events Add, delete, or update areas or energy resources in a simulation while it is running. This allows users to grow their simulations in real-time and analyze the impacts of energy resources coming online and changes to grid parameters such as grid fees. Timeline to view events and zoom in View all events in a timeline and click on each event to view its relevant grid configuration and results. Zoom in to view results for a specific day. Pause or stop a simulation Pause a simulation to freeze it while adding an event. Stop a simulation pre-maturely in order to run another version sooner. Configure an infinite bus as part of the Market Maker Configure an Infinite Bus in order to add a feed-in-tariff to the simulation.","title":"Version 0.6.0"},{"location":"ui-releases/#version-050","text":"The following features were implemented : Constant based Grid Fees Self Sufficiency, Self Consumption, and Energy Peak Percentage KPIs Simulation runtime status indicator Increased node limit to 1000 nodes Collaborations Scoreboard Select visible charts on Results page Colors for Energy Bills Bought and Sold","title":"Version 0.5.0"},{"location":"ui-releases/#version-040","text":"The following features were implemented : Grid fees configuration User roles, including 'Collaborations' feature for multi user testing and Grid Singularity-hosted challenges API connection to energy devices allowing bids and offers to be submitted by external algorithms","title":"Version 0.4.0"},{"location":"ui-releases/#version-030","text":"The following features were implemented : Run simulations with up to 250 nodes Compare results of two simulations side by side New navigation side bar with Home, Projects, and Library easily accessible","title":"Version 0.3.0"},{"location":"ui-releases/#version-020","text":"The following features were implemented : Run simulations for one week Choose your market type: additional access to two-sided pay as bid and two-sided pay as clear market types New user friendly device strategies Configure your market maker Scrollable graphs on the results page optimized for longer simulations Download simulation results","title":"Version 0.2.0"},{"location":"upload-file-formats/","text":"Files can be uploaded to support custom energy supply or load profiles. The following file formats are supported: Comma Separated Values (.csv) \u00b6 The separation can be done by comma , or semicolon ; Two time formats are supported, see below. Power set-points are given in Watts. D3A handles any conversions to energy (in kWh). hh:mm Example: INTERVAL;POWER(W): 00:00;10 00:15;10 00:30;10 00:45;10 01:00;10 YYYY-MM-DDThh:mm Example: INTERVAL,POWER(W) 2019-01-01T00:00,10.0 2019-01-01T00:15,10.0 2019-01-01T00:30,10.0 2019-01-01T00:45,10.0 2019-01-01T01:00,10.0 Warning : If you upload csv files with date information (second example), you should also set the start-date of the simulation (the start-date of your csv files and the one of your simulation should be identical).","title":"Upload File Formats"},{"location":"upload-file-formats/#comma-separated-values-csv","text":"The separation can be done by comma , or semicolon ; Two time formats are supported, see below. Power set-points are given in Watts. D3A handles any conversions to energy (in kWh). hh:mm Example: INTERVAL;POWER(W): 00:00;10 00:15;10 00:30;10 00:45;10 01:00;10 YYYY-MM-DDThh:mm Example: INTERVAL,POWER(W) 2019-01-01T00:00,10.0 2019-01-01T00:15,10.0 2019-01-01T00:30,10.0 2019-01-01T00:45,10.0 2019-01-01T01:00,10.0 Warning : If you upload csv files with date information (second example), you should also set the start-date of the simulation (the start-date of your csv files and the one of your simulation should be identical).","title":"Comma Separated Values (.csv)"},{"location":"user-interface-d3a/","text":"This is the user's manual to the D3A User Interface (UI) at d3a.io . For questions, comments, and feedback, please engage with us through the D3A community at gitter.im/D3A-community . We are always welcoming feedback regarding how to improve the D3A. We are starting a tutorial video series. Check out our first video here and let us know what other videos you'd like to see! We also publish videos about the new features implemented in our latest releases . In the D3A UI users can model, simulate, optimize, and (coming soon) download and deploy their own energy exchange. Each exchange will be downloadable as a set of smart contracts, allowing the exchange to be decentralized for specific use cases. When creating, configuring and running a simulation of an energy trading use-case, the D3A UI will lead the user to three pages: Projects (Home Page) Simulation Configuration Results","title":"UI Overview"},{"location":"version-update/","text":"How to update the D3A and API Client \u00b6 The D3A is often updated with new features. These steps allow you to update to the most current version Update the D3A \u00b6 Open a terminal and activate the d3a virtual environment as described in the Installation Instructions for your OS. Then type: git pull origin/master fab sync If fab sync does not work on your machine, please try: pip install -e . The D3A should now be up to date. Update the API Client \u00b6 Open a terminal and activate the API client virtual environment as described in the API Installation Instructions . Then type: pip uninstall d3a-api-client Press y when prompted. Once the uninstall is complete, type: pip install git+https://github.com/gridsingularity/d3a-api-client.git Now, the API client should be up to date.","title":"Version Updates"},{"location":"version-update/#how-to-update-the-d3a-and-api-client","text":"The D3A is often updated with new features. These steps allow you to update to the most current version","title":"How to update the D3A and API Client"},{"location":"version-update/#update-the-d3a","text":"Open a terminal and activate the d3a virtual environment as described in the Installation Instructions for your OS. Then type: git pull origin/master fab sync If fab sync does not work on your machine, please try: pip install -e . The D3A should now be up to date.","title":"Update the D3A"},{"location":"version-update/#update-the-api-client","text":"Open a terminal and activate the API client virtual environment as described in the API Installation Instructions . Then type: pip uninstall d3a-api-client Press y when prompted. Once the uninstall is complete, type: pip install git+https://github.com/gridsingularity/d3a-api-client.git Now, the API client should be up to date.","title":"Update the API Client"}]}