{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"api-overview/","text":"Definition \u00b6 To enable users to interact with a running collaboration or a canary test network, two different application interfaces (APIs) are available. The Asset API allows the user to manage multiple energy assets by implementing custom trading strategies. The Grid Operator API allows the user to manage multiple markets by implementing custom grid fee strategies. Both interfaces allow strategies to incorporate market and asset statistics. Two examples of template API scripts are available in the Grid Singularity\u2019s GitHub repository: Asset API and Grid Operator API . These two APIs interact with Grid Singularity simulations through the open source Grid Singularity\u2019s API client . API Client Installation \u00b6 Note: If you are running the Grid Singularity energy exchange engine (D3A) using a virtual machine and vagrant , the latest api-client is already installed on your machine and you can skip to the Launch Simulation section below. If you are running the engine locally, please follow the following instructions. Install Redis server. Open a new terminal and type \u00b6 brew install redis To install redis in Ubuntu follow the link Install d3a-client \u00b6 mkvirtualenv d3a-api-env pip install git+https://github.com/gridsingularity/d3a-api-client.git Update d3a-client (as needed when an update is deployed) \u00b6 pip uninstall d3a-api-client pip install git+https://github.com/gridsingularity/d3a-api-client.git Lastly for the Grid Operator API, 3 additional packages are required for the template script to work: pip install pandas pip install openpyxl pip install tabulate Registration - Simulations run on the User Interface \u00b6 To connect the API to simulations, the user needs to register and be approved for a collaborative simulation by following these steps . Once the user successfully registers for the relevant assets or markets, the user needs to adapt their API scripts. Registration - Simulations run on the Backend \u00b6 Start Redis server \u00b6 To use the API locally, your script interacts with the simulation using a local Redis instance. To start the redis instance, open a new terminal and run the following command : redis-server /usr/local/etc/redis.conf` Open external connection to API for Assets \u00b6 In the setup file (template available here ), an asset must be designated as open to external connection via the API. This is controlled when setting up the simulation in the setup file by designating the ExternalStrategy for each relevant energy assets : Area('Family 3 children+PV+Batt', [ Area('Load 3 L17', strategy=LoadProfileExternalStrategy( daily_load_profile=os.path.join(current_dir, \"resources/CHR41 Family with 3 children, both at work HH1.csv\"), initial_buying_rate=Load_initial_buying_rate, final_buying_rate=Load_final_buying_rate), ), Area('PV 3 (5kW)', strategy=PVUserProfileExternalStrategy( power_profile=os.path.join(current_dir, \"resources/Berlin_pv.csv\"), panel_count=5, initial_selling_rate=30, final_selling_rate=11), ), Area('Tesla Powerwall 3', strategy=StorageExternalStrategy(initial_soc=10, 54min_allowed_soc=10, battery_capacity_kWh=14, max_abs_battery_power_kW=5, initial_buying_rate=0, final_buying_rate=25, initial_selling_rate=30, final_selling_rate=25.1), ), ]) By default, trading strategies do not allow API connections unless the ExternalStrategy is used. Please also ensure that the appropriate libraries are imported to use the API. Open Markets for external connection \u00b6 The API supports multiple markets managed with the Grid Operator API. Access is controlled when setting up the simulation, using the Area class\u2019 boolean argument called external_connection_available : Area( 'Community',[ ... ], grid_fee_constant=4, external_connection_available=True), If set to True , the area allows all the Grid Operator API to connect to that market, receive statistics and change grid fees. By default, this external_connection_available is set to False . Launch simulation \u00b6 This requires you to have the backend codebase installed on your machine to run simulations (see installation instructions ). First navigate to the D3A folder in a new terminal, then activate the D3A environment with the command: workon d3a An template setup is already available in github and ready to be run here (data available for the July 2021). To run this simulation and wait for the API template script to execute: d3a -l INFO run -t 15s -s 15m --setup api_setup.default_community --slot-length-realtime 5 --start-date 2021-07-01 --enable-external-connection --paused For more information on launching a simulation on the backend please visit this page . After few seconds, the simulation should begin, waiting for the API template as mentioned in the figure below: Initialise and start the API : \u00b6 Before launching the API script, the user needs to adapt the following information in their script (script template available here) : Oracle name \u00b6 This parameter is only relevant when using the API on the User-Interface. This defines the name of the aggregator / API name that manages the markets and energy assets. Once the name is set it cannot be changed within the same running collaboration. oracle_name = 'oracle' Assets/markets list \u00b6 The list of assets / markets needs to be updated to include the assets registered to user through the registration process, in arrays as follows : load_names = ['Load 1 L13', 'Load 2 L21', 'Load 3 L17'] pv_names = ['PV 1 (4kW)', 'PV 3 (5kW)'] storage_names = ['Tesla Powerwall 3'] market_names = [\"Grid\", \"Community\"] The API script has an automatic connection method to manage energy assets. If automatic is True , the API client will automatically connect to all energy assets that the user is registered to. This option is only available for simulations running on the User-Interface . Launching the API client: \u00b6 The API client is launched with a cli command . To launch the agent, you need to open a new terminal and activate d3a-api-client environment Workon d3a-api-client And go to the d3a-api-client repository cd path_to_repository/d3a-api-client The api launch cli command takes several arguments that can be listed with: d3a-api-client run --help The arguments are : base-setup-path --> Set the base path where user's client script resides, otherwise d3a_api_client/setups is taken as default for user's client scripts. Users can provide either an absolute or a relative file path. setup --> Name of user's API client module/script. username --> Username of agent authorized to communicate with respective collaboration/CN. password --> Password of respective agent domain-name --> D3A domain name web-socket --> D3A websocket URI simulation-id --> UUID of the collaboration or Canary Network (CN) simulation-config-path --> Path to the JSON file that contains the user's collaboration/CN information. This file can be downloaded from the \"Registry\" page on the D3A website. simulation-id , domain-name , and web-socket CLI-settings will be overwritten by the settings in the file run-on-redis --> This flag targets the local testing of the API client, where no user authentication is required. A locally running redis server and d3a simulation are needed here. The API agent can interface with a local simulation (d3a backend) or a collaboration/Canary Network (User-Interface). There are 3 methods to parse the required information when launching the API to connect to the UI: Simulation configuration file Cli command Environment variables Simulation configuration file: \u00b6 The simulation configuration file is a JSON format file downloadable on the User-Interface. It contains all the information about the simulation setup (username, simulation name and UUID, domain name, websocket domain name, global settings of the simulation and the registry, consisting of all the grid hierarchy including markets and assets and whether or not the user is connected to those). To download this file the user needs to go to the registry page of the relevant collaboration/CN and click on the top right edit icon and Download API Client Summary. To run the API agent you can run the following command by adapting the arguments to your case: d3a-api-client --log-level INFO run --setup asset_api_template -u username -p password -i absolute_path/my_simulation_config.json CLI command: \u00b6 Instead of passing the JSON file, the user can directly pass the relevant variables as arguments in the CLI commands. For that to work, users need to pass the domain name and websocket name (both are optional parameters and only relevant when connecting to specific domains) and the simulation_id. The simulation_id corresponds to the Universally Unique IDentifier. This token can be found in the URL of a collaboration or a Canary Network in the User Interface. To run the API agent you can run the following command by adapting the arguments to your case: d3a-api-client --log-level INFO run --setup asset_api_template -u username -p password --simulation-id UUID Environnement variables: \u00b6 The last method to launch the API is to send the set the required variable in the environment. To do that users can simply define those parameters at the top of their script as follow: os.environ[\"API_CLIENT_USERNAME\"] = \"username\" os.environ[\"API_CLIENT_PASSWORD\"] = \"password\" os.environ[\"API_CLIENT_SIMULATION_ID\"] = \"simulation_uuid\" To run the API agent you can run the following command by adapting the arguments to your case: d3a-api-client --log-level INFO run --setup asset_api_template Local simulation: \u00b6 To interact with a locally running simulation (backend simulation), username, passwords, domain and websocket names and simulation_id are not necessary. There is only an additional flag required in the CLI command : --run-on-redis . d3a-api-client --log-level INFO run --setup asset_api_template --run-on-redis Log levels: \u00b6 The API CLI command can receive a --log-level argument. Adjusting this parameter will increase or reduce the level of information displayed in the terminal, while the agent is running. There are 4 levels (classed from low detailed to high: ERROR \u00b6 Display only critical errors from the api client or the d3a (for instance, if d3a responds with an error in a command that the API client is sending, the error log should include it) WARNING \u00b6 Display critical and non-critical error messages (for instance if the API agent is over bidding its energy requirement) INFO \u00b6 Display critical and non-critical errors messages and general information such as market progression and trades DEBUG \u00b6 Display full information on the agent (for instance all command and response, such as placing bids and offers on the market)","title":"Overview"},{"location":"api-overview/#definition","text":"To enable users to interact with a running collaboration or a canary test network, two different application interfaces (APIs) are available. The Asset API allows the user to manage multiple energy assets by implementing custom trading strategies. The Grid Operator API allows the user to manage multiple markets by implementing custom grid fee strategies. Both interfaces allow strategies to incorporate market and asset statistics. Two examples of template API scripts are available in the Grid Singularity\u2019s GitHub repository: Asset API and Grid Operator API . These two APIs interact with Grid Singularity simulations through the open source Grid Singularity\u2019s API client .","title":"Definition"},{"location":"api-overview/#api-client-installation","text":"Note: If you are running the Grid Singularity energy exchange engine (D3A) using a virtual machine and vagrant , the latest api-client is already installed on your machine and you can skip to the Launch Simulation section below. If you are running the engine locally, please follow the following instructions.","title":"API Client Installation"},{"location":"api-overview/#install-redis-server-open-a-new-terminal-and-type","text":"brew install redis To install redis in Ubuntu follow the link","title":"Install Redis server. Open a new terminal and type"},{"location":"api-overview/#install-d3a-client","text":"mkvirtualenv d3a-api-env pip install git+https://github.com/gridsingularity/d3a-api-client.git","title":"Install d3a-client"},{"location":"api-overview/#update-d3a-client-as-needed-when-an-update-is-deployed","text":"pip uninstall d3a-api-client pip install git+https://github.com/gridsingularity/d3a-api-client.git Lastly for the Grid Operator API, 3 additional packages are required for the template script to work: pip install pandas pip install openpyxl pip install tabulate","title":"Update d3a-client (as needed when an update is deployed)"},{"location":"api-overview/#registration-simulations-run-on-the-user-interface","text":"To connect the API to simulations, the user needs to register and be approved for a collaborative simulation by following these steps . Once the user successfully registers for the relevant assets or markets, the user needs to adapt their API scripts.","title":"Registration - Simulations run on the User Interface"},{"location":"api-overview/#registration-simulations-run-on-the-backend","text":"","title":"Registration - Simulations run on the Backend"},{"location":"api-overview/#start-redis-server","text":"To use the API locally, your script interacts with the simulation using a local Redis instance. To start the redis instance, open a new terminal and run the following command : redis-server /usr/local/etc/redis.conf`","title":"Start Redis server"},{"location":"api-overview/#open-external-connection-to-api-for-assets","text":"In the setup file (template available here ), an asset must be designated as open to external connection via the API. This is controlled when setting up the simulation in the setup file by designating the ExternalStrategy for each relevant energy assets : Area('Family 3 children+PV+Batt', [ Area('Load 3 L17', strategy=LoadProfileExternalStrategy( daily_load_profile=os.path.join(current_dir, \"resources/CHR41 Family with 3 children, both at work HH1.csv\"), initial_buying_rate=Load_initial_buying_rate, final_buying_rate=Load_final_buying_rate), ), Area('PV 3 (5kW)', strategy=PVUserProfileExternalStrategy( power_profile=os.path.join(current_dir, \"resources/Berlin_pv.csv\"), panel_count=5, initial_selling_rate=30, final_selling_rate=11), ), Area('Tesla Powerwall 3', strategy=StorageExternalStrategy(initial_soc=10, 54min_allowed_soc=10, battery_capacity_kWh=14, max_abs_battery_power_kW=5, initial_buying_rate=0, final_buying_rate=25, initial_selling_rate=30, final_selling_rate=25.1), ), ]) By default, trading strategies do not allow API connections unless the ExternalStrategy is used. Please also ensure that the appropriate libraries are imported to use the API.","title":"Open external connection to API for Assets"},{"location":"api-overview/#open-markets-for-external-connection","text":"The API supports multiple markets managed with the Grid Operator API. Access is controlled when setting up the simulation, using the Area class\u2019 boolean argument called external_connection_available : Area( 'Community',[ ... ], grid_fee_constant=4, external_connection_available=True), If set to True , the area allows all the Grid Operator API to connect to that market, receive statistics and change grid fees. By default, this external_connection_available is set to False .","title":"Open Markets for external connection"},{"location":"api-overview/#launch-simulation","text":"This requires you to have the backend codebase installed on your machine to run simulations (see installation instructions ). First navigate to the D3A folder in a new terminal, then activate the D3A environment with the command: workon d3a An template setup is already available in github and ready to be run here (data available for the July 2021). To run this simulation and wait for the API template script to execute: d3a -l INFO run -t 15s -s 15m --setup api_setup.default_community --slot-length-realtime 5 --start-date 2021-07-01 --enable-external-connection --paused For more information on launching a simulation on the backend please visit this page . After few seconds, the simulation should begin, waiting for the API template as mentioned in the figure below:","title":"Launch simulation"},{"location":"api-overview/#initialise-and-start-the-api","text":"Before launching the API script, the user needs to adapt the following information in their script (script template available here) :","title":"Initialise and start the API :"},{"location":"api-overview/#oracle-name","text":"This parameter is only relevant when using the API on the User-Interface. This defines the name of the aggregator / API name that manages the markets and energy assets. Once the name is set it cannot be changed within the same running collaboration. oracle_name = 'oracle'","title":"Oracle name"},{"location":"api-overview/#assetsmarkets-list","text":"The list of assets / markets needs to be updated to include the assets registered to user through the registration process, in arrays as follows : load_names = ['Load 1 L13', 'Load 2 L21', 'Load 3 L17'] pv_names = ['PV 1 (4kW)', 'PV 3 (5kW)'] storage_names = ['Tesla Powerwall 3'] market_names = [\"Grid\", \"Community\"] The API script has an automatic connection method to manage energy assets. If automatic is True , the API client will automatically connect to all energy assets that the user is registered to. This option is only available for simulations running on the User-Interface .","title":"Assets/markets list"},{"location":"api-overview/#launching-the-api-client","text":"The API client is launched with a cli command . To launch the agent, you need to open a new terminal and activate d3a-api-client environment Workon d3a-api-client And go to the d3a-api-client repository cd path_to_repository/d3a-api-client The api launch cli command takes several arguments that can be listed with: d3a-api-client run --help The arguments are : base-setup-path --> Set the base path where user's client script resides, otherwise d3a_api_client/setups is taken as default for user's client scripts. Users can provide either an absolute or a relative file path. setup --> Name of user's API client module/script. username --> Username of agent authorized to communicate with respective collaboration/CN. password --> Password of respective agent domain-name --> D3A domain name web-socket --> D3A websocket URI simulation-id --> UUID of the collaboration or Canary Network (CN) simulation-config-path --> Path to the JSON file that contains the user's collaboration/CN information. This file can be downloaded from the \"Registry\" page on the D3A website. simulation-id , domain-name , and web-socket CLI-settings will be overwritten by the settings in the file run-on-redis --> This flag targets the local testing of the API client, where no user authentication is required. A locally running redis server and d3a simulation are needed here. The API agent can interface with a local simulation (d3a backend) or a collaboration/Canary Network (User-Interface). There are 3 methods to parse the required information when launching the API to connect to the UI: Simulation configuration file Cli command Environment variables","title":"Launching the API client:"},{"location":"api-overview/#simulation-configuration-file","text":"The simulation configuration file is a JSON format file downloadable on the User-Interface. It contains all the information about the simulation setup (username, simulation name and UUID, domain name, websocket domain name, global settings of the simulation and the registry, consisting of all the grid hierarchy including markets and assets and whether or not the user is connected to those). To download this file the user needs to go to the registry page of the relevant collaboration/CN and click on the top right edit icon and Download API Client Summary. To run the API agent you can run the following command by adapting the arguments to your case: d3a-api-client --log-level INFO run --setup asset_api_template -u username -p password -i absolute_path/my_simulation_config.json","title":"Simulation configuration file:"},{"location":"api-overview/#cli-command","text":"Instead of passing the JSON file, the user can directly pass the relevant variables as arguments in the CLI commands. For that to work, users need to pass the domain name and websocket name (both are optional parameters and only relevant when connecting to specific domains) and the simulation_id. The simulation_id corresponds to the Universally Unique IDentifier. This token can be found in the URL of a collaboration or a Canary Network in the User Interface. To run the API agent you can run the following command by adapting the arguments to your case: d3a-api-client --log-level INFO run --setup asset_api_template -u username -p password --simulation-id UUID","title":"CLI command:"},{"location":"api-overview/#environnement-variables","text":"The last method to launch the API is to send the set the required variable in the environment. To do that users can simply define those parameters at the top of their script as follow: os.environ[\"API_CLIENT_USERNAME\"] = \"username\" os.environ[\"API_CLIENT_PASSWORD\"] = \"password\" os.environ[\"API_CLIENT_SIMULATION_ID\"] = \"simulation_uuid\" To run the API agent you can run the following command by adapting the arguments to your case: d3a-api-client --log-level INFO run --setup asset_api_template","title":"Environnement variables:"},{"location":"api-overview/#local-simulation","text":"To interact with a locally running simulation (backend simulation), username, passwords, domain and websocket names and simulation_id are not necessary. There is only an additional flag required in the CLI command : --run-on-redis . d3a-api-client --log-level INFO run --setup asset_api_template --run-on-redis","title":"Local simulation:"},{"location":"api-overview/#log-levels","text":"The API CLI command can receive a --log-level argument. Adjusting this parameter will increase or reduce the level of information displayed in the terminal, while the agent is running. There are 4 levels (classed from low detailed to high:","title":"Log levels:"},{"location":"api-overview/#error","text":"Display only critical errors from the api client or the d3a (for instance, if d3a responds with an error in a command that the API client is sending, the error log should include it)","title":"ERROR"},{"location":"api-overview/#warning","text":"Display critical and non-critical error messages (for instance if the API agent is over bidding its energy requirement)","title":"WARNING"},{"location":"api-overview/#info","text":"Display critical and non-critical errors messages and general information such as market progression and trades","title":"INFO"},{"location":"api-overview/#debug","text":"Display full information on the agent (for instance all command and response, such as placing bids and offers on the market)","title":"DEBUG"},{"location":"assets-api/","text":"The Grid Singularity API client allows you to create agents that follow custom trading strategies to buy and sell energy in the energy market. The agent can request and receive information through the Asset API, feed that information into an algorithm, and post bids or offers on a live simulated exchange. The new market cycle begins after every 15 minutes and is divided into 10 ticks till the end of the market cycle. The bids and offers are made within the market cycle at every tick till the cycle ends. Start of the market slot The API sends the market info, aggregated last market slot stats, grid hierarchy and asset info. Each tick of the market slot Market slots are organised into 10 available ticks where the agent can make decisions API agent receives updated asset information (e.g. remaining energy to buy/sell) API agent can post/update/delete bid and offer When the trade occurs, on_trade events with trade details are sent by the API. If there are unmatched bids or offers, they are not carried to the next market cycle. API Events \u00b6 In order to facilitate bid and offer management and scheduling, a python file with the class Oracle is provided. The Oracle class acts as an information aggregator for all of the energy assets (e.g. loads, PVs and storages) you manage, and allows you to post bids and offers on their behalf. A few functions are triggered on different types of events, and can be overridden, useful to take actions when market events occur. Each new market slot \u00b6 def on_market_cycle(self, market_info): When a new market slot is available the client will get notified via an event. It is possible to capture this event and perform operations after it by overriding the on_market_cycle method. In the variable market_info you will get a dictionary with information on the market and your assets. You receive information for each asset you manage. The return values have the following structure: { 'slo t _comple t io n ' : ' 0 %' , 'marke t _slo t ' : ' 2014-10-01 T 00 : 15 ' , 'grid_ tree ' : { ' 477999 f 1- f d 6e-4 c 68-8 cc 8-e8e52049 de 8e ' : { 'las t _marke t _bill' : { 'accumula te d_ tra des' : {}, 'ex ternal _ tra des' : {}}, 'las t _marke t _s tats ' : { 'mi n _ tra de_ra te ' : 26.0 , 'max_ tra de_ra te ' : 26.0 , 'avg_ tra de_ra te ' : 26.0 , 'media n _ tra de_ra te ' : 26.0 , ' t o tal _ tra ded_e ner gy_kWh' : 7.5239405 }, 'las t _marke t _ fee ' : 4 , 'curre nt _marke t _ fee ' : 4 , 'area_ na me' : 'Grid' , 'childre n ' : { ' f 02313 bb -16 c 4-427 b -90 d 2- d 753822 fe 21 c' : { 'las t _marke t _bill' : { 'accumula te d_ tra des' : {}, 'ex ternal _ tra des' : {}}, 'las t _marke t _s tats ' : { 'mi n _ tra de_ra te ' : 30.0 , 'max_ tra de_ra te ' : 30.0 , 'avg_ tra de_ra te ' : 30.0 , 'media n _ tra de_ra te ' : 30.0 , ' t o tal _ tra ded_e ner gy_kWh' : 7.5239405 }, 'las t _marke t _ fee ' : 4 , 'curre nt _marke t _ fee ' : 4 , 'area_ na me' : 'Commu n i t y' , 'childre n ' : { ' 44 d 19495-39e8-42e0- be 2 f -0432e644e5e5 ' : { 'las t _marke t _bill' : { 'accumula te d_ tra des' : {}, 'ex ternal _ tra des' : {}}, 'las t _marke t _s tats ' : { 'mi n _ tra de_ra te ' : No ne , 'max_ tra de_ra te ' : No ne , 'avg_ tra de_ra te ' : No ne , 'media n _ tra de_ra te ' : No ne , ' t o tal _ tra ded_e ner gy_kWh' : No ne }, 'las t _marke t _ fee ' : 0.0 , 'curre nt _marke t _ fee ' : No ne , 'area_ na me' : 'Member 1 ' , 'childre n ' : { ' 075834 dd -5438-4287-8393-781 a 4 a 8068 f 5 ' : { 'asse t _i nf o' : { 'e ner gy_requireme nt _kWh' : 0.06802025 , 'e ner gy_ac t ive_i n _bids' : 0.0 , 'e ner gy_ tra ded' : 0.0 , ' t o tal _cos t ' : 0.0 }, 'las t _slo t _asse t _i nf o' : { 'e ner gy_ tra ded' : 0.0 , ' t o tal _cos t ' : 0.0 }, 'asse t _bill' : {}, 'area_ na me' : 'Load 1 ' }, ' 2e7866 d 8-34 c 6-49 ad - a 388- f d 5876 a 3e679 ' : { 'asse t _i nf o' : { 'available_e ner gy_kWh' : 0.0 , 'e ner gy_ac t ive_i n _o ffers ' : 0 , 'e ner gy_ tra ded' : 0 , ' t o tal _cos t ' : 0 }, 'las t _slo t _asse t _i nf o' : { 'e ner gy_ tra ded' : 0 , ' t o tal _cos t ' : 0 }, 'asse t _bill' : {}, 'area_ na me' : 'PV 1 ' }, ' 22 c 495 b 2-4 b 2 b -43 ba -8 c 76-3e b 956014975 ' : { 'asse t _i nf o' : { 'e ner gy_ t o_sell' : 0.0 , 'e ner gy_ac t ive_i n _bids' : 0 , 'e ner gy_ t o_buy' : 1.36275 , 'e ner gy_ac t ive_i n _o ffers ' : 0 , ' free _s t orage' : 10.0 , 'used_s t orage' : 0.0 , 'e ner gy_ tra ded' : 0.0 , ' t o tal _cos t ' : 0.0 }, 'las t _slo t _asse t _i nf o' : { 'e ner gy_ tra ded' : 0.0 , ' t o tal _cos t ' : 0.0 }, 'asse t _bill' : {}, 'area_ na me' : 'S t orage 1 ' }}}, ' 5 c 0 c 05 dd -2e23-4866- a 113-e08797 a 2094e ' : { 'las t _marke t _bill' : { 'accumula te d_ tra des' : {}, 'ex ternal _ tra des' : {}}, 'las t _marke t _s tats ' : { 'mi n _ tra de_ra te ' : 30.0 , 'max_ tra de_ra te ' : 30.0 , 'avg_ tra de_ra te ' : 30.0 , 'media n _ tra de_ra te ' : 30.0 , ' t o tal _ tra ded_e ner gy_kWh' : 0.064779 }, 'las t _marke t _ fee ' : 0.0 , 'curre nt _marke t _ fee ' : No ne , ' fee d_i n _ tar i ff _ra te ' : 21.9 , 'marke t _maker_ra te ' : 22 , 'eve nt ' : 'marke t ' , ' nu m_ t icks' : 10.0 , 'simula t io n _id' : No ne ' fee d_i n _ tar i ff _ra te ' : 21.9 , 'marke t _maker_ra te ' : 22 , 'eve nt ' : 'marke t ' , ' nu m_ t icks' : 10.0 , 'simula t io n _id' : No ne } On % of market completion \u00b6 def on_tick(self, tick_info): Each 10% of market slot completion (e.g. 10%, 20%, 30%, \u2026), the same information as market_info will be passed, with updated asset energy requirements based on trades. This can be used to update your bid or offer price at these milestones. On event or response \u00b6 def on_event_or_response(self, message): Each time the assets you manage are triggered with an event or get any responses (from sending the batch commands such as trades, bids/offers confirmations), this information is passed through on_event_or_response . This information can be stored locally or acted upon. On finish \u00b6 def on_finish(self, finish_info): This executes when the simulation finishes, and can be used to trigger exporting data, training a model or exiting the code. API Commands \u00b6 The oracle is able to request information and post bids and offers for multiple assets at the same time by aggregating multiple commands in a single batch to be executed at the same time. The following are the different commands available for the Asset API : bid_energy() \u00b6 Places an energy bid to the registered market. This command receives 4 arguments : area_uuid : Universal Unique Identifier of the selected asset energy : energy in kWh price : price in Euro cents replace_existing : if set to TRUE replace all existing bids with a new one Here is an example: self.add_to_batch_commands.bid_energy(area_uuid = \"2e7866d8-34c6-49ad-a388-fd5876a3e679\", energy = 2, price = 60, replace_existing = True) bid_energy_rate() \u00b6 Places an energy bid to the registered market. This batch command receives 4 arguments : area_uuid : Universal Unique Identifier of the selected asset energy : energy in kWh rate : price per volume in Euro cents/kWh replace_existing : if set to TRUE replace all existing bids with a new one Here is an example: self.add_to_batch_commands.bid_energy_rate(area_uuid = \"2e7866d8-34c6-49ad-a388-fd5876a3e679\", energy = 2, rate = 30, replace_existing = True) lists_bids() \u00b6 Lists all posted bids on the selected market. This command takes 1 argument: area_uuid which is the Universal Unique Identifier of the selected market. Here is an example: self.add_to_batch_commands.list_bids(area_uuid=\"62f827ec-ef86-4782-b5c3-88327751d97d\") delete_bid() \u00b6 Delete a bid posted on the market using its ID. This command receives 2 arguments : area_uuid : Universal Unique Identifier of the selected asset bid_id : ID of the selected bid. If None, all the bids posted by the selected asset will be deleted. Here is an example: self.add_to_batch_commands.delete_bid(area_uuid=\"62f827ec-ef86-4782-b5c3-88327751d97d\", bid_id = \"2e7866d8-3dg6-49ad-afe8-fd5876a3e679\") offer_energy() \u00b6 Places an energy offer to the registered market. This command receives 4 arguments : area_uuid : Universal Unique Identifier of the selected asset energy : energy in kWh price : price in Euro cents replace_existing : if set to TRUE replace all existing bids with a new one Here is an example: self.add_to_batch_commands.offer_energy(area_uuid = \"2e7866d8-34c6-49ad-a388-fd5876a3e679\", energy = 2, price_cents = 60, replace_existing = True) offer_energy_rate() \u00b6 Places an energy offer to the registered market. This command receives 4 arguments : area_uuid : Universal Unique Identifier of the selected asset energy : energy in kWh rate : price per volume in Euro cents/kWh replace_existing : if set to TRUE replace all existing offers with a new one Here is an example: self.add_to_batch_commands.offer_energy_rate(area_uuid = \"2e7866d8-34c6-49ad-a388-fd5876a3e679\", energy = 2, rate = 30, replace_existing = True) lists_offers() \u00b6 Lists all posted offers on the selected market. This command takes 1 argument: area_uuid which is the Universal Unique Identifier of the selected market. Here is an example: self.add_to_batch_commands.list_offers(area_uuid=\"62f827ec-ef86-4782-b5c3-88327751d97d\") delete_offer() \u00b6 Delete an offer posted on the market using its ID. This command receives 2 arguments : area_uuid : Universal Unique Identifier of the selected asset offer_id : ID of the selected offer. If None, all the bids posted by the selected asset will be deleted. Here is an example: self.add_to_batch_commands.delete_offer(area_uuid=\"62f827ec-ef86-4782-b5c3-88327751d97d\", bid_id = \"2e7866d8-3dg6-49ad-afe8-fd5876a3e679\") device_info() \u00b6 Get device info (returns required energy for Load devices, available energy for PVs and energy to buy/sell for storage). This command receives 1 argument: area_uuid which is the Universal Unique Identifier of the selected asset self.add_to_batch_commands.device_info(area_uuid=\"62f827ec-ef86-4782-b5c3-88327751d97d\") Execute \u00b6 After adding all the wanted commands in the batch, the API can execute it with the following command: response = self.execute_batch_commands() In return the simulation will provide a detailed response for all commands submitted. Note: The total amount of energy to bid/offer at any point is limited to the energy requirement/available of the asset. Additionally, the price of your bids/offers must be a positive float otherwise it will get rejected by the market. API template script \u00b6 A simple trading strategy is available in the template agent . This shows an example of what can be done with this API, and offers a flexible structure, easy to modify to implement custom smart trading strategies. See the TODO flags there to see how you may configure your trading strategy and extract market and asset data. Here , the name of the oracle and the list of the connected devices are defined. If the user is running the API to the UI and automatic is set to True, the script will automatically connect to all assets the user is approved to. The event on_market_cycle is used to gather market information through market_info and assets information, define the trading strategy and place the first bids/offers. The first information to be gathered is the Market Maker price and Feed-in Tariff and calculate the average value between them. These values are required to set the boundaries of the pricing trading strategy. In these lines , the API script stores energy assets information such as the energy requirements for the loads, the energy available for the PVs and the State Of Charge for the storage. This information when aggregated could be valuable when designing a smarter strategy. After that, the API client creates a nested dictionary , containing various information for each asset. First we get the name of the assets and the fees between the assets and the market maker . The Aggregator class has a function that calculates the grid fees along the path between two assets or markets in the grid: calculate_grid_fee . This function takes 3 arguments: start_market_or_device_name : UUID of the started market/asset target_market_or_device_name : UUID of the targeted market/asset fee_type : can either be current_market_fee or last_market_fee These fees should be integrated in the pricing strategy in order to avoid any power outages for the loads and curtailment for the PVs. Lastly in this asset_strategy dictionary, the pricing strategy is defined for each asset individually. This allows assets to have independent strategies depending on their information and location in the grid. The current pricing strategies are deterministic, representing a linear function bounded between the Feed-in Tariff - grid fee (lower boundary) and the Market Maker price + grid fee (upper boundary). Since the API client can post up to 10 bids/offers per market slot, the strategies incrementally ramp up (bids) or down (offers) for a total of 10 prices per energy asset. The final bid/offer price is set at least 2 API available ticks before the end of the market slot length (9th and 10th tick in our case) to make sure that the bids and offers are placed before the market slot . Here are defined the loads , PVs and storages pricing strategies. In these lines , the API script sends the first bid and/or offer for each energy asset. For each of them the API gets the energy requirements (load), available (storage) and energy to buy/sell (storage) through latest_grid_tree_flat.items() (which is the market_info dictionary flattened). For each asset\u2019s bid/offer, the API applies the price defined in the asset_strategy dictionary defined above. Once all the bids/offers commands have been set, the batch is executed . At each on_tick event, the API agent can post new or update or delete existing bids and offers. This allows the API client to update their price strategy until all consumption and generation have been traded. In these lines , the API client updates the existing bids/offers with new prices to optimize trades. The updated energy information is found in latest_grid_tree_flat.items() and the prices for each bid/offer depends on the market slot progression. Once all commands are added to the batch, it is then executed. After that, the on_event_or_response is overwritten. By default we do not perform any operation in this event but the user could add some if needed. For instance the user could record all the trades responses received in that event. Lastly the API script overwrites the on_finish event so that whenever the function is triggered the script stops. If the user wishes to save some information recorded within the API client this would be the opportunity to export them to external files. The rest of the script is used to connect to the energy assets of a running simulation/collaboration/canary network. These lines should work as is and no changes are required. Please find the following tutorial describing the required steps to run the asset API locally and on a collaboration:","title":"Asset API"},{"location":"assets-api/#api-events","text":"In order to facilitate bid and offer management and scheduling, a python file with the class Oracle is provided. The Oracle class acts as an information aggregator for all of the energy assets (e.g. loads, PVs and storages) you manage, and allows you to post bids and offers on their behalf. A few functions are triggered on different types of events, and can be overridden, useful to take actions when market events occur.","title":"API Events"},{"location":"assets-api/#each-new-market-slot","text":"def on_market_cycle(self, market_info): When a new market slot is available the client will get notified via an event. It is possible to capture this event and perform operations after it by overriding the on_market_cycle method. In the variable market_info you will get a dictionary with information on the market and your assets. You receive information for each asset you manage. The return values have the following structure: { 'slo t _comple t io n ' : ' 0 %' , 'marke t _slo t ' : ' 2014-10-01 T 00 : 15 ' , 'grid_ tree ' : { ' 477999 f 1- f d 6e-4 c 68-8 cc 8-e8e52049 de 8e ' : { 'las t _marke t _bill' : { 'accumula te d_ tra des' : {}, 'ex ternal _ tra des' : {}}, 'las t _marke t _s tats ' : { 'mi n _ tra de_ra te ' : 26.0 , 'max_ tra de_ra te ' : 26.0 , 'avg_ tra de_ra te ' : 26.0 , 'media n _ tra de_ra te ' : 26.0 , ' t o tal _ tra ded_e ner gy_kWh' : 7.5239405 }, 'las t _marke t _ fee ' : 4 , 'curre nt _marke t _ fee ' : 4 , 'area_ na me' : 'Grid' , 'childre n ' : { ' f 02313 bb -16 c 4-427 b -90 d 2- d 753822 fe 21 c' : { 'las t _marke t _bill' : { 'accumula te d_ tra des' : {}, 'ex ternal _ tra des' : {}}, 'las t _marke t _s tats ' : { 'mi n _ tra de_ra te ' : 30.0 , 'max_ tra de_ra te ' : 30.0 , 'avg_ tra de_ra te ' : 30.0 , 'media n _ tra de_ra te ' : 30.0 , ' t o tal _ tra ded_e ner gy_kWh' : 7.5239405 }, 'las t _marke t _ fee ' : 4 , 'curre nt _marke t _ fee ' : 4 , 'area_ na me' : 'Commu n i t y' , 'childre n ' : { ' 44 d 19495-39e8-42e0- be 2 f -0432e644e5e5 ' : { 'las t _marke t _bill' : { 'accumula te d_ tra des' : {}, 'ex ternal _ tra des' : {}}, 'las t _marke t _s tats ' : { 'mi n _ tra de_ra te ' : No ne , 'max_ tra de_ra te ' : No ne , 'avg_ tra de_ra te ' : No ne , 'media n _ tra de_ra te ' : No ne , ' t o tal _ tra ded_e ner gy_kWh' : No ne }, 'las t _marke t _ fee ' : 0.0 , 'curre nt _marke t _ fee ' : No ne , 'area_ na me' : 'Member 1 ' , 'childre n ' : { ' 075834 dd -5438-4287-8393-781 a 4 a 8068 f 5 ' : { 'asse t _i nf o' : { 'e ner gy_requireme nt _kWh' : 0.06802025 , 'e ner gy_ac t ive_i n _bids' : 0.0 , 'e ner gy_ tra ded' : 0.0 , ' t o tal _cos t ' : 0.0 }, 'las t _slo t _asse t _i nf o' : { 'e ner gy_ tra ded' : 0.0 , ' t o tal _cos t ' : 0.0 }, 'asse t _bill' : {}, 'area_ na me' : 'Load 1 ' }, ' 2e7866 d 8-34 c 6-49 ad - a 388- f d 5876 a 3e679 ' : { 'asse t _i nf o' : { 'available_e ner gy_kWh' : 0.0 , 'e ner gy_ac t ive_i n _o ffers ' : 0 , 'e ner gy_ tra ded' : 0 , ' t o tal _cos t ' : 0 }, 'las t _slo t _asse t _i nf o' : { 'e ner gy_ tra ded' : 0 , ' t o tal _cos t ' : 0 }, 'asse t _bill' : {}, 'area_ na me' : 'PV 1 ' }, ' 22 c 495 b 2-4 b 2 b -43 ba -8 c 76-3e b 956014975 ' : { 'asse t _i nf o' : { 'e ner gy_ t o_sell' : 0.0 , 'e ner gy_ac t ive_i n _bids' : 0 , 'e ner gy_ t o_buy' : 1.36275 , 'e ner gy_ac t ive_i n _o ffers ' : 0 , ' free _s t orage' : 10.0 , 'used_s t orage' : 0.0 , 'e ner gy_ tra ded' : 0.0 , ' t o tal _cos t ' : 0.0 }, 'las t _slo t _asse t _i nf o' : { 'e ner gy_ tra ded' : 0.0 , ' t o tal _cos t ' : 0.0 }, 'asse t _bill' : {}, 'area_ na me' : 'S t orage 1 ' }}}, ' 5 c 0 c 05 dd -2e23-4866- a 113-e08797 a 2094e ' : { 'las t _marke t _bill' : { 'accumula te d_ tra des' : {}, 'ex ternal _ tra des' : {}}, 'las t _marke t _s tats ' : { 'mi n _ tra de_ra te ' : 30.0 , 'max_ tra de_ra te ' : 30.0 , 'avg_ tra de_ra te ' : 30.0 , 'media n _ tra de_ra te ' : 30.0 , ' t o tal _ tra ded_e ner gy_kWh' : 0.064779 }, 'las t _marke t _ fee ' : 0.0 , 'curre nt _marke t _ fee ' : No ne , ' fee d_i n _ tar i ff _ra te ' : 21.9 , 'marke t _maker_ra te ' : 22 , 'eve nt ' : 'marke t ' , ' nu m_ t icks' : 10.0 , 'simula t io n _id' : No ne ' fee d_i n _ tar i ff _ra te ' : 21.9 , 'marke t _maker_ra te ' : 22 , 'eve nt ' : 'marke t ' , ' nu m_ t icks' : 10.0 , 'simula t io n _id' : No ne }","title":"Each new market slot"},{"location":"assets-api/#on-of-market-completion","text":"def on_tick(self, tick_info): Each 10% of market slot completion (e.g. 10%, 20%, 30%, \u2026), the same information as market_info will be passed, with updated asset energy requirements based on trades. This can be used to update your bid or offer price at these milestones.","title":"On % of market completion"},{"location":"assets-api/#on-event-or-response","text":"def on_event_or_response(self, message): Each time the assets you manage are triggered with an event or get any responses (from sending the batch commands such as trades, bids/offers confirmations), this information is passed through on_event_or_response . This information can be stored locally or acted upon.","title":"On event or response"},{"location":"assets-api/#on-finish","text":"def on_finish(self, finish_info): This executes when the simulation finishes, and can be used to trigger exporting data, training a model or exiting the code.","title":"On finish"},{"location":"assets-api/#api-commands","text":"The oracle is able to request information and post bids and offers for multiple assets at the same time by aggregating multiple commands in a single batch to be executed at the same time. The following are the different commands available for the Asset API :","title":"API Commands"},{"location":"assets-api/#bid_energy","text":"Places an energy bid to the registered market. This command receives 4 arguments : area_uuid : Universal Unique Identifier of the selected asset energy : energy in kWh price : price in Euro cents replace_existing : if set to TRUE replace all existing bids with a new one Here is an example: self.add_to_batch_commands.bid_energy(area_uuid = \"2e7866d8-34c6-49ad-a388-fd5876a3e679\", energy = 2, price = 60, replace_existing = True)","title":"bid_energy()"},{"location":"assets-api/#bid_energy_rate","text":"Places an energy bid to the registered market. This batch command receives 4 arguments : area_uuid : Universal Unique Identifier of the selected asset energy : energy in kWh rate : price per volume in Euro cents/kWh replace_existing : if set to TRUE replace all existing bids with a new one Here is an example: self.add_to_batch_commands.bid_energy_rate(area_uuid = \"2e7866d8-34c6-49ad-a388-fd5876a3e679\", energy = 2, rate = 30, replace_existing = True)","title":"bid_energy_rate()"},{"location":"assets-api/#lists_bids","text":"Lists all posted bids on the selected market. This command takes 1 argument: area_uuid which is the Universal Unique Identifier of the selected market. Here is an example: self.add_to_batch_commands.list_bids(area_uuid=\"62f827ec-ef86-4782-b5c3-88327751d97d\")","title":"lists_bids()"},{"location":"assets-api/#delete_bid","text":"Delete a bid posted on the market using its ID. This command receives 2 arguments : area_uuid : Universal Unique Identifier of the selected asset bid_id : ID of the selected bid. If None, all the bids posted by the selected asset will be deleted. Here is an example: self.add_to_batch_commands.delete_bid(area_uuid=\"62f827ec-ef86-4782-b5c3-88327751d97d\", bid_id = \"2e7866d8-3dg6-49ad-afe8-fd5876a3e679\")","title":"delete_bid()"},{"location":"assets-api/#offer_energy","text":"Places an energy offer to the registered market. This command receives 4 arguments : area_uuid : Universal Unique Identifier of the selected asset energy : energy in kWh price : price in Euro cents replace_existing : if set to TRUE replace all existing bids with a new one Here is an example: self.add_to_batch_commands.offer_energy(area_uuid = \"2e7866d8-34c6-49ad-a388-fd5876a3e679\", energy = 2, price_cents = 60, replace_existing = True)","title":"offer_energy()"},{"location":"assets-api/#offer_energy_rate","text":"Places an energy offer to the registered market. This command receives 4 arguments : area_uuid : Universal Unique Identifier of the selected asset energy : energy in kWh rate : price per volume in Euro cents/kWh replace_existing : if set to TRUE replace all existing offers with a new one Here is an example: self.add_to_batch_commands.offer_energy_rate(area_uuid = \"2e7866d8-34c6-49ad-a388-fd5876a3e679\", energy = 2, rate = 30, replace_existing = True)","title":"offer_energy_rate()"},{"location":"assets-api/#lists_offers","text":"Lists all posted offers on the selected market. This command takes 1 argument: area_uuid which is the Universal Unique Identifier of the selected market. Here is an example: self.add_to_batch_commands.list_offers(area_uuid=\"62f827ec-ef86-4782-b5c3-88327751d97d\")","title":"lists_offers()"},{"location":"assets-api/#delete_offer","text":"Delete an offer posted on the market using its ID. This command receives 2 arguments : area_uuid : Universal Unique Identifier of the selected asset offer_id : ID of the selected offer. If None, all the bids posted by the selected asset will be deleted. Here is an example: self.add_to_batch_commands.delete_offer(area_uuid=\"62f827ec-ef86-4782-b5c3-88327751d97d\", bid_id = \"2e7866d8-3dg6-49ad-afe8-fd5876a3e679\")","title":"delete_offer()"},{"location":"assets-api/#device_info","text":"Get device info (returns required energy for Load devices, available energy for PVs and energy to buy/sell for storage). This command receives 1 argument: area_uuid which is the Universal Unique Identifier of the selected asset self.add_to_batch_commands.device_info(area_uuid=\"62f827ec-ef86-4782-b5c3-88327751d97d\")","title":"device_info()"},{"location":"assets-api/#execute","text":"After adding all the wanted commands in the batch, the API can execute it with the following command: response = self.execute_batch_commands() In return the simulation will provide a detailed response for all commands submitted. Note: The total amount of energy to bid/offer at any point is limited to the energy requirement/available of the asset. Additionally, the price of your bids/offers must be a positive float otherwise it will get rejected by the market.","title":"Execute"},{"location":"assets-api/#api-template-script","text":"A simple trading strategy is available in the template agent . This shows an example of what can be done with this API, and offers a flexible structure, easy to modify to implement custom smart trading strategies. See the TODO flags there to see how you may configure your trading strategy and extract market and asset data. Here , the name of the oracle and the list of the connected devices are defined. If the user is running the API to the UI and automatic is set to True, the script will automatically connect to all assets the user is approved to. The event on_market_cycle is used to gather market information through market_info and assets information, define the trading strategy and place the first bids/offers. The first information to be gathered is the Market Maker price and Feed-in Tariff and calculate the average value between them. These values are required to set the boundaries of the pricing trading strategy. In these lines , the API script stores energy assets information such as the energy requirements for the loads, the energy available for the PVs and the State Of Charge for the storage. This information when aggregated could be valuable when designing a smarter strategy. After that, the API client creates a nested dictionary , containing various information for each asset. First we get the name of the assets and the fees between the assets and the market maker . The Aggregator class has a function that calculates the grid fees along the path between two assets or markets in the grid: calculate_grid_fee . This function takes 3 arguments: start_market_or_device_name : UUID of the started market/asset target_market_or_device_name : UUID of the targeted market/asset fee_type : can either be current_market_fee or last_market_fee These fees should be integrated in the pricing strategy in order to avoid any power outages for the loads and curtailment for the PVs. Lastly in this asset_strategy dictionary, the pricing strategy is defined for each asset individually. This allows assets to have independent strategies depending on their information and location in the grid. The current pricing strategies are deterministic, representing a linear function bounded between the Feed-in Tariff - grid fee (lower boundary) and the Market Maker price + grid fee (upper boundary). Since the API client can post up to 10 bids/offers per market slot, the strategies incrementally ramp up (bids) or down (offers) for a total of 10 prices per energy asset. The final bid/offer price is set at least 2 API available ticks before the end of the market slot length (9th and 10th tick in our case) to make sure that the bids and offers are placed before the market slot . Here are defined the loads , PVs and storages pricing strategies. In these lines , the API script sends the first bid and/or offer for each energy asset. For each of them the API gets the energy requirements (load), available (storage) and energy to buy/sell (storage) through latest_grid_tree_flat.items() (which is the market_info dictionary flattened). For each asset\u2019s bid/offer, the API applies the price defined in the asset_strategy dictionary defined above. Once all the bids/offers commands have been set, the batch is executed . At each on_tick event, the API agent can post new or update or delete existing bids and offers. This allows the API client to update their price strategy until all consumption and generation have been traded. In these lines , the API client updates the existing bids/offers with new prices to optimize trades. The updated energy information is found in latest_grid_tree_flat.items() and the prices for each bid/offer depends on the market slot progression. Once all commands are added to the batch, it is then executed. After that, the on_event_or_response is overwritten. By default we do not perform any operation in this event but the user could add some if needed. For instance the user could record all the trades responses received in that event. Lastly the API script overwrites the on_finish event so that whenever the function is triggered the script stops. If the user wishes to save some information recorded within the API client this would be the opportunity to export them to external files. The rest of the script is used to connect to the energy assets of a running simulation/collaboration/canary network. These lines should work as is and no changes are required. Please find the following tutorial describing the required steps to run the asset API locally and on a collaboration:","title":"API template script"},{"location":"balancing-implementation/","text":"Figure: Structure of Balancing Market in Grid Singularity energy exchange (D3A) Grid Singularity energy exchange (D3A) bottom-up market design allows participants to engage in Local Energy Market (LEM) for energy trading, providing energy balance at a local level. D3A flexibility trading also facilitates the procurement of flexibility locally from participants to assist distribution grid operation in balancing the grid. Assets \u00b6 In the Grid Singularity D3A, balancing has been implemented using: Fast responding non-critical loads to provide load shedding Battery storage Commercial power plants The trading strategies of energy assets like Loads , Storages and Power Plants can be used to balance the grid by placing balancing offers. These assets participate in the balancing market only if they are registered in the Asset Registry . Asset Registry \u00b6 How to register an energy asset in the registry in the the setup file: The balancing asset registry is a dictionary that contains the names of assets as keys and the balancing rates as tuple values: (demand balancing rate, supply balancing rate). asset_registry_dict = { \"H1 General Load\": (33, 35), \"H2 General Load\": (33, 35), \"H1 Storage1\": (33, 35), \"H1 Storage2\": (33, 35), } Balancing Market \u00b6 The present setting is a One-Sided Pay-as-Offer market , which accepts balancing_offers from energy assets and connected hierarchies of balancing_market . balancing_offers could be positive or negative. It also facilitates the balancing_trade . Balancing Agent \u00b6 The balancing agent follows the lead of the spot_market_trade of its lower hierarchy. Whenever there is a trade in the lower hierarchy of spot_market , it will try to secure a share of spot market trades in the balancing market. Constant Parameters \u00b6 The following are the constant parameters related to the balancing market, with defaults available here . ENABLE_BALANCING_MARKET \u2192 (Default: False) (It enables the simulation with Balancing Market) BALANCING_SPOT_TRADE_RATIO \u2192 (Default: 0.2) (It dictates the ratio of spot_market_energy to be traded in balancing market) BALANCING_OFFER_DEMAND_RATIO \u2192 (Default: 0.1) (It dictates the ratio of spot_market_energy to be offered in balancing market as demand_balancing_offer ) BALANCING_OFFER_SUPPLY_RATIO \u2192 (Default: 0.1) (It dictates the ratio of spot_market_energy to be offered in balancing market as supply_balancing_offer ) BALANCING_FLEXIBLE_LOADS_SUPPORT \u2192 (Default: True) (It enables Load Strategy to place supply_balancing_offer (effectively curtailing it's load)) Multiple examples of balancing market setup are available here .","title":"Balancing Market Implementation"},{"location":"balancing-implementation/#assets","text":"In the Grid Singularity D3A, balancing has been implemented using: Fast responding non-critical loads to provide load shedding Battery storage Commercial power plants The trading strategies of energy assets like Loads , Storages and Power Plants can be used to balance the grid by placing balancing offers. These assets participate in the balancing market only if they are registered in the Asset Registry .","title":"Assets"},{"location":"balancing-implementation/#asset-registry","text":"How to register an energy asset in the registry in the the setup file: The balancing asset registry is a dictionary that contains the names of assets as keys and the balancing rates as tuple values: (demand balancing rate, supply balancing rate). asset_registry_dict = { \"H1 General Load\": (33, 35), \"H2 General Load\": (33, 35), \"H1 Storage1\": (33, 35), \"H1 Storage2\": (33, 35), }","title":"Asset Registry"},{"location":"balancing-implementation/#balancing-market","text":"The present setting is a One-Sided Pay-as-Offer market , which accepts balancing_offers from energy assets and connected hierarchies of balancing_market . balancing_offers could be positive or negative. It also facilitates the balancing_trade .","title":"Balancing Market"},{"location":"balancing-implementation/#balancing-agent","text":"The balancing agent follows the lead of the spot_market_trade of its lower hierarchy. Whenever there is a trade in the lower hierarchy of spot_market , it will try to secure a share of spot market trades in the balancing market.","title":"Balancing Agent"},{"location":"balancing-implementation/#constant-parameters","text":"The following are the constant parameters related to the balancing market, with defaults available here . ENABLE_BALANCING_MARKET \u2192 (Default: False) (It enables the simulation with Balancing Market) BALANCING_SPOT_TRADE_RATIO \u2192 (Default: 0.2) (It dictates the ratio of spot_market_energy to be traded in balancing market) BALANCING_OFFER_DEMAND_RATIO \u2192 (Default: 0.1) (It dictates the ratio of spot_market_energy to be offered in balancing market as demand_balancing_offer ) BALANCING_OFFER_SUPPLY_RATIO \u2192 (Default: 0.1) (It dictates the ratio of spot_market_energy to be offered in balancing market as supply_balancing_offer ) BALANCING_FLEXIBLE_LOADS_SUPPORT \u2192 (Default: True) (It enables Load Strategy to place supply_balancing_offer (effectively curtailing it's load)) Multiple examples of balancing market setup are available here .","title":"Constant Parameters"},{"location":"balancing-market/","text":"Definition \u00b6 Electrical power systems are characterized by voltage and frequency and the flow of electricity is a continuous process. Buffering or storing electrical energy at each node is still not feasible, therefore electrical energy needs to be generated exactly at the time of consumption. Differences in supply and demand causes the nominal frequency (50Hz in EU) to deviate. Consequently, supply and demand need to be monitored in real time to implement adjustments to maintain equilibrium and nominal frequency. Significant deviation from the nominal leads to cascading effect culminating in a blackout . Transmission system operators (TSOs) oversee fast, flexible, fossil fuel-based generation units and demand response service from large consumers, ensuring the continuation of operation during significant transient faults in the energy system. These generators form the basis of frequency control strategies used in balancing these electrical systems. Each control strategy has specific purposes and features and can be categorized in three groups, as shown in the figure below. Primary Control (Frequency Containment Reserve - FCR) Secondary Control (Automatic Frequency Restoration Reserves - aFRR) Tertiary Control (Manual Frequency Restoration Reserves - mFRR) Figure: The three tiers of grid control and its activation structure In conventional grid structures: \u00b6 Primary control is an automatic function that is almost instantaneously activated to stabilise the frequency drops/spikes. It is the fastest type of frequency control with a response time of a few seconds and operates using a joint process involving all TSOs of the synchronous area. This is shown in the figure below. For example, if there is an increase in demand, the energy used to compensate for this demand comes from the kinetic energy stored in large rotating synchronous generators that start decreasing its velocity. This is referred to as Inertial response . For the generators to recover the speed, the speed controller of each generator acts to increase the generator power to clear the imbalance. Within a period of 30 seconds, each generating unit is able to generate the required power and stabilise this production for at least 15 minutes or depending on the requirements of the TSO within the synchronous region. Primary control is done using generation plants that are connected to the high voltage power supply with the exception of renewable energy sources which are non-schedulable due to its intermittent nature. Figure: Recovery of the system from a contingency event and action by primary frequency control (PFR) Secondary control is performed automatically by all the generators to restore the nominal frequency, the power exchanges and reserve of the generators used in primary control. The generators involved in this regulation function through dedicated reserve power that are set in conjunction with central controllers. The reserve control power is negotiated in a contract conjunction with the TSO and is a percentage of the maximum available power with a predefined minimum value to ensure that it can be dispatched whenever needed. This service is remunerated according to the set contracts. Tertiary control is not an automatic function and is executed upon request by the grid operator. The reserve margins used for the secondary control are restored through tertiary control. The differences between the primary, secondary and tertiary frequency control is the time the production and response can be activated, and the remuneration for each. Primary frequency control is symmetrical as the capacity for control has been scheduled and usually balances between ramping up and down the production and therefore not remunerated. Secondary and tertiary control are not symmetrical as the capacity can be used only for ramping up or down the production to restore the frequency and are remunerated. Review of the three levels of regulation \u00b6 Response Time Duration Time Operation Purpose Primary Control 10-30 Seconds 15 Minutes Automatic Act in case of frequency variation in order to stabilize frequency value Secondary Control 200 Seconds 120 minutes Automatic Act to bring back frequency value to the nominal value and restore the power reserve of the generators used for the primary frequency control Tertiary Control 15 Minutes Indicated by TSO Upon Request Act to restore power reserves of the generators used for the secondary frequency control Table: Main features of frequency control strategies In our transactive energy low voltage grid structure primary, secondary and tertiary control are controlled by an area controller called the balancing agent. Area control structure of market consisting of all three tiers of control (source: Martin Fornage, A generalized transactive energy based framework: Enphase Energy. Powerpoint presentation 2015) The balancing agent monitors the health of the system and is in control of all its allocated resources. It also had the ability to control the physical connect and disconnect from upstream and downstream resources according to the type of control required. Primary control happens simultaneously as the spot market through a droop curve. Grid forming assets have different droop curves based on their behaviour (Loads, Storage, PV) which are used to keep the voltage and frequency towards nominal in case of a deviation. Local balancing is therefore done through primary control. Secondary control (Inertia Control) is done through a time schedule. The schedule is received from the upper tertiary control or from a ledger. Secondary balancing agents adjust the primary balancing agents resources within its market by disconnecting and connecting them in case of failure of upstream structure or failure to meet the schedule. Tertiary control negotiates the schedules upstream or downstream at lowest cost of operation and provides a marketplace for energy in and out of the market area. The inputs of the tertiary control are the bids, offers and error signals from secondary control. The outputs are the schedules to resources.","title":"Balancing Market Structure"},{"location":"balancing-market/#definition","text":"Electrical power systems are characterized by voltage and frequency and the flow of electricity is a continuous process. Buffering or storing electrical energy at each node is still not feasible, therefore electrical energy needs to be generated exactly at the time of consumption. Differences in supply and demand causes the nominal frequency (50Hz in EU) to deviate. Consequently, supply and demand need to be monitored in real time to implement adjustments to maintain equilibrium and nominal frequency. Significant deviation from the nominal leads to cascading effect culminating in a blackout . Transmission system operators (TSOs) oversee fast, flexible, fossil fuel-based generation units and demand response service from large consumers, ensuring the continuation of operation during significant transient faults in the energy system. These generators form the basis of frequency control strategies used in balancing these electrical systems. Each control strategy has specific purposes and features and can be categorized in three groups, as shown in the figure below. Primary Control (Frequency Containment Reserve - FCR) Secondary Control (Automatic Frequency Restoration Reserves - aFRR) Tertiary Control (Manual Frequency Restoration Reserves - mFRR) Figure: The three tiers of grid control and its activation structure","title":"Definition"},{"location":"balancing-market/#in-conventional-grid-structures","text":"Primary control is an automatic function that is almost instantaneously activated to stabilise the frequency drops/spikes. It is the fastest type of frequency control with a response time of a few seconds and operates using a joint process involving all TSOs of the synchronous area. This is shown in the figure below. For example, if there is an increase in demand, the energy used to compensate for this demand comes from the kinetic energy stored in large rotating synchronous generators that start decreasing its velocity. This is referred to as Inertial response . For the generators to recover the speed, the speed controller of each generator acts to increase the generator power to clear the imbalance. Within a period of 30 seconds, each generating unit is able to generate the required power and stabilise this production for at least 15 minutes or depending on the requirements of the TSO within the synchronous region. Primary control is done using generation plants that are connected to the high voltage power supply with the exception of renewable energy sources which are non-schedulable due to its intermittent nature. Figure: Recovery of the system from a contingency event and action by primary frequency control (PFR) Secondary control is performed automatically by all the generators to restore the nominal frequency, the power exchanges and reserve of the generators used in primary control. The generators involved in this regulation function through dedicated reserve power that are set in conjunction with central controllers. The reserve control power is negotiated in a contract conjunction with the TSO and is a percentage of the maximum available power with a predefined minimum value to ensure that it can be dispatched whenever needed. This service is remunerated according to the set contracts. Tertiary control is not an automatic function and is executed upon request by the grid operator. The reserve margins used for the secondary control are restored through tertiary control. The differences between the primary, secondary and tertiary frequency control is the time the production and response can be activated, and the remuneration for each. Primary frequency control is symmetrical as the capacity for control has been scheduled and usually balances between ramping up and down the production and therefore not remunerated. Secondary and tertiary control are not symmetrical as the capacity can be used only for ramping up or down the production to restore the frequency and are remunerated.","title":"In conventional grid structures:"},{"location":"balancing-market/#review-of-the-three-levels-of-regulation","text":"Response Time Duration Time Operation Purpose Primary Control 10-30 Seconds 15 Minutes Automatic Act in case of frequency variation in order to stabilize frequency value Secondary Control 200 Seconds 120 minutes Automatic Act to bring back frequency value to the nominal value and restore the power reserve of the generators used for the primary frequency control Tertiary Control 15 Minutes Indicated by TSO Upon Request Act to restore power reserves of the generators used for the secondary frequency control Table: Main features of frequency control strategies In our transactive energy low voltage grid structure primary, secondary and tertiary control are controlled by an area controller called the balancing agent. Area control structure of market consisting of all three tiers of control (source: Martin Fornage, A generalized transactive energy based framework: Enphase Energy. Powerpoint presentation 2015) The balancing agent monitors the health of the system and is in control of all its allocated resources. It also had the ability to control the physical connect and disconnect from upstream and downstream resources according to the type of control required. Primary control happens simultaneously as the spot market through a droop curve. Grid forming assets have different droop curves based on their behaviour (Loads, Storage, PV) which are used to keep the voltage and frequency towards nominal in case of a deviation. Local balancing is therefore done through primary control. Secondary control (Inertia Control) is done through a time schedule. The schedule is received from the upper tertiary control or from a ledger. Secondary balancing agents adjust the primary balancing agents resources within its market by disconnecting and connecting them in case of failure of upstream structure or failure to meet the schedule. Tertiary control negotiates the schedules upstream or downstream at lowest cost of operation and provides a marketplace for energy in and out of the market area. The inputs of the tertiary control are the bids, offers and error signals from secondary control. The outputs are the schedules to resources.","title":"Review of the three levels of regulation"},{"location":"blockchain/","text":"Purpose \u00b6 Grid Singularity energy exchange engine (D3A) has been designed so that it does not require blockchain technology, but that it can benefit from this technology to provide enhanced functionality. Grid Singularity aims to integrate blockchain for specific benefits: Decentralisation and transparency : blockchain can be used to create decentralized registry and identity. By doing so, the privacy and security of users are enhanced. Data ownership : End-users would have complete control over their data access and use Payments : Trades cleared on the market will be recorded on the chain and the payments executed. While the privacy of users will be preserved, the system would be more transparent. Degrees of Freedom: Bids and offers can be tagged with validated attributes to enable trading degrees of freedom such as preferred trading partner, energy source selection, or location restrictions on trades Asset validation : energy assets, smart meters, and entities can be validated using tools like the Energy Web Switchboard. The Energy Web Chain is the blockchain of choice for Grid Singularity D3A future blockchain implementation. Grid Singularity, an energy technology startup, and the Rocky Mountain Institute, a nonprofit clean technology organisation, jointly founded the Energy Web Foundation (EWF) in January 2017. EWF is a nonprofit foundation gathering an ecosystem of over 100 energy corporations and startups with a shared, public blockchain platform, the Energy Web Chain. While Grid Singularity has significantly contributed to EWF development and the launch of the Energy Web Chain, its role today is supervisory and advisory, with two Grid Singularity representatives serving on the EWF\u2019s Foundation Council . At present, D3A blockchain integration is used just for simulated transactions and it is based on Substrate . We are also in the process of integrating with the Energy Web Switchboard , which will be used as a decentralized asset registry . In the future we plan to move to full implementation on the Energy Web Chain, benefiting from Polkadot\u2019s scaling solution. The current basic blockchain integration uses Substrate, which allows modular business logic to be built directly in the blockchain and facilitates a high transaction throughput. Substrate has components called pallets, where each pallet can represent different functionality, such as smart contracts, storage, auctions, and more . Currently, our integration includes a storage pallet that provides immutable storage of executed transactions, and additional functionalities will continue to be actively developed. Blockchain can optionally be enabled on simulations running locally with the backend code base. There are three configuration parameters. The command-line flag is --enable-bc , used to enable blockchain operations. The two other parameters are the mnemonic to restore your key and interact with the blockchain, and the ENABLE_SUBSTRATE parameter described in the steps below. Connecting to Grid Singularity node \u00b6 https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fcanvas-node.dev.gridsingularity.com When you go to the endpoint, you will see the standard interface. That\u2019s the easiest point of interaction with the node, where you can call extrinsics, upload contracts, deploy them, test their functions, send funds and more. Simulating Grid Singularity local energy markets on Substrate \u00b6 Wallet \u00b6 Ensure that you have the Polkadot Chrome extension (it is a browser extension that allows you to manage accounts for any Substrate-based blockchain). Create an account and save your seed phrase. You will need to save \"your twelve words\" mnemonic to be able to restore your key in general, and later to pass it the models/market/blockchain_utils.py in order to call the contracts on-chain from python code. Make sure never to push your mnemonic to GitHub. Balance \u00b6 If you want to send a transaction manually or through Grid Singularity D3A in the development chain, you need to pay transaction fees ( gas ), which requires that you have funds in your wallet. In the Polkadot User Interface, go to Network \u2192 Accounts where you will see a list of pre-funded addresses called Alice, Bob, and so on. There you can send funds to your newly generated address to be able to pay for the gas. Sending 10 Units will suffice for running hundreds of simulations. These pre-funded accounts serve as a faucet as they do not represent real financial value and the transactions are simulated. Test pallet calls \u00b6 It is possible to manually test the Developer \u2192 Extrinsics \u2192 tradestorage in the UI. You can choose the prefunded addresses as the buyer (Alice) and the seller (Bob). Set a small amount e.g. 1 and rate (e.g.12) (rate here is the price at which the trade is executed). Trade ID is a bytes vector (e.g. 0x1234 ). If the extrinsic hash is successfully submitted, you will see a success message pop up in the top right corner of the UI. The Polkadot user interface does not allow you to directly go to that extrinsic hash, but you can go to Network and find the latest block. You may have to go to its parent or further to see the extrinsic hash. Running Grid Singularity D3A with Substrate \u00b6 Go to src/d3a/blockchain/constants.py and set ENABLE_SUBSTRATE = True and add your mnemonic. That will allow all the blockchain dependencies to be installed with: fab sync Each transaction in the simulation triggers a call to the pallet. Currently, the buyer and the seller are default addresses. In addition to the buyer and seller, the trade structure has a trade ID, energy quantity, and rate. Following D3A\u2019s integration with the decentralized identity registry (Energy Web Switchboard), the addresses will be actual user accounts. In the terminal, you should see the extrinsic hash and the block hash. 17:39:37.466 WARNING ( 333) d3a.d3a_core.simulation : Slot 1 of 96 - (1.0%) 0.00 second elapsed, ETA: 0.01 second 17:39:41.974 INFO ( 122) root : Extrinsic '0xe1357be7db683e0f3f85e101ea017da10fcaa63310e4dc7040e505cad9ac1a0a' sent and included in block '0x2199d0870583183e6f2c591b66e9a1a9cb2399b7b3ed21b21c3804c3cfcf730f' 17:39:41.975 INFO ( 271) d3a.models.market.one_sided : [TRADE] [Grid] [2021-01-26T00:00] {7f15aa} [origin: H1 Storage2 -> Cell Tower] [IAA House 1 -> Cell Tower] 0.025 kWh @ 0.7500000000000001 30.0 db09b600-22a9-4feb-ae4d-620cb6247702 [fee: 0.0 cts.] The block hash will allow you to find your extrinsic hash, as in this example . View events \u2192 tradestorage.TradeMapStored (this event is triggered every time we call the pallet\u2019s store trade map function).","title":"Blockchain Integration"},{"location":"blockchain/#purpose","text":"Grid Singularity energy exchange engine (D3A) has been designed so that it does not require blockchain technology, but that it can benefit from this technology to provide enhanced functionality. Grid Singularity aims to integrate blockchain for specific benefits: Decentralisation and transparency : blockchain can be used to create decentralized registry and identity. By doing so, the privacy and security of users are enhanced. Data ownership : End-users would have complete control over their data access and use Payments : Trades cleared on the market will be recorded on the chain and the payments executed. While the privacy of users will be preserved, the system would be more transparent. Degrees of Freedom: Bids and offers can be tagged with validated attributes to enable trading degrees of freedom such as preferred trading partner, energy source selection, or location restrictions on trades Asset validation : energy assets, smart meters, and entities can be validated using tools like the Energy Web Switchboard. The Energy Web Chain is the blockchain of choice for Grid Singularity D3A future blockchain implementation. Grid Singularity, an energy technology startup, and the Rocky Mountain Institute, a nonprofit clean technology organisation, jointly founded the Energy Web Foundation (EWF) in January 2017. EWF is a nonprofit foundation gathering an ecosystem of over 100 energy corporations and startups with a shared, public blockchain platform, the Energy Web Chain. While Grid Singularity has significantly contributed to EWF development and the launch of the Energy Web Chain, its role today is supervisory and advisory, with two Grid Singularity representatives serving on the EWF\u2019s Foundation Council . At present, D3A blockchain integration is used just for simulated transactions and it is based on Substrate . We are also in the process of integrating with the Energy Web Switchboard , which will be used as a decentralized asset registry . In the future we plan to move to full implementation on the Energy Web Chain, benefiting from Polkadot\u2019s scaling solution. The current basic blockchain integration uses Substrate, which allows modular business logic to be built directly in the blockchain and facilitates a high transaction throughput. Substrate has components called pallets, where each pallet can represent different functionality, such as smart contracts, storage, auctions, and more . Currently, our integration includes a storage pallet that provides immutable storage of executed transactions, and additional functionalities will continue to be actively developed. Blockchain can optionally be enabled on simulations running locally with the backend code base. There are three configuration parameters. The command-line flag is --enable-bc , used to enable blockchain operations. The two other parameters are the mnemonic to restore your key and interact with the blockchain, and the ENABLE_SUBSTRATE parameter described in the steps below.","title":"Purpose"},{"location":"blockchain/#connecting-to-grid-singularity-node","text":"https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fcanvas-node.dev.gridsingularity.com When you go to the endpoint, you will see the standard interface. That\u2019s the easiest point of interaction with the node, where you can call extrinsics, upload contracts, deploy them, test their functions, send funds and more.","title":"Connecting to Grid Singularity node"},{"location":"blockchain/#simulating-grid-singularity-local-energy-markets-on-substrate","text":"","title":"Simulating Grid Singularity local energy markets on Substrate"},{"location":"blockchain/#wallet","text":"Ensure that you have the Polkadot Chrome extension (it is a browser extension that allows you to manage accounts for any Substrate-based blockchain). Create an account and save your seed phrase. You will need to save \"your twelve words\" mnemonic to be able to restore your key in general, and later to pass it the models/market/blockchain_utils.py in order to call the contracts on-chain from python code. Make sure never to push your mnemonic to GitHub.","title":"Wallet"},{"location":"blockchain/#balance","text":"If you want to send a transaction manually or through Grid Singularity D3A in the development chain, you need to pay transaction fees ( gas ), which requires that you have funds in your wallet. In the Polkadot User Interface, go to Network \u2192 Accounts where you will see a list of pre-funded addresses called Alice, Bob, and so on. There you can send funds to your newly generated address to be able to pay for the gas. Sending 10 Units will suffice for running hundreds of simulations. These pre-funded accounts serve as a faucet as they do not represent real financial value and the transactions are simulated.","title":"Balance"},{"location":"blockchain/#test-pallet-calls","text":"It is possible to manually test the Developer \u2192 Extrinsics \u2192 tradestorage in the UI. You can choose the prefunded addresses as the buyer (Alice) and the seller (Bob). Set a small amount e.g. 1 and rate (e.g.12) (rate here is the price at which the trade is executed). Trade ID is a bytes vector (e.g. 0x1234 ). If the extrinsic hash is successfully submitted, you will see a success message pop up in the top right corner of the UI. The Polkadot user interface does not allow you to directly go to that extrinsic hash, but you can go to Network and find the latest block. You may have to go to its parent or further to see the extrinsic hash.","title":"Test pallet calls"},{"location":"blockchain/#running-grid-singularity-d3a-with-substrate","text":"Go to src/d3a/blockchain/constants.py and set ENABLE_SUBSTRATE = True and add your mnemonic. That will allow all the blockchain dependencies to be installed with: fab sync Each transaction in the simulation triggers a call to the pallet. Currently, the buyer and the seller are default addresses. In addition to the buyer and seller, the trade structure has a trade ID, energy quantity, and rate. Following D3A\u2019s integration with the decentralized identity registry (Energy Web Switchboard), the addresses will be actual user accounts. In the terminal, you should see the extrinsic hash and the block hash. 17:39:37.466 WARNING ( 333) d3a.d3a_core.simulation : Slot 1 of 96 - (1.0%) 0.00 second elapsed, ETA: 0.01 second 17:39:41.974 INFO ( 122) root : Extrinsic '0xe1357be7db683e0f3f85e101ea017da10fcaa63310e4dc7040e505cad9ac1a0a' sent and included in block '0x2199d0870583183e6f2c591b66e9a1a9cb2399b7b3ed21b21c3804c3cfcf730f' 17:39:41.975 INFO ( 271) d3a.models.market.one_sided : [TRADE] [Grid] [2021-01-26T00:00] {7f15aa} [origin: H1 Storage2 -> Cell Tower] [IAA House 1 -> Cell Tower] 0.025 kWh @ 0.7500000000000001 30.0 db09b600-22a9-4feb-ae4d-620cb6247702 [fee: 0.0 cts.] The block hash will allow you to find your extrinsic hash, as in this example . View events \u2192 tradestorage.TradeMapStored (this event is triggered every time we call the pallet\u2019s store trade map function).","title":"Running Grid Singularity D3A with Substrate"},{"location":"canary-network/","text":"The Grid Singularity Canary Test Network (CN) is the first peer-to-peer energy exchange with live energy asset data and real-time trading . At the current stage, CN acts as a uni-directional bridge between the physical and digital world, reading real consumption and generation data from real energy assets in real-time, while simulating trading with the grid\u2019s digital twins. Flexible assets\u2019 digital twins such as storage are unbundled from their physical ones, to simulate the benefits of Local Energy Markets without real world energy and financial transactions. All energy trades in the GSy Canary Test Network are simulated, meaning that no real-world financial or energy transaction occurs and flexible assets such as batteries may physically charge or discharge at different times than their simulated behaviour in the Canary Network. The GSy Canary Test Network runs at real time, meaning that assets send their actual energy usage through the Asset API once every 15 minutes . This mimics how deployed exchanges will operate, but provides only a few sets of data points every hour, requiring iterations of experiments to which doesn\u2019t meet the needs of the ongoing research efforts to determine effective market, grid fee, and agent designs. Determining the mechanics for deployable markets require frequent iterations and experimentation. Grid Singularity simulations allow for energy exchanges to be run at warp speed, meaning one week of trading can be simulated and analysed in less than two hours. This functionality allows for rapid prototyping of grid models and experimental setups . CN is designed to host an iterative process to test new ideas in a safe environment, closest as possible to reality. The following link will direct you to the Grid Singularity Canary Test Network tutorial .","title":"Canary Test Network"},{"location":"clearing-purpose/","text":"In a local energy market (LEM), bids and offers are matched according to the selected clearing mechanism. Studies show that different clearing mechanisms offer diverse benefits and limitations relating to market efficiency , fairness , and user choices . Grid Singularity\u2019s energy exchange engine (D3A) currently offers three types of clearing mechanisms: One-Sided Pay-as-Offer Market Two-Sided Pay-as-Bid Market Two-Sided Pay-as-Clear Market","title":"Clearing Mechanism Types"},{"location":"cloud-service-guide/","text":"Guide to setup and run an API agent from a cloud based service \u00b6 Amazon Web Services (AWS) \u00b6 Step 1: Set up an instance \u00b6 Login to your AWS account. If you don\u2019t have one, you can create one, the free plan is sufficient. Create a virtual machine. Select an AMI . We strongly recommend using Ubuntu Server 20.04 LTS (HVM), SSD Volume Type Choose instance type t2.micro 1vcpus and 1GiB and click on review and launch Create a new ssh key and download it on your local machine. The key file\u2019s format is .pem Now you need to copy your scripts/files from your local computer onto your AWS instance. To do that you need to connect to your instance by using the ssh key and your public DNS. You can find the DNS of your instance by selecting your instance and looking at the summary First you need to make sure your key is not publicly available on your machine. Run the following command chmod 400 path_to/mykey.pem Step 2: Upload relevant files onto the instance \u00b6 To copy a file into your AWS instance please run the equivalent command (with your own information) scp -i path_to_ssh_key.pem path_to_file username@public_DNS:/path_to_copy The username can be found after clicking on connect. The default username will depend on the instance platform you are using. If you are using Linux, \u201cubuntu\u201d will be the default username. Additionally we recommend copying your files into the home directory of your instance /home/ubuntu . Here is an example of command scp -i Desktop/mykey.pem myscript.py ubuntu@ec2-18-188-221-121.us-east-2.compute.amazonaws.com:/home/ubuntu/ Step 3: Connect to the instance \u00b6 Once you have copied all necessary files onto you AWS instance you can connect to your instance with 2 ways Directly with the AWS terminal cli that you can access by clicking on connect on your EC2 instance connect With your local terminal cli (recommended) To connect to your instance from your local terminal you just need to run the following command with your equivalent information ssh -i path_to/mykey.pem username@public_DNS Example ssh -i Desktop/mykey.pem ubuntu@ec2-18-188-221-121.us-east-2.compute.amazonaws.com Once connected, go into the directory you have previously sent your files. If you have copied them in /home/ubuntu , just run the following command cd /home/ubuntu You can list all the files in the directory, to confirm that your files are correctly copied onto the instance by running ls Step 4: Initialize the instance's environment and install Grid Singularity Client \u00b6 Update and install all required package on your AWS instance Update your sudo sudo apt update Install python3 pip sudo apt install python3-pip Add deadnakes to your system source sudo add-apt-repository ppa:deadsnakes/ppa Install python 3.6 sudo apt-get install python3.6 Install virtual environment sudo apt install python3-virtualenv Create a virtual environment with python 3.6 virtualenv /tmp/d3a --python=/usr/bin/python3.6 Activate your virtual environment source /tmp/d3a/bin/activate Install d3a api client pip3 install git+https://github.com/gridsingularity/d3a-api-client.git Step 5: Install screen and run the API agent \u00b6 To be able to run the script indefinitely on your AWS instance you need to install Linux Screen (that allows to have multiple screen within your terminal) with the following command sudo apt-get install screen Create a new screen screen -S screen_name Run your python script python3 assets.py To detach from the current screen session Ctr+a+d If you want to log back in the relevant screen run screen -r screen_name Once you are detached for the running screen you are able to close your terminal and your script will continue to run indefinitely on your AWS instance","title":"API agent on cloud"},{"location":"cloud-service-guide/#guide-to-setup-and-run-an-api-agent-from-a-cloud-based-service","text":"","title":"Guide to setup and run an API agent from a cloud based service"},{"location":"cloud-service-guide/#amazon-web-services-aws","text":"","title":"Amazon Web Services (AWS)"},{"location":"cloud-service-guide/#step-1-set-up-an-instance","text":"Login to your AWS account. If you don\u2019t have one, you can create one, the free plan is sufficient. Create a virtual machine. Select an AMI . We strongly recommend using Ubuntu Server 20.04 LTS (HVM), SSD Volume Type Choose instance type t2.micro 1vcpus and 1GiB and click on review and launch Create a new ssh key and download it on your local machine. The key file\u2019s format is .pem Now you need to copy your scripts/files from your local computer onto your AWS instance. To do that you need to connect to your instance by using the ssh key and your public DNS. You can find the DNS of your instance by selecting your instance and looking at the summary First you need to make sure your key is not publicly available on your machine. Run the following command chmod 400 path_to/mykey.pem","title":"Step 1: Set up an instance"},{"location":"cloud-service-guide/#step-2-upload-relevant-files-onto-the-instance","text":"To copy a file into your AWS instance please run the equivalent command (with your own information) scp -i path_to_ssh_key.pem path_to_file username@public_DNS:/path_to_copy The username can be found after clicking on connect. The default username will depend on the instance platform you are using. If you are using Linux, \u201cubuntu\u201d will be the default username. Additionally we recommend copying your files into the home directory of your instance /home/ubuntu . Here is an example of command scp -i Desktop/mykey.pem myscript.py ubuntu@ec2-18-188-221-121.us-east-2.compute.amazonaws.com:/home/ubuntu/","title":"Step 2: Upload relevant files onto the instance"},{"location":"cloud-service-guide/#step-3-connect-to-the-instance","text":"Once you have copied all necessary files onto you AWS instance you can connect to your instance with 2 ways Directly with the AWS terminal cli that you can access by clicking on connect on your EC2 instance connect With your local terminal cli (recommended) To connect to your instance from your local terminal you just need to run the following command with your equivalent information ssh -i path_to/mykey.pem username@public_DNS Example ssh -i Desktop/mykey.pem ubuntu@ec2-18-188-221-121.us-east-2.compute.amazonaws.com Once connected, go into the directory you have previously sent your files. If you have copied them in /home/ubuntu , just run the following command cd /home/ubuntu You can list all the files in the directory, to confirm that your files are correctly copied onto the instance by running ls","title":"Step 3: Connect to the instance"},{"location":"cloud-service-guide/#step-4-initialize-the-instances-environment-and-install-grid-singularity-client","text":"Update and install all required package on your AWS instance Update your sudo sudo apt update Install python3 pip sudo apt install python3-pip Add deadnakes to your system source sudo add-apt-repository ppa:deadsnakes/ppa Install python 3.6 sudo apt-get install python3.6 Install virtual environment sudo apt install python3-virtualenv Create a virtual environment with python 3.6 virtualenv /tmp/d3a --python=/usr/bin/python3.6 Activate your virtual environment source /tmp/d3a/bin/activate Install d3a api client pip3 install git+https://github.com/gridsingularity/d3a-api-client.git","title":"Step 4: Initialize the instance's environment and install Grid Singularity Client"},{"location":"cloud-service-guide/#step-5-install-screen-and-run-the-api-agent","text":"To be able to run the script indefinitely on your AWS instance you need to install Linux Screen (that allows to have multiple screen within your terminal) with the following command sudo apt-get install screen Create a new screen screen -S screen_name Run your python script python3 assets.py To detach from the current screen session Ctr+a+d If you want to log back in the relevant screen run screen -r screen_name Once you are detached for the running screen you are able to close your terminal and your script will continue to run indefinitely on your AWS instance","title":"Step 5: Install screen and run the API agent"},{"location":"collaboration/","text":"Collaboration is a type of simulation in the Grid Singularity UI that allows multiple users to participate in the same environment. These users can act in a collaborative or competitive way, aiming to optimize specific metrics. Users can connect through the API client to actively engage in the collaboration. User roles \u00b6 Exchange Operator \u00b6 The exchange operator (EO) is responsible for building the digital twin of the electrical grid , including energy assets and markets in the modelling page. Once the setup is complete, the EO facilitates the approval of other users to register to manage a set of markets and energy assets, and subsequently launches the collaboration.The EO is also in charge of expanding the grid (with events ) or registering new users desiring to connect to the exchange over the course of a simulation. Grid Operator \u00b6 The grid operator role is designed specifically for Distribution System Operators (DSOs) and Transmission System Operators (TSOs). Those users have the possibility to register to different markets, on different grid levels in the collaboration. Once registered and approved by the EO, they can manage the relevant markets by using the Grid Operator API to change grid fees in order to influence trades to optimize specific metrics (e.g. peak percentage ). Researcher \u00b6 The researcher role is designed to represent smart meters, PV and battery vendors, community leaders, energy management companies, data scientists and aggregators in collaborations. Researchers can claim assets ( Load , PV and Storage ) and, once approved by the Exchange Operator, are responsible for buying and selling energy for the assets they manage on markets through the Asset API. How to connect \u00b6 If you wish to connect to a collaboration in the framework of an event (e.g. Energy Singularity Chaos Experiment ) or to a Canary Test Network in the framework of a live running exchange please follow these steps: Login on the User-Interface Go to the Collaborations (or Canary Test Network page), where you will see a list of all active collaborations. For each, any user may view the settings and the grid setup. If the collaboration the user wishes to join is public, they can click on Registry and Scoreboard . On this page, each market and asset of the collaboration is listed. The user can apply to manage the trading strategies of assets or the grid fee strategy of markets on the Registry. The EO is able to either approve or deny the request. Once approved, the user can start the API script and wait until the EO starts the collaboration / canary network, when trading will begin.","title":"Collaboration Tool"},{"location":"collaboration/#user-roles","text":"","title":"User roles"},{"location":"collaboration/#exchange-operator","text":"The exchange operator (EO) is responsible for building the digital twin of the electrical grid , including energy assets and markets in the modelling page. Once the setup is complete, the EO facilitates the approval of other users to register to manage a set of markets and energy assets, and subsequently launches the collaboration.The EO is also in charge of expanding the grid (with events ) or registering new users desiring to connect to the exchange over the course of a simulation.","title":"Exchange Operator"},{"location":"collaboration/#grid-operator","text":"The grid operator role is designed specifically for Distribution System Operators (DSOs) and Transmission System Operators (TSOs). Those users have the possibility to register to different markets, on different grid levels in the collaboration. Once registered and approved by the EO, they can manage the relevant markets by using the Grid Operator API to change grid fees in order to influence trades to optimize specific metrics (e.g. peak percentage ).","title":"Grid Operator"},{"location":"collaboration/#researcher","text":"The researcher role is designed to represent smart meters, PV and battery vendors, community leaders, energy management companies, data scientists and aggregators in collaborations. Researchers can claim assets ( Load , PV and Storage ) and, once approved by the Exchange Operator, are responsible for buying and selling energy for the assets they manage on markets through the Asset API.","title":"Researcher"},{"location":"collaboration/#how-to-connect","text":"If you wish to connect to a collaboration in the framework of an event (e.g. Energy Singularity Chaos Experiment ) or to a Canary Test Network in the framework of a live running exchange please follow these steps: Login on the User-Interface Go to the Collaborations (or Canary Test Network page), where you will see a list of all active collaborations. For each, any user may view the settings and the grid setup. If the collaboration the user wishes to join is public, they can click on Registry and Scoreboard . On this page, each market and asset of the collaboration is listed. The user can apply to manage the trading strategies of assets or the grid fee strategy of markets on the Registry. The EO is able to either approve or deny the request. Once approved, the user can start the API script and wait until the EO starts the collaboration / canary network, when trading will begin.","title":"How to connect"},{"location":"constant-fees/","text":"The constant grid fee is a market based fee, defined in \u20ac/kWh and added to each trade that is cleared, as shown in the figure below. The rate of a bid or offer changes as that bid or offer is propagated into different markets . The offer rate increases to account for the added fees for the relevant market, ensuring that the seller receives a revenue equal or greater than the original offer. The bid rate decreases for the same reason. Example Calculation in One-Sided Pay-as-Offer Market \u00b6 In an One-Sided Pay-as-Offer market, there are no bids, only offers. Offers are propagated throughout the markets in the hierarchy shown in the figure above. Grid fees are accounted for when an offer is forwarded to the higher market, adding that market\u2019s grid fees to any previously accumulated fees. The formula to calculate the new offer rate when placing an offer to a higher market is the following: offer_rate_after_fees (\u20ac/kWh) = offer_rate (\u20ac/kWh) + grid_fee (\u20ac/kWh) If the offer is not purchased after two ticks , it is moved into the next market, with the total rate incremented by the amount of that market's grid fee. In the example above, the PV offer of 0.10 \u20ac/kWh is first placed into the House 2 Market where it gains zero fees. Then it moves into the Neighborhood 2 Market, gaining a fee of 0.01 \u20ac/kWh to become 0.11 \u20ac/kWh. Then, if not purchased, it moves into the Grid Market, gaining a fee of 0.02 \u20ac/kWh to become 0.13 \u20ac/kWh. Continuing into the Neighborhood 1 Market, the offer gains a fee of 0.01 \u20ac/kWh to become 0.14 \u20ac/kWh. Continuing into the House 1 Market, the offer gains zero fees. The Load ultimately buys the offer in the House 1 Market at the Clearing Rate of 0.14 \u20ac/kWh. The trade price is calculated by adding the original offer rate ( 0.10 \u20ac/kWh ) and the total fees ( (0.01+0.02+0.01) = 0.04 \u20ac/kWh ), then multiplying by the amount of energy traded ( 1 kWh ) to yield the Trade Price of 0.14\u20ac. The Load pays the Trade Price of 0.14\u20ac, which includes 0.10\u20ac revenue for the PV, 0.01\u20ac fees for the Neighborhood Market 1, 0.02\u20ac fees for the Grid Market, and 0.01\u20ac fees for the Neighborhood Market 2. Since the market type is pay-as-offer, the offer rate is used as the clearing rate. The grid fees are added to the offer rate to determine the trade rate and therefore the trade price in each market. The following formula is used: supply_side_fee (\u20ac/kWh) = forwarded_offer_rate (\u20ac/kWh) - original_offer_rate (\u20ac/kWh) trade_rate (\u20ac/kWh) = clearing rate (\u20ac/kWh) trade_price (\u20ac) = energy (kWh) * trade_rate (\u20ac/kWh) For the provided example, the trade price for each market is: Market_trade_price (\u20ac) = (original_offer_rate (\u20ac/kWh) + supply_side_fee (\u20ac/kWh)) * energy (kWh) Grid Market = (0.10 + 0.03)*1 = 0.13 Neighborhood 2 Market = (0.10 + 0.01)*1 = 0.11 Neighborhood 1 Market = (0.10 + 0.04)*1 = 0.14 House 1 Market = (0.10 + 0.04)*1 = 0.14 House 2 Market = (0.10 + 0)*1 = 0.10 Example Calculation in Two-Sided Pay-as-Bid Market \u00b6 In the Two-Sided Pay-as-Bid market, there are both bids and offers, and both are propagated through the markets in the hierarchy. If a bid or offer is not matched after two ticks , it is moved into the next market. In order to prevent the double accounting of a market's grid fee when a bid and an offer are matched in that market, market fees are added to offers when they enter a new market (target market), and they are subtracted from bids when they leave a market (source market) and enter another one. The formula for propagating the offers is the same as for the one-sided market : offer_rate_after_fees (\u20ac/kWh) = offer_rate (\u20ac/kWh) + grid_fee (\u20ac/kWh) The IAA subtracts the fees from the bid before propagating the bid to the higher market, based on the following formula: bid_rate_after_fees (\u20ac/kWh) = bid_rate (\u20ac/kWh) - grid_fee (\u20ac/kWh) In the case of a Two-Sided Pay-as-Bid market, the offer is moved into the Grid Market by the same mechanism as in the One-Sided Pay-as-Offer market. The bid of 0.30 \u20ac/kWh is placed into the House 1 Market where there are zero fees. If it is not purchased after two ticks, it is moved into the Neighborhood 1 Market. As explained above, only the fees from the source market are added, which are zero in this case. Hence the bid rate remains 0.30 \u20ac/kWh. Next, the bid is moved into the Grid Market, where its value is reduced by the amount of the fees of its source market, the Neighborhood 1 Market at 0.01 \u20ac/kWh, resulting in a rate of 0.29 \u20ac/kWh as it enters the Grid Market. In the example above, the bid and offer are matched in the Grid Market. When the offer entered the Grid Market, its rate was immediately updated to account for the Grid Market fees (0.11 + 0.02). The bid was not updated, and if it was not matched in the Grid Market and moved to the Neighborhood 2 Market, the 0.02 \u20ac/kWh fee from the Grid Market would be subtracted to become (0.29 - 0.02) 0.27 \u20ac/kWh. The fees from the Neighborhood 2 Market would not be added to the bid unless it entered the House 2 Market (fees added according to the source market). In the Grid Market, the Load bid rate is listed as 0.29 \u20ac/kWh and the PV offer as 0.13 \u20ac/kWh. As the bid\u2019s rate is greater than the offer\u2019s rate, a trade can be scheduled. The trade clears at the bid\u2019s rate, resulting in a Clearing Rate of 0.29 \u20ac/kWh. The Grid Singularity energy exchange engine includes an algorithm that calculates the grid fee according to the clearing rate, basing the calculation on the original bid and offer rates. This allows the markets to act more independently and in a decentralized manner, without having to share information regarding their fees with other markets. The algorithm formula is as follows: demand_side_fee (\u20ac/kWh) = original_bid_rate (\u20ac/kWh) - forwarded_bid_rate (\u20ac/kWh) supply_side_fee (\u20ac/kWh) = forwarded_offer_rate (\u20ac/kWh) - original_offer_rate (\u20ac/kWh) For the example, we have the following values: supply_side_fee = 0.13 - 0.10 = 0.03 \u20ac/kWh demand_side_fee = 0.30 - 0.29 = 0.01 \u20ac/kWh After calculating the supply and demand side fee, the trade revenue can be calculated. Note the original_trade_rate is the amount that the original buyer (in our case the Load) will need to pay, therefore in the Pay-as-Bid market type this is the original bid price. The formula is the following: total_fee (\u20ac/kWh) = supply_side_fee (\u20ac/kWh) + demand_side_fee (\u20ac/kWh) revenue_rate (\u20ac/kWh) = original_trade_rate (\u20ac/kWh) - total_fee (\u20ac/kWh) For the example, the revenue will be: revenue = 0.30 - 0.04 = 0.26 \u20ac/kWh Finally, the trade rate is adapted according to the supply side fee, in order to include the fees of the current market: trade_rate (\u20ac/kWh) = revenue_rate (\u20ac/kWh) + supply_side_fee (\u20ac/kWh) trade_price (\u20ac) = energy (kWh) * trade_rate (\u20ac/kWh) For our example, the trade price for each market is: Market_trade_price (\u20ac) = (revenue_rate (\u20ac/kWh) + supply_side_fee (\u20ac/kWh)) * energy (kWh) Grid Market = (0.26 + 0.03)*1 = 0.29, Neighborhood 2 Market = (0.26 + 0.01)*1 = 0.27, Neighborhood 1 Market = (0.26 + 0.04)*1 = 0.30, House 1 Market = (0.26 + 0.04)*1 = 0.30, House 2 Market = (0.26 + 0)*1 = 0.26. The Load pays the Trade Price of 0.30\u20ac, which includes 0.26\u20ac revenue for the PV, 0.01\u20ac fees for Neighborhood Market 1, 0.02\u20ac fees for the Grid Market, and 0.01\u20ac fees for the Neighborhood Market 2. Example Calculation in Two-Sided Pay-as-Clear Market \u00b6 This market clearing type is currently in development. We welcome your suggestions on its design!","title":"Constant Grid Fee Calculation"},{"location":"constant-fees/#example-calculation-in-one-sided-pay-as-offer-market","text":"In an One-Sided Pay-as-Offer market, there are no bids, only offers. Offers are propagated throughout the markets in the hierarchy shown in the figure above. Grid fees are accounted for when an offer is forwarded to the higher market, adding that market\u2019s grid fees to any previously accumulated fees. The formula to calculate the new offer rate when placing an offer to a higher market is the following: offer_rate_after_fees (\u20ac/kWh) = offer_rate (\u20ac/kWh) + grid_fee (\u20ac/kWh) If the offer is not purchased after two ticks , it is moved into the next market, with the total rate incremented by the amount of that market's grid fee. In the example above, the PV offer of 0.10 \u20ac/kWh is first placed into the House 2 Market where it gains zero fees. Then it moves into the Neighborhood 2 Market, gaining a fee of 0.01 \u20ac/kWh to become 0.11 \u20ac/kWh. Then, if not purchased, it moves into the Grid Market, gaining a fee of 0.02 \u20ac/kWh to become 0.13 \u20ac/kWh. Continuing into the Neighborhood 1 Market, the offer gains a fee of 0.01 \u20ac/kWh to become 0.14 \u20ac/kWh. Continuing into the House 1 Market, the offer gains zero fees. The Load ultimately buys the offer in the House 1 Market at the Clearing Rate of 0.14 \u20ac/kWh. The trade price is calculated by adding the original offer rate ( 0.10 \u20ac/kWh ) and the total fees ( (0.01+0.02+0.01) = 0.04 \u20ac/kWh ), then multiplying by the amount of energy traded ( 1 kWh ) to yield the Trade Price of 0.14\u20ac. The Load pays the Trade Price of 0.14\u20ac, which includes 0.10\u20ac revenue for the PV, 0.01\u20ac fees for the Neighborhood Market 1, 0.02\u20ac fees for the Grid Market, and 0.01\u20ac fees for the Neighborhood Market 2. Since the market type is pay-as-offer, the offer rate is used as the clearing rate. The grid fees are added to the offer rate to determine the trade rate and therefore the trade price in each market. The following formula is used: supply_side_fee (\u20ac/kWh) = forwarded_offer_rate (\u20ac/kWh) - original_offer_rate (\u20ac/kWh) trade_rate (\u20ac/kWh) = clearing rate (\u20ac/kWh) trade_price (\u20ac) = energy (kWh) * trade_rate (\u20ac/kWh) For the provided example, the trade price for each market is: Market_trade_price (\u20ac) = (original_offer_rate (\u20ac/kWh) + supply_side_fee (\u20ac/kWh)) * energy (kWh) Grid Market = (0.10 + 0.03)*1 = 0.13 Neighborhood 2 Market = (0.10 + 0.01)*1 = 0.11 Neighborhood 1 Market = (0.10 + 0.04)*1 = 0.14 House 1 Market = (0.10 + 0.04)*1 = 0.14 House 2 Market = (0.10 + 0)*1 = 0.10","title":"Example Calculation in One-Sided Pay-as-Offer Market"},{"location":"constant-fees/#example-calculation-in-two-sided-pay-as-bid-market","text":"In the Two-Sided Pay-as-Bid market, there are both bids and offers, and both are propagated through the markets in the hierarchy. If a bid or offer is not matched after two ticks , it is moved into the next market. In order to prevent the double accounting of a market's grid fee when a bid and an offer are matched in that market, market fees are added to offers when they enter a new market (target market), and they are subtracted from bids when they leave a market (source market) and enter another one. The formula for propagating the offers is the same as for the one-sided market : offer_rate_after_fees (\u20ac/kWh) = offer_rate (\u20ac/kWh) + grid_fee (\u20ac/kWh) The IAA subtracts the fees from the bid before propagating the bid to the higher market, based on the following formula: bid_rate_after_fees (\u20ac/kWh) = bid_rate (\u20ac/kWh) - grid_fee (\u20ac/kWh) In the case of a Two-Sided Pay-as-Bid market, the offer is moved into the Grid Market by the same mechanism as in the One-Sided Pay-as-Offer market. The bid of 0.30 \u20ac/kWh is placed into the House 1 Market where there are zero fees. If it is not purchased after two ticks, it is moved into the Neighborhood 1 Market. As explained above, only the fees from the source market are added, which are zero in this case. Hence the bid rate remains 0.30 \u20ac/kWh. Next, the bid is moved into the Grid Market, where its value is reduced by the amount of the fees of its source market, the Neighborhood 1 Market at 0.01 \u20ac/kWh, resulting in a rate of 0.29 \u20ac/kWh as it enters the Grid Market. In the example above, the bid and offer are matched in the Grid Market. When the offer entered the Grid Market, its rate was immediately updated to account for the Grid Market fees (0.11 + 0.02). The bid was not updated, and if it was not matched in the Grid Market and moved to the Neighborhood 2 Market, the 0.02 \u20ac/kWh fee from the Grid Market would be subtracted to become (0.29 - 0.02) 0.27 \u20ac/kWh. The fees from the Neighborhood 2 Market would not be added to the bid unless it entered the House 2 Market (fees added according to the source market). In the Grid Market, the Load bid rate is listed as 0.29 \u20ac/kWh and the PV offer as 0.13 \u20ac/kWh. As the bid\u2019s rate is greater than the offer\u2019s rate, a trade can be scheduled. The trade clears at the bid\u2019s rate, resulting in a Clearing Rate of 0.29 \u20ac/kWh. The Grid Singularity energy exchange engine includes an algorithm that calculates the grid fee according to the clearing rate, basing the calculation on the original bid and offer rates. This allows the markets to act more independently and in a decentralized manner, without having to share information regarding their fees with other markets. The algorithm formula is as follows: demand_side_fee (\u20ac/kWh) = original_bid_rate (\u20ac/kWh) - forwarded_bid_rate (\u20ac/kWh) supply_side_fee (\u20ac/kWh) = forwarded_offer_rate (\u20ac/kWh) - original_offer_rate (\u20ac/kWh) For the example, we have the following values: supply_side_fee = 0.13 - 0.10 = 0.03 \u20ac/kWh demand_side_fee = 0.30 - 0.29 = 0.01 \u20ac/kWh After calculating the supply and demand side fee, the trade revenue can be calculated. Note the original_trade_rate is the amount that the original buyer (in our case the Load) will need to pay, therefore in the Pay-as-Bid market type this is the original bid price. The formula is the following: total_fee (\u20ac/kWh) = supply_side_fee (\u20ac/kWh) + demand_side_fee (\u20ac/kWh) revenue_rate (\u20ac/kWh) = original_trade_rate (\u20ac/kWh) - total_fee (\u20ac/kWh) For the example, the revenue will be: revenue = 0.30 - 0.04 = 0.26 \u20ac/kWh Finally, the trade rate is adapted according to the supply side fee, in order to include the fees of the current market: trade_rate (\u20ac/kWh) = revenue_rate (\u20ac/kWh) + supply_side_fee (\u20ac/kWh) trade_price (\u20ac) = energy (kWh) * trade_rate (\u20ac/kWh) For our example, the trade price for each market is: Market_trade_price (\u20ac) = (revenue_rate (\u20ac/kWh) + supply_side_fee (\u20ac/kWh)) * energy (kWh) Grid Market = (0.26 + 0.03)*1 = 0.29, Neighborhood 2 Market = (0.26 + 0.01)*1 = 0.27, Neighborhood 1 Market = (0.26 + 0.04)*1 = 0.30, House 1 Market = (0.26 + 0.04)*1 = 0.30, House 2 Market = (0.26 + 0)*1 = 0.26. The Load pays the Trade Price of 0.30\u20ac, which includes 0.26\u20ac revenue for the PV, 0.01\u20ac fees for Neighborhood Market 1, 0.02\u20ac fees for the Grid Market, and 0.01\u20ac fees for the Neighborhood Market 2.","title":"Example Calculation in Two-Sided Pay-as-Bid Market"},{"location":"constant-fees/#example-calculation-in-two-sided-pay-as-clear-market","text":"This market clearing type is currently in development. We welcome your suggestions on its design!","title":"Example Calculation in Two-Sided Pay-as-Clear Market"},{"location":"d3a-documentation/","text":"The commitment made to the energy transition by an increasing number of governments resulted in numerous incentive schemes, spurring growth in renewable power capacity in the European Union and globally . In 2019, the production of wind and solar energy was higher than energy produced with coal in Germany for the first time . This positive trend, however, also created a challenge in that the installed capacity of renewable energy outgrew the capacity of the distribution grid , impeding the grid operators to effectively transmit the energy to the final consumer . As a result, they have called for innovative tools to enable, \u201cmarket-based activation of explicit flexibilities that are able to alter power flows\" . Energy asset owners, from individual households to communities, could also use such tools for more optimal energy consumption, while contributing to wider market flexibility. If equipped with a decision-making agency, the distributed energy resources would become the medium to solve the challenge they have inadvertently created, while further enhancing the system's sustainability. A bottom-up, community energy model could transform our energy system to be more democratic, sustainable and stable. The European Union has recently laid the legal foundations for this reconstruction and other regulators are also supporting this market transformation.","title":"Energy Market Design Challenge"},{"location":"data-download/","text":"After successfully running a simulation in Grid Singularity\u2019s User Interface (d3a.io), the user can download the results file for a deeper analysis. The downloaded folder is organised into two subfolders with relevant files, as follows: Aggregated_results : area_throughput.json : Imported/exported energy for each market slot : Bills.json : Energy bills of all markets and energy assets (more details here ) Cumulative_bills.json : Total energy bills (spent & earned) Cumulative_grid_trades.json : Total energy traded for each market and energy asset and their penalty (for not trading their required energy) asset_statistics.json : asset profiles, energy traded, energy rates (min and max) for each asset each market slot Energy_trade_profile.json : Energy traded in each market Kpi.json : Self-consumption and self-sufficiency (in %), total energy demanded, generated and self-consumed Price_energy_day.json : Min, avg, max and grid fee rates for each market each market slot Progress_info.json : time remaining, simulation duration and percentage completed (if the simulation is complete eta_seconds should report 0 and percentage_completed should report 100) Random_seed.json : Random seed number used in the randomization process for specific events. This can mean the same simulation run multiple times may have slightly different results, as the posting order of bids and offers and matching trades can differ in certain situations (such as when two bids for the same price are randomly selected to be matched with one offer), causing some trades and bills to be different. Simulation_id.json : UUID of the simulation (can also be found in the simulation URL) Status.json : Status of the simulation Unmatched_loads.json : Number of unmatched load per markets reported each market slot bids_offers_trades : The folder structure follows the same logic as the simulation\u2019s grid hierarchy. There are three different csv files : *_bids.csv : Lists every bid posted on the relevant market including their volume, rate and buyer\u2019s name *_offers.csv : Lists every offer posted on the relevant market including their volume, rate and seller\u2019s name *_trades.csv : Lists each traded including their volume, rate, buyer\u2019s and seller\u2019s name","title":"Data Download"},{"location":"data-requirements/","text":"If you wish to base your digital twin simulation of an energy community using your own data rather than the provided templates, you need to collect the following: Grid topology : a description of the location of energy assets and their grouping. Energy assets specifications: Disaggregated data (not net meter) is recommended to efficiently connect and measure performance, provided as csv files in the following upload format for each of the assets: Load Name (anonymised) and geolocation Energy consumed over the last 15 minutes by each house in kWh, and/or: If houses have more granularity and have data for specific loads within a house, it is possible to either aggregate them or simulate different assets inside the house using their average power (kW) and the number of hours of use per day. PV Name (anonymised) and geolocation Energy produced over the last 15 minutes by each PV plant and/or Peak production of PV panel in kW in order for the software to generate the Gaussian profile automatically. Storage Name (anonymised) and geolocation Capacity in kWh Power delivery in kW Minimum SOC in % and/or Actual SOC (sent each 15 minutes) Actual charge/discharge rate (sent each 15 minutes). Grid pricing information a. Feed-in structures b. Conventional (utility) energy price (profile) c. Grid tariffs (profile). For the Canary Test Network Implementation, a live data stream of energy assets should be reported through our API following the similar format logic as explained above. If you are interested to connect your community to a canary test network please contact us .","title":"Data Requirements for Customized Simulations"},{"location":"default-trading-strategy/","text":"Grid Singularity\u2019s exchange engine (D3A) has a built-in template trading agent. The agent\u2019s trading strategy is deterministic . Each consumer asset will first try to buy energy at a low price and, if not cleared, the price will increase linearly during the market slot until a user-defined maximum is reached. In turn, assets generating energy will try to sell at a high price first and, if not cleared, reduce their rate linearly until a user-set minimum is reached. Offers\u2019 trading settings are as follows: initial_selling_rate final_selling_rate update_interval energy_rate_decrease_per_update fit_to_limit The following plot shows the changing energy rate in a spot market slot (slot_length = 15min) for four different trading settings. If fit_to_limit is set to True , energy_rate_decrease_per_update is ignored and a rate decrease per time is calculated, starting at initial_selling_rate and ending at final_selling_rate while updating the rate at each update_interval . Bids\u2019 Trading settings: initial_buying_rate final_buying_rate update_interval energy_rate_increase_per_update fit_to_limit The following plot shows the energy rate change in a spot market slot (slot_length = 15min) for different trading settings. If fit_to_limit is set to True , energy_rate_increase_per_update is ignored and a rate increase per time is calculated that starts at initial_buying_rate and ends at final_buying_rate while updating the rate at each update_interval . Assets can also deploy more intelligent trading strategies, as demonstrated in the 2020 Energy Singularity Challenge, described in the following two articles: Grid Singularity. (September 10, 2020). En Route to Energy Singularity Odyssey Momentum: Learnings from the 2020 Chaos Experiment Grid Singularity. (November 25, 2020). Energy Singularity Challenge 2020: Social Energy Networks Information on how to set up and train intelligent trading strategies through the Grid Singularity Asset API is available here .","title":"Trading Strategies"},{"location":"energy-bills/","text":"The cumulative energy bills for each market and energy asset are reported on the UI Results page and in a JSON file bills.json for a backend simulation. The bills are reported as the cash flow through each market. For a visual example, the following configuration will be used: This configuration is simulated for one day using the Pay-as-Bid market type and the load bidding to buy energy at 12:00, leading to the propagation of the load bid and the grid operator offer until they are matched as shown in the figure below: The bid and the offer are forwarded to the higher-level Grid market and are matched in this market with a clearing price (and trade price) of 0.45 \u20ac. For more information on how grid fees are calculated, please read the grid fees documentation ). In the bills.json file, the cash flow in each market is reported as follows: \"Parent market\" : { \"Agent\" : { \"bought\" : E ner gy t ha t has bee n bough t duri n g t he simula t io n [ kWh ], \"sold\" : E ner gy t ha t has bee n sold duri n g t he simula t io n [ kWh ], \"spent\" : Amou nt o f mo ne y t ha t has bee n spe nt i n tra des duri n g t he simula t io n [ \u20ac ] , \"earned\" : Amou nt o f mo ne y t ha t has bee n ear ne d i n tra des duri n g t he simula t io n [ \u20ac ], \"total_energy\" : e ner gy bough t - e ner gy sold [ kWh ], \"total_cost\" : mo ne y spe nt i n tra des - mo ne y ear ne d i n tra des [ \u20ac ], \"market_fee\" : Mo ne y spe nt i n t he \"Parent area\" as grid fees [ \u20ac ] , \"type\" : Type o f age nt . Ca n ei t her be a marke t or t he na me o f t he asse t s trate gy }, }, Shown below are the results of the previous example. The first set of results is from the highest market, in this case the Grid market : In the Grid market, House 1 has bought 1 kWh from the DSO and spent 0.375\u20ac in this trade. House 1 also pays the 0.075\u20ac grid fee that the Grid market is charging. The total cost of 1 kWh of energy is 0.375 + 0.075 = 0.45\u20ac One level down the hierarchy, the House 1 market is displayed in the figure below: The House 1 market has no information on the other markets\u2019 grid fees, so only considers its own fees in the bills table. Therefore, the Load spends 0.45\u20ac (0.0375+0.075) for 1 kWh of energy coming outside of House 1, with no grid fee added since House 1 has no fees. Finally, the bills of each energy asset is shown : The Load has bought 1 kWh of energy for 0.45\u20ac. Since 0.075\u20ac was paid as fees to the Grid market, the DSO received the remaining 0.375\u20ac for 1 kWh.","title":"Energy Bill"},{"location":"events/","text":"The user has the ability to modify the modelling setup while the simulated network is running. These modifications are termed events . To create an event the user can either go to the Modelling page and make a change while the simulation is running or pause the simulation beforehand (by clicking pause on the Results page ), resuming once changes are implemented. Possible events are : Add or delete markets and energy assets Change parameters of energy assets (with the exception of their names and the Market Maker ) Change market configuration settings (except names) Events in Simulations run using the User Interface \u00b6 Once an event is set, the user can track it on the timeline displayed at the top of the simulation. If the user clicks on the event on the Modelling page, the grid setup at that specific time is viewed. If the user clicks on an event in the Results page, the results of the specific markets and energy assets are viewed. whenever a market or energy asset was added whenever a market or energy asset parameter was modified whenever a market or energy asset was removed whenever multiple events have been executed at the same time Events in Simulations run using the Backend \u00b6 In a backend simulation, events need to be defined by the user in the setup files before the start of the simulation, and they are associated with a specific point in time (or duration), at which the event is triggered. An event has to be associated with a market by using the event_list constructor parameter for that market. There are four different event types, described in further detail below: Add/Remove Market Events Connect/Disconnect Market Events Strategy Events Configuration Events Add/Remove Market Events \u00b6 This event is associated with a market, and dictates that this market (and its submarkets and assets) will be added or removed from the grid at a specific point in time. There are two ways to configure this operation, either via individual events ( EnableMarketEvent and DisableMarketEvent ) or by disabling this market for a time interval ( DisableIntervalMarketEvent ). EnableMarketEvent / DisableMarketEvent commands each accept one argument, which is the hour at which this event is triggered (hourly resolution is supported in the current implementation), and this area will be enabled/disabled at this specific point in time no matter its current state. DisableIntervalMarketEvent accepts two arguments, denoting the start hour and the end hour at which the Market is disabled. The term disabled market means that the relevant markets and submarkets are not performing any trading, and are hence inactive in the simulation for the time that the market is disabled. Once enabled, the relevant market and its submarkets will start to operate. Examples for these events are available on the Grid Singularity GitHub: EnableMarketEvent: isolated_enable_event.py DisableMarketEvent: isolated_disable_event.py DisableIntervalMarketEvent: disable_interval_event.py Connect/Disconnect Market Events \u00b6 These events are similar to the enable/disable event; both have a similar API and both are used for removing a market from the grid. The difference is that the Connect/Disconnect events are decoupling the relevant submarkets and assets from the main grid. When the event is enabled, there will be two independent grids trading energy internally, but not with each other. This is contrary to enable/disable events, where the subtree is not performing any trades. This can simulate grids that are abruptly decoupled from the main grid, but manage to self-sustain their assets by continuing to trade energy even after they are disconnected from the main grid. You can find examples for these events on Grid Singularity GitHub: ConnectMarketEvent: isolated_connect_event.py DisconnectMarketEvent: isolated_disconnect_event.py DisconnectIntervalMarketEvent: disconnect_interval_event.py Strategy Events \u00b6 These events are used to change an asset\u2019s trading strategy during the simulation runtime. These are distinct events with no interval event provided. Load StrategyEvent: load_event.py PV StrategyEvent: pv_event.py Storage StrategyEvent: storage_event.py Configuration Events \u00b6 These events are used to change the market configuration (including submarkets and assets) during runtime. A useful application for this event is to set different weather conditions for a subset of the grid. Configuration events are distinct and no interval event is provided. There are currently two configuration events: Cloud Coverage Event: cloud_coverage_event.py PV User Profile Event : userprofile_pv_event.py","title":"Events (adding assets, communities, etc.)"},{"location":"events/#events-in-simulations-run-using-the-user-interface","text":"Once an event is set, the user can track it on the timeline displayed at the top of the simulation. If the user clicks on the event on the Modelling page, the grid setup at that specific time is viewed. If the user clicks on an event in the Results page, the results of the specific markets and energy assets are viewed. whenever a market or energy asset was added whenever a market or energy asset parameter was modified whenever a market or energy asset was removed whenever multiple events have been executed at the same time","title":"Events in Simulations run using the User Interface"},{"location":"events/#events-in-simulations-run-using-the-backend","text":"In a backend simulation, events need to be defined by the user in the setup files before the start of the simulation, and they are associated with a specific point in time (or duration), at which the event is triggered. An event has to be associated with a market by using the event_list constructor parameter for that market. There are four different event types, described in further detail below: Add/Remove Market Events Connect/Disconnect Market Events Strategy Events Configuration Events","title":"Events in Simulations run using the Backend"},{"location":"events/#addremove-market-events","text":"This event is associated with a market, and dictates that this market (and its submarkets and assets) will be added or removed from the grid at a specific point in time. There are two ways to configure this operation, either via individual events ( EnableMarketEvent and DisableMarketEvent ) or by disabling this market for a time interval ( DisableIntervalMarketEvent ). EnableMarketEvent / DisableMarketEvent commands each accept one argument, which is the hour at which this event is triggered (hourly resolution is supported in the current implementation), and this area will be enabled/disabled at this specific point in time no matter its current state. DisableIntervalMarketEvent accepts two arguments, denoting the start hour and the end hour at which the Market is disabled. The term disabled market means that the relevant markets and submarkets are not performing any trading, and are hence inactive in the simulation for the time that the market is disabled. Once enabled, the relevant market and its submarkets will start to operate. Examples for these events are available on the Grid Singularity GitHub: EnableMarketEvent: isolated_enable_event.py DisableMarketEvent: isolated_disable_event.py DisableIntervalMarketEvent: disable_interval_event.py","title":"Add/Remove Market Events"},{"location":"events/#connectdisconnect-market-events","text":"These events are similar to the enable/disable event; both have a similar API and both are used for removing a market from the grid. The difference is that the Connect/Disconnect events are decoupling the relevant submarkets and assets from the main grid. When the event is enabled, there will be two independent grids trading energy internally, but not with each other. This is contrary to enable/disable events, where the subtree is not performing any trades. This can simulate grids that are abruptly decoupled from the main grid, but manage to self-sustain their assets by continuing to trade energy even after they are disconnected from the main grid. You can find examples for these events on Grid Singularity GitHub: ConnectMarketEvent: isolated_connect_event.py DisconnectMarketEvent: isolated_disconnect_event.py DisconnectIntervalMarketEvent: disconnect_interval_event.py","title":"Connect/Disconnect Market Events"},{"location":"events/#strategy-events","text":"These events are used to change an asset\u2019s trading strategy during the simulation runtime. These are distinct events with no interval event provided. Load StrategyEvent: load_event.py PV StrategyEvent: pv_event.py Storage StrategyEvent: storage_event.py","title":"Strategy Events"},{"location":"events/#configuration-events","text":"These events are used to change the market configuration (including submarkets and assets) during runtime. A useful application for this event is to set different weather conditions for a subset of the grid. Configuration events are distinct and no interval event is provided. There are currently two configuration events: Cloud Coverage Event: cloud_coverage_event.py PV User Profile Event : userprofile_pv_event.py","title":"Configuration Events"},{"location":"general-settings/","text":"Grid Singularity exchange engine can be used to simulate, collaborate and optimize grid-aware local energy markets (LEMs). The simulation tool is freely available through our User Interface (UI) at map.gridsingularity and our backend codebase is open source under GNU general public license . This section will focus on a step-by-step guide to create and simulate LEMs using our software, starting with an explanation and guide for the UI, followed by a more technical tutorial to reproduce in the backend. User-Interface Simulation Configuration \u00b6 When creating a new simulation, simulation collaboration or a simulation in the Canary Test Network, the user needs to define the following general settings: Simulation name : Please provide a unique name. Description : Description of the simulation (optional but encouraged to clarify the intent of the simulation). Project : The user can select a project folder where the simulation is saved. Start date : Simulation start date (please make sure that the date-stamp of any uploaded data coincides with the defined start and end date). End date : Simulation end date. The user can simulate up to 7 days of LEM trading. Solar profile : Sets a template production curve for all photovoltaics (PVs) without custom production curves. Select one the following possible configurations: Sunny (generation profile with 250W panel) Cloudy (generation profile with 250W panel) Partially Cloudy (generation profile with 250W panel) Gaussian (the user can define the panel power output) Upload a profile (a custom default PV production curve can be uploaded as described in Upload File Formats ) Spot market type : The user can select one of three market types: One-sided pay-as-offer , Two-sided pay-as-bid and Two-sided pay-as-clear . Number of spot markets : Number of future spot markets where the energy assets and agents can trade. Duration of market slot : Duration of each spot market,between 2 and 60 minutes. Default is set to 15 minutes. Tick duration : Amount of time between two increments of each market slot when trades are cleared or agent trading rates are updated. Default duration is 15 simulated seconds, yielding 60 ticks per market slot. Grid Fees : The user can select one of two types: Constant grid fee or Percentage grid fee The interface for selecting general settings is shown below: Once the general settings of the simulation are defined, the user can move to the modelling page and set up the grid architecture by adding Markets and Energy Assets. Each market or energy asset is considered as 1 node . At the moment, up to 1000 nodes can be configured. Markets contain a spot market where all connected energy assets, submarkets and parent markets trade energy. Markets can potentially house multiple submarkets of different market types, and this feature will be available in the future version of our software. After adding the first market the user has to select a Market Maker rate. Subsequently, the user can model the simulation by configuring multiple submarkets and energy assets in a hierarchical electrical grid. Once the modelling is completed, the user goes to the Results page to initiate the simulation and view results. Backend Simulation Configuration \u00b6 In the backend, the simulation process is slightly different. There is no need to login to set up a simulation. The user first needs to download the code from our Github Repository (Installation Instructions for Linux , Mac and Windows ). In the setup-file (in Python programming language), general and trading strategy settings can be defined. Examples can be found in the relevant Grid Singularity GitHub folder. This is the most basic skeleton for a setup-file: from d3a.models.area import Area def get_setup ( config ): area = Area ( 'Grid' , []) return area The user can add more nested submarkets recursively by adding more instances of Area to the second parameter (list) of the Area class. If the strategy parameter is set in the Area class, the area is converted to a leaf node, e.g. a load. The following grid architecture is given: Grid House 1 H1 General Load H1 Storage 1 H1 Storage 2 House 2 H2 General Load Bold instances in the outline above are markets ( Area component). For each of these markets, an inter-area-agent is created in the background to execute offer/bid forwarding and matching. In the following, the corresponding setup-file is shown. from d3a.models.area import Area from d3a.models.strategy.storage import StorageStrategy from d3a.models.strategy.load_hours import LoadHoursStrategy from d3a.models.strategy.pv import PVStrategy def get_setup ( config ): area = Area ( 'Grid' , [ Area ( 'House 1' , [ Area ( 'H1 General Load' , strategy = LoadHoursStrategy ( avg_power_W = 200 , hrs_per_day = 6 , hrs_of_day = list ( range ( 12 , 18 )), final_buying_rate = 35 ) ), Area ( 'H1 Storage1' , strategy = StorageStrategy ( initial_soc = 50 ) ), Area ( 'H1 Storage2' , strategy = StorageStrategy ( initial_soc = 50 ) ), ], grid_fee_pct = 0 , grid_fee_const = 0 , ), Area ( 'House 2' , [ Area ( 'H2 General Load' , strategy = LoadHoursStrategy ( avg_power_W = 200 , hrs_per_day = 4 , hrs_of_day = list ( range ( 12 , 16 )), final_buying_rate = 35 ) ), Area ( 'H2 PV' , strategy = PVStrategy ( panel_count = 4 , initial_selling_rate = 30 , final_selling_rate = 5 ) ), ], grid_fee_pct = 0 , grid_fee_const = 0 , ), ], config = config ) return area Additionally the user has the possibility to change the default general settings in two different ways: Setup file (best option) d3a-setting.json setup-file (best option): \u00b6 For a description of each grid component please see the Modelling section. The user can overwrite the configuration settings by changing variables of the ConstSettings class in the setup-file. This class defines the default values for various parameters (general simulation settings, market settings and energy asset configuration). For instance, the user can define multiple configuration parameters in the get_setup function by overwriting the ConstSettings default values. For example, the following parameters can be set : Market_type (if equal to 1: One-Sided Pay-as-Offer , if equal to 2 : Two-Sided Pay-as-Bid , if equal to 3 : Two-Sided Pay-as-Clear ) Grid_fee_type (if equal to 1: Constant grid fee , if equal to 2 : Percentage grid fee ) Here is an example to setup a simulation with the Two-Sided Pay-as-Bid market type, constant grid fee and default min (0cts/kWh) and max to (35cts/kWh) energy rate for all loads : from d3a_interface.constants_limits import ConstSettings def get_setup ( config ): ConstSettings . IAASettings . MARKET_TYPE = 2 ConstSettings . LoadSettings . MIN_ENERGY_RATE = 0 ConstSettings . LoadSettings . MAX_ENERGY_RATE = 35 ConstSettings . IAASettings . GRID_FEE_TYPE = 1 d3a-settings.json \u00b6 These general settings can also be parsed via a settings file in JSON format, which contains all constants in the advanced_settings branch. An example can be found here: src/d3a/setup/d3a-settings.json The settings JSON file can be parsed via the --settings-file keyword Setting General Configuration Parameters \u00b6 The following parameters are part of Simulation Config and are initialised before updating any ConstSettings : sim_duration slot_length tick_length market_count cloud_coverage* market_maker_rate* grid_fee_pct* grid_fee_const* pv_user_profile* max_panel_power_W In order to update some of these parameters (starred in list above), please use update_config_parameters method to update the general configuration parameters in the setup file: def get_setup ( config ): config . update_config_parameters ( grid_fee_pct = 5 , grid_fee_const = 35 , cloud_coverage = 2 , pv_user_profile = \"<path>/<profile_name>\" , market_maker_rate = 30 ) area = Area ( 'Grid' , [ Area ( 'General Load' , strategy = LoadHoursStrategy ( avg_power_W = 200 , hrs_per_day = 4 , hrs_of_day = list ( range ( 12 , 16 )), final_buying_rate = 35 ) ), Area ( 'PV' , strategy = PVStrategy ( 4 , 80 ) ), ], config = config ) return area Simulation launch \u00b6 Once the entire grid architecture is modelled, including energy assets, the user can launch the trading simulation by running a command line including desired setup features: -d, --duration: simulated duration of simulation [default: 1d] -t, --tick-length: simulated duration of a tick [default: 1s] -s, --slot-length: simulated duration of a market slot [default: 15m] -c, --cloud-coverage: Cloud coverage, 0 for sunny, 1 for partial coverage, 2 for clouds. [default: 0] -m, --market-count: Number of tradable market slots [default: 1] --slot-length-realtime: Desired duration of slot in realtime [default: 0s] Example simulation call: d3a -l ERROR run --duration=1d --tick-length=1s --slot-length=15m --cloud-coverage=0 --market-count=5 --setup default_2a Getting help in the command line: d3a --help returns: Usage: d3a [OPTIONS] COMMAND [ARGS]... Options: -l, --log-level [CRITICAL|FATAL|ERROR|WARN|WARNING|INFO|DEBUG|NOTSET|TRACE] Log level [default: INFO] --help Show this message and exit. Commands: run* resume d3a run --help returns: Usage: d3a run [OPTIONS] Options: -d, --duration INTERVAL Duration of simulation [default: 1d] -t, --tick-length INTERVAL Length of a tick [default: 1s] -s, --slot-length INTERVAL Length of a market slot [default: 15m] --slot-length-realtime INTERVAL Desired duration of slot in realtime [default: 0s] -c, --cloud-coverage INTEGER Cloud coverage, 0 for sunny, 1 for partial coverage, 2 for clouds. [default: 0] -m, --market-count INTEGER Number of tradable market slots into the future [default: 1] --setup TEXT Simulation setup module use. Available modules: [1000_houses, market_events.cloud_coverage_event, market_events.disable_interval_event, market_events.disconnect_interval_event, market_events.isolated_connect_event, market_events.isolated_disable_event, market_events.isolated_disconnect_event, market_events.isolated_enable_event, market_events.load_event, market_events.pv_event, market_events.storage_event, balancing_market.default_2a, balancing_market.one_load_one_pv, balancing_market.one_load_one_storage, balancing_market.one_storage_one_pv, balancing_market.test_asset_registry, balancing_market.two_sided_one_load_one_pv, config_parameter_test, default_2, default_2a, default_2b, default_3, default_3_pv_only, default_3a, default_3b, default_4, default_5, default_addcurve, default_addcurve2, default_csv, graphs_testing, jira.d3asim_1024, jira.d3asim_1139, jira.d3asim_638_custom_load, jira.d3asim_639_custom_storage, jira.d3asim_640_custom_pv, jira.d3asim_778, jira.d3asim_780, jira.d3asim_869, jira.d3asim_871, jira.d3asim_895, jira.d3asim_895_pr1, jira.d3asim_895_pr2, jira.d3asim_895_pr3, jira.d3asim_962, jira.default_2off_d3asim_1475, jira.default_595, jira.default_611, jira.default_613, jira.default_623, jira.default_645, jira.default_737, jira.test_strategy_custom_load, jira.test_strategy_custom_pv, jira.test_strategy_custom_storage, json_arg, json_file, non_compounded_grid_fees, redis_communication_default_2a, sam_config, sam_config_const_load, sam_config_small, strategy_tests.commercial_producer_market_maker_rate, strategy_tests.ess_capacity_based_sell_offer, strategy_tests.ess_sell_offer_decrease_based_on_risk_or_rate, strategy_tests.finite_power_plant, strategy_tests.finite_power_plant_profile, strategy_tests.home_cp_ess_load, strategy_tests.home_hybrid_pv_ess_load, strategy_tests.infinite_bus, strategy_tests.predefined_pv_test, strategy_tests.pv_const_price_decrease, strategy_tests.pv_final_selling_rate, strategy_tests.pv_initial_pv_rate_option, strategy_tests.pv_max_panel_output, strategy_tests.pv_max_panel_power_global, strategy_tests.pv_risk_based_price_decrease, strategy_tests.storage_buys_and_offers, strategy_tests.storage_strategy_break_even_hourly, strategy_tests.user_profile_load_csv, strategy_tests.user_profile_load_csv_multiday, strategy_tests.user_profile_load_dict, strategy_tests.user_profile_pv_csv, strategy_tests.user_profile_pv_dict, strategy_tests.user_profile_wind_csv, strategy_tests.user_rate_profile_load_dict, tobalaba.one_producer_load, two_sided_market.default_2a, two_sided_market.infinite_bus, two_sided_market.offer_reposted_at_old_offer_rate, two_sided_market.one_cep_one_load, two_sided_market.one_load_5_pv_partial, two_sided_market.one_load_one_storage, two_sided_market.one_pv_one_load, two_sided_market.one_pv_one_storage, two_sided_market.one_storage_5_pv_partial, two_sided_market.user_min_rate_profile_load_dict, two_sided_market.with_balancing_market, two_sided_pay_as_clear.default_2a, two_sided_pay_as_clear.test_clearing_energy] -g, --settings-file TEXT Settings file path --seed TEXT Manually specify random seed --paused Start simulation in paused state [default: False] --pause-at TEXT Automatically pause at a certain time. Accepted Input formats: (YYYY-MM-DD, HH:mm) [default: disabled] --repl / --no-repl Start REPL after simulation run. [default: False] --no-export Skip export of simulation data --export-path TEXT Specify a path for the csv export files (default: ~/d3a-simulation) --enable-bc Run simulation on Blockchain --compare-alt-pricing Compare alternative pricing schemes --start-date DATE Start date of the Simulation (YYYY-MM-DD) [default: 2019-09-27] --help Show this message and exit.","title":"General Configuration Settings"},{"location":"general-settings/#user-interface-simulation-configuration","text":"When creating a new simulation, simulation collaboration or a simulation in the Canary Test Network, the user needs to define the following general settings: Simulation name : Please provide a unique name. Description : Description of the simulation (optional but encouraged to clarify the intent of the simulation). Project : The user can select a project folder where the simulation is saved. Start date : Simulation start date (please make sure that the date-stamp of any uploaded data coincides with the defined start and end date). End date : Simulation end date. The user can simulate up to 7 days of LEM trading. Solar profile : Sets a template production curve for all photovoltaics (PVs) without custom production curves. Select one the following possible configurations: Sunny (generation profile with 250W panel) Cloudy (generation profile with 250W panel) Partially Cloudy (generation profile with 250W panel) Gaussian (the user can define the panel power output) Upload a profile (a custom default PV production curve can be uploaded as described in Upload File Formats ) Spot market type : The user can select one of three market types: One-sided pay-as-offer , Two-sided pay-as-bid and Two-sided pay-as-clear . Number of spot markets : Number of future spot markets where the energy assets and agents can trade. Duration of market slot : Duration of each spot market,between 2 and 60 minutes. Default is set to 15 minutes. Tick duration : Amount of time between two increments of each market slot when trades are cleared or agent trading rates are updated. Default duration is 15 simulated seconds, yielding 60 ticks per market slot. Grid Fees : The user can select one of two types: Constant grid fee or Percentage grid fee The interface for selecting general settings is shown below: Once the general settings of the simulation are defined, the user can move to the modelling page and set up the grid architecture by adding Markets and Energy Assets. Each market or energy asset is considered as 1 node . At the moment, up to 1000 nodes can be configured. Markets contain a spot market where all connected energy assets, submarkets and parent markets trade energy. Markets can potentially house multiple submarkets of different market types, and this feature will be available in the future version of our software. After adding the first market the user has to select a Market Maker rate. Subsequently, the user can model the simulation by configuring multiple submarkets and energy assets in a hierarchical electrical grid. Once the modelling is completed, the user goes to the Results page to initiate the simulation and view results.","title":"User-Interface Simulation Configuration"},{"location":"general-settings/#backend-simulation-configuration","text":"In the backend, the simulation process is slightly different. There is no need to login to set up a simulation. The user first needs to download the code from our Github Repository (Installation Instructions for Linux , Mac and Windows ). In the setup-file (in Python programming language), general and trading strategy settings can be defined. Examples can be found in the relevant Grid Singularity GitHub folder. This is the most basic skeleton for a setup-file: from d3a.models.area import Area def get_setup ( config ): area = Area ( 'Grid' , []) return area The user can add more nested submarkets recursively by adding more instances of Area to the second parameter (list) of the Area class. If the strategy parameter is set in the Area class, the area is converted to a leaf node, e.g. a load. The following grid architecture is given: Grid House 1 H1 General Load H1 Storage 1 H1 Storage 2 House 2 H2 General Load Bold instances in the outline above are markets ( Area component). For each of these markets, an inter-area-agent is created in the background to execute offer/bid forwarding and matching. In the following, the corresponding setup-file is shown. from d3a.models.area import Area from d3a.models.strategy.storage import StorageStrategy from d3a.models.strategy.load_hours import LoadHoursStrategy from d3a.models.strategy.pv import PVStrategy def get_setup ( config ): area = Area ( 'Grid' , [ Area ( 'House 1' , [ Area ( 'H1 General Load' , strategy = LoadHoursStrategy ( avg_power_W = 200 , hrs_per_day = 6 , hrs_of_day = list ( range ( 12 , 18 )), final_buying_rate = 35 ) ), Area ( 'H1 Storage1' , strategy = StorageStrategy ( initial_soc = 50 ) ), Area ( 'H1 Storage2' , strategy = StorageStrategy ( initial_soc = 50 ) ), ], grid_fee_pct = 0 , grid_fee_const = 0 , ), Area ( 'House 2' , [ Area ( 'H2 General Load' , strategy = LoadHoursStrategy ( avg_power_W = 200 , hrs_per_day = 4 , hrs_of_day = list ( range ( 12 , 16 )), final_buying_rate = 35 ) ), Area ( 'H2 PV' , strategy = PVStrategy ( panel_count = 4 , initial_selling_rate = 30 , final_selling_rate = 5 ) ), ], grid_fee_pct = 0 , grid_fee_const = 0 , ), ], config = config ) return area Additionally the user has the possibility to change the default general settings in two different ways: Setup file (best option) d3a-setting.json","title":"Backend Simulation Configuration"},{"location":"general-settings/#setup-file-best-option","text":"For a description of each grid component please see the Modelling section. The user can overwrite the configuration settings by changing variables of the ConstSettings class in the setup-file. This class defines the default values for various parameters (general simulation settings, market settings and energy asset configuration). For instance, the user can define multiple configuration parameters in the get_setup function by overwriting the ConstSettings default values. For example, the following parameters can be set : Market_type (if equal to 1: One-Sided Pay-as-Offer , if equal to 2 : Two-Sided Pay-as-Bid , if equal to 3 : Two-Sided Pay-as-Clear ) Grid_fee_type (if equal to 1: Constant grid fee , if equal to 2 : Percentage grid fee ) Here is an example to setup a simulation with the Two-Sided Pay-as-Bid market type, constant grid fee and default min (0cts/kWh) and max to (35cts/kWh) energy rate for all loads : from d3a_interface.constants_limits import ConstSettings def get_setup ( config ): ConstSettings . IAASettings . MARKET_TYPE = 2 ConstSettings . LoadSettings . MIN_ENERGY_RATE = 0 ConstSettings . LoadSettings . MAX_ENERGY_RATE = 35 ConstSettings . IAASettings . GRID_FEE_TYPE = 1","title":"setup-file (best option):"},{"location":"general-settings/#d3a-settingsjson","text":"These general settings can also be parsed via a settings file in JSON format, which contains all constants in the advanced_settings branch. An example can be found here: src/d3a/setup/d3a-settings.json The settings JSON file can be parsed via the --settings-file keyword","title":"d3a-settings.json"},{"location":"general-settings/#setting-general-configuration-parameters","text":"The following parameters are part of Simulation Config and are initialised before updating any ConstSettings : sim_duration slot_length tick_length market_count cloud_coverage* market_maker_rate* grid_fee_pct* grid_fee_const* pv_user_profile* max_panel_power_W In order to update some of these parameters (starred in list above), please use update_config_parameters method to update the general configuration parameters in the setup file: def get_setup ( config ): config . update_config_parameters ( grid_fee_pct = 5 , grid_fee_const = 35 , cloud_coverage = 2 , pv_user_profile = \"<path>/<profile_name>\" , market_maker_rate = 30 ) area = Area ( 'Grid' , [ Area ( 'General Load' , strategy = LoadHoursStrategy ( avg_power_W = 200 , hrs_per_day = 4 , hrs_of_day = list ( range ( 12 , 16 )), final_buying_rate = 35 ) ), Area ( 'PV' , strategy = PVStrategy ( 4 , 80 ) ), ], config = config ) return area","title":"Setting General Configuration Parameters"},{"location":"general-settings/#simulation-launch","text":"Once the entire grid architecture is modelled, including energy assets, the user can launch the trading simulation by running a command line including desired setup features: -d, --duration: simulated duration of simulation [default: 1d] -t, --tick-length: simulated duration of a tick [default: 1s] -s, --slot-length: simulated duration of a market slot [default: 15m] -c, --cloud-coverage: Cloud coverage, 0 for sunny, 1 for partial coverage, 2 for clouds. [default: 0] -m, --market-count: Number of tradable market slots [default: 1] --slot-length-realtime: Desired duration of slot in realtime [default: 0s] Example simulation call: d3a -l ERROR run --duration=1d --tick-length=1s --slot-length=15m --cloud-coverage=0 --market-count=5 --setup default_2a Getting help in the command line: d3a --help returns: Usage: d3a [OPTIONS] COMMAND [ARGS]... Options: -l, --log-level [CRITICAL|FATAL|ERROR|WARN|WARNING|INFO|DEBUG|NOTSET|TRACE] Log level [default: INFO] --help Show this message and exit. Commands: run* resume d3a run --help returns: Usage: d3a run [OPTIONS] Options: -d, --duration INTERVAL Duration of simulation [default: 1d] -t, --tick-length INTERVAL Length of a tick [default: 1s] -s, --slot-length INTERVAL Length of a market slot [default: 15m] --slot-length-realtime INTERVAL Desired duration of slot in realtime [default: 0s] -c, --cloud-coverage INTEGER Cloud coverage, 0 for sunny, 1 for partial coverage, 2 for clouds. [default: 0] -m, --market-count INTEGER Number of tradable market slots into the future [default: 1] --setup TEXT Simulation setup module use. Available modules: [1000_houses, market_events.cloud_coverage_event, market_events.disable_interval_event, market_events.disconnect_interval_event, market_events.isolated_connect_event, market_events.isolated_disable_event, market_events.isolated_disconnect_event, market_events.isolated_enable_event, market_events.load_event, market_events.pv_event, market_events.storage_event, balancing_market.default_2a, balancing_market.one_load_one_pv, balancing_market.one_load_one_storage, balancing_market.one_storage_one_pv, balancing_market.test_asset_registry, balancing_market.two_sided_one_load_one_pv, config_parameter_test, default_2, default_2a, default_2b, default_3, default_3_pv_only, default_3a, default_3b, default_4, default_5, default_addcurve, default_addcurve2, default_csv, graphs_testing, jira.d3asim_1024, jira.d3asim_1139, jira.d3asim_638_custom_load, jira.d3asim_639_custom_storage, jira.d3asim_640_custom_pv, jira.d3asim_778, jira.d3asim_780, jira.d3asim_869, jira.d3asim_871, jira.d3asim_895, jira.d3asim_895_pr1, jira.d3asim_895_pr2, jira.d3asim_895_pr3, jira.d3asim_962, jira.default_2off_d3asim_1475, jira.default_595, jira.default_611, jira.default_613, jira.default_623, jira.default_645, jira.default_737, jira.test_strategy_custom_load, jira.test_strategy_custom_pv, jira.test_strategy_custom_storage, json_arg, json_file, non_compounded_grid_fees, redis_communication_default_2a, sam_config, sam_config_const_load, sam_config_small, strategy_tests.commercial_producer_market_maker_rate, strategy_tests.ess_capacity_based_sell_offer, strategy_tests.ess_sell_offer_decrease_based_on_risk_or_rate, strategy_tests.finite_power_plant, strategy_tests.finite_power_plant_profile, strategy_tests.home_cp_ess_load, strategy_tests.home_hybrid_pv_ess_load, strategy_tests.infinite_bus, strategy_tests.predefined_pv_test, strategy_tests.pv_const_price_decrease, strategy_tests.pv_final_selling_rate, strategy_tests.pv_initial_pv_rate_option, strategy_tests.pv_max_panel_output, strategy_tests.pv_max_panel_power_global, strategy_tests.pv_risk_based_price_decrease, strategy_tests.storage_buys_and_offers, strategy_tests.storage_strategy_break_even_hourly, strategy_tests.user_profile_load_csv, strategy_tests.user_profile_load_csv_multiday, strategy_tests.user_profile_load_dict, strategy_tests.user_profile_pv_csv, strategy_tests.user_profile_pv_dict, strategy_tests.user_profile_wind_csv, strategy_tests.user_rate_profile_load_dict, tobalaba.one_producer_load, two_sided_market.default_2a, two_sided_market.infinite_bus, two_sided_market.offer_reposted_at_old_offer_rate, two_sided_market.one_cep_one_load, two_sided_market.one_load_5_pv_partial, two_sided_market.one_load_one_storage, two_sided_market.one_pv_one_load, two_sided_market.one_pv_one_storage, two_sided_market.one_storage_5_pv_partial, two_sided_market.user_min_rate_profile_load_dict, two_sided_market.with_balancing_market, two_sided_pay_as_clear.default_2a, two_sided_pay_as_clear.test_clearing_energy] -g, --settings-file TEXT Settings file path --seed TEXT Manually specify random seed --paused Start simulation in paused state [default: False] --pause-at TEXT Automatically pause at a certain time. Accepted Input formats: (YYYY-MM-DD, HH:mm) [default: disabled] --repl / --no-repl Start REPL after simulation run. [default: False] --no-export Skip export of simulation data --export-path TEXT Specify a path for the csv export files (default: ~/d3a-simulation) --enable-bc Run simulation on Blockchain --compare-alt-pricing Compare alternative pricing schemes --start-date DATE Start date of the Simulation (YYYY-MM-DD) [default: 2019-09-27] --help Show this message and exit.","title":"Simulation launch"},{"location":"grid-fees/","text":"Grid operators (Distribution and Transmission System Operators - DSOs and TSOs - or Independent System Operators - ISOs in the USA) are tasked to monitor and manage the electrical grid. It is their responsibility to ensure a connection for end-users on the distribution network along with energy transport security. Grid operators use grid fees to cover the cost of managing their grid infrastructure. Lately, due to the heightened pace of innovation, increased demand and investment in distributed energy resources (DERs), grid operators face many challenges, such as lines and transformers congestion at specific times of the day. One solution is to use grid fees as a tool to actively manage grid congestion by increasing and reducing the fee during the day, week or year. Increasing the fee at peak transmission and reducing the price during off-peak periods makes it financially attractive for end-users to use flexible energy assets (e.g. batteries, EVs, heat-pumps) to provide demand response services and reduce reliance on the grid. Grid Singularity offers an environment to simulate, test and optimize grid fee incentives for local energy markets (LEMs) At the moment grid fee can be set as : Market Fee : This is a fee that is added to each trade that is cleared. The buyer of energy is responsible for paying all the grid fees: bid\u2019s price >= offer\u2019s price + grid fee . Constant grid fee : constant value in cents/kWh that is added to each trade Percentage grid fee : percentage value determined by the clearing price that is added to each trade The following article explains how flexible grid fees may be implemented towards peak reduction. For a video tutorial on how to set grid fees in the Grid Singularity exchange engine , please follow this link .","title":"Grid Fee Objectives"},{"location":"grid-operator-api/","text":"The Grid Singularity Grid Operator API client allows you to create agents that can dynamically change the grid fee in different markets. The agent can request and receive information through the Grid Operator API, feed that information into a tariff model, and submit grid fees through the API client to change grid fees on a live simulated exchange. The Grid Operator API is designed for grid operators (notably Distribution System Operators or DSOs) to manage congestion and grid constraints in different markets across the grid. The structure is designed so that multiple markets can be managed from a single agent, allowing information to be aggregated for integrated grid management. Market Information \u00b6 The Grid Operator API receives information concerning the markets that it manages. Different metrics are shared through the API : Minimum, median, average and maximum trade price [\u20ac/kWh] Total energy volume traded [kWh] Self sufficiency / self consumption [%] Import / Export [kWh] Current market fee [cents/kWh] Next market fee [cents/kWh] Market fee revenue [cents] Interaction with the running exchange \u00b6 As explained above the Grid Operator API function is triggered at the start of each market slot. Here is one example: At the end of the 12:45 market slot, the Grid Operator API function on_market_cycle is triggered. The Grid Operator agent receives a nested dictionary with information from the last market slot, including the grid tree ( 12:45-13:00 ). Based on these inputs, the agent script sets a new grid fee for the markets it manages. The grid fees sent during the 13:00 will be applied for the 13:15 market slot API Events \u00b6 In the Grid Operator there are 3 events that are triggered while a simulation is running. Each new market slot \u00b6 def on_market_cycle(self, market_info): As shown in the schematic above, this event triggered at the start of every market slot. When a new market slot is created the API receives the market_info , containing market information and the code within the script event is executed. On event or response \u00b6 def on_event_or_response(self, message): In this event, the API receives a message for every event ( on_market_cycle ) or response for each commands (e.g. submitting new grid fees) On finish \u00b6 def on_finish(self, finish_info): This event is triggered when the simulation/collaboration finishes. Within that function, information stored during the simulation could potentially be exported for further analysis. API command \u00b6 The Grid Operator API can function once at the start of each market slot . When the current market slot ends, a new one is automatically created and the client is notified via the on_market_cycle event. It is possible to capture this event and perform operations when it occurs by overriding the functionality of the on_market_cycle method. The Grid Operator API can send batch commands, grouping different commands, for different markets. The commands can be grouped and then all executed at the same time. Three different commands are available for the Grid Operator API : last_market_dso_stats() \u00b6 This command is used to request information from different markets for the last market slot. This batch command receives one argument : area_uuid . This latter is the Universal Unique Identifier of the requested market statistic. Here is an example: self.add_to_batch_commands.last_market_dso_stats(area_uuid = \"62f827ec-ef86-4782-b5c3-88327751d97d\") grid_fees() \u00b6 This command is used to send the new grid fee for a specific market. The grid fee needs to be set as a positive value and the unit is cents/kWh. This batch command receives two arguments: area_uuid and fee_cents_kwh . Here is an example: self.add_to_batch_commands.grid_fees(area_uuid=62f827ec-ef86-4782-b5c3-88327751d97d\", fee_cents_kwh=3.2) After adding all the wanted commands in the batch, the API can execute it with the following command: response = self.execute_batch_commands() In return the simulation will provide a response for all commands submitted. API template script \u00b6 A Grid Operator API template script is available on github . This shows an example of what can be done with this API, and offers a flexible structure, easy to modify to implement custom grid fee strategies. In this script two template strategies are available already. Time-of-Use (ToU) \u00b6 This is a strategy where grid fee is applied depending on the time of the day (hours and minutes) regardless of the market conditions. After analysing import and export patterns of their client, grid operators can create a time-based curve, increasing fees at peak predicted times (e.g. morning and dinner time). Here is an example of ToU strategy that was used by the DSOs in one of the experiments at Odyssey hackathon . Aziiz pricing \u00b6 The Aziiz model is using past market information to determine the next grid fee. The model looks at past imports and exports on a specific market, applies a moving average and then based on this number sets the next grid fee for that market. This model has the advantage of integrating market conditions into its strategy. For instance if past market slots experienced high imports, the model will increase fees in the relevant market to incentivise market participants to contain the energy within that area. Script Configuration \u00b6 As mentioned on this page, at the start of the API script the user needs to specify the markets she/he wishes to connect and manage and the oracle name. Right after that the user selects the strategy to use (Time of Use or Aziiz model). To select the Time of Use strategy the user needs to set TimeOfUse to True and Aziiz to False. On the other hand, to select the Aziiz model, the user has to set TimeOfUse to False and Aziiz to True. If the Aziiz model is selected, the user can tune parameters such as applying the moving average and specifying the number of past market slots to average. For both strategies, the script reads an Excel file to adjust the grid fees ( ToU.xlsx and Aziiz.xlsx ). In ToU.xlsx the user can define the grid fees for each market she/he manages for every quarter hours of the day. In Aziiz.xlsx grid fees can be set for every peak import/export thresholds for each market. The Aziiz strategy will compare the average of the last markets\u2019 peak import/export to the threshold. If the average is lower than the threshold the relevant grid fee will be applied (for instance on the figure below if the average peak is equal to 22kWh, the next grid fee will be 3 cents/KWh. Each sheet\u2019s name represents the market connected to. On_market_slot event is used to gather market statistics and set the grid fees for the next market slot. In these lines , the API is requesting dso market statistics from the simulation. After that, the API is storing some of the relevant market data to local variables, easier to manipulate. To improve the API monitoring, the script is printing relevant data in the terminal: In these lines , the script applies the grid fee depending on the fee strategy defined at the start. If the Time of Use was set, the markets\u2019 grid fee is set based on the ToU excel file. If the Aziiz model was chosen the next fee is defined based on the Aziiz excel file. Additionally if the peak import/export is higher than all threshold defined in the excel sheets this sets the next fee as 2000cts/kWh. All the fees are added to the batch command and then executed . After that the script prints the current fee and next fee for each market. Later, the on_event_or_response is overwritten. By default we do not perform any operation in this event but the user could add some if needed. For instance the user could record all the grid fee change responses received in that event. Lastly the API script overwrites the on_finish event so that whenever the function is triggered the script stops. If the user wishes to save some information recorded within the API client this would be the opportunity to export them to external files. The rest of the scrip is used to connect to a running simulation/collaboration/canary network. These lines should work as is and no changes are required. Please find the following tutorial describing the required steps to run the grid operator API locally and on a collaboration:","title":"Grid Operator API"},{"location":"grid-operator-api/#market-information","text":"The Grid Operator API receives information concerning the markets that it manages. Different metrics are shared through the API : Minimum, median, average and maximum trade price [\u20ac/kWh] Total energy volume traded [kWh] Self sufficiency / self consumption [%] Import / Export [kWh] Current market fee [cents/kWh] Next market fee [cents/kWh] Market fee revenue [cents]","title":"Market Information"},{"location":"grid-operator-api/#interaction-with-the-running-exchange","text":"As explained above the Grid Operator API function is triggered at the start of each market slot. Here is one example: At the end of the 12:45 market slot, the Grid Operator API function on_market_cycle is triggered. The Grid Operator agent receives a nested dictionary with information from the last market slot, including the grid tree ( 12:45-13:00 ). Based on these inputs, the agent script sets a new grid fee for the markets it manages. The grid fees sent during the 13:00 will be applied for the 13:15 market slot","title":"Interaction with the running exchange"},{"location":"grid-operator-api/#api-events","text":"In the Grid Operator there are 3 events that are triggered while a simulation is running.","title":"API Events"},{"location":"grid-operator-api/#each-new-market-slot","text":"def on_market_cycle(self, market_info): As shown in the schematic above, this event triggered at the start of every market slot. When a new market slot is created the API receives the market_info , containing market information and the code within the script event is executed.","title":"Each new market slot"},{"location":"grid-operator-api/#on-event-or-response","text":"def on_event_or_response(self, message): In this event, the API receives a message for every event ( on_market_cycle ) or response for each commands (e.g. submitting new grid fees)","title":"On event or response"},{"location":"grid-operator-api/#on-finish","text":"def on_finish(self, finish_info): This event is triggered when the simulation/collaboration finishes. Within that function, information stored during the simulation could potentially be exported for further analysis.","title":"On finish"},{"location":"grid-operator-api/#api-command","text":"The Grid Operator API can function once at the start of each market slot . When the current market slot ends, a new one is automatically created and the client is notified via the on_market_cycle event. It is possible to capture this event and perform operations when it occurs by overriding the functionality of the on_market_cycle method. The Grid Operator API can send batch commands, grouping different commands, for different markets. The commands can be grouped and then all executed at the same time. Three different commands are available for the Grid Operator API :","title":"API command"},{"location":"grid-operator-api/#last_market_dso_stats","text":"This command is used to request information from different markets for the last market slot. This batch command receives one argument : area_uuid . This latter is the Universal Unique Identifier of the requested market statistic. Here is an example: self.add_to_batch_commands.last_market_dso_stats(area_uuid = \"62f827ec-ef86-4782-b5c3-88327751d97d\")","title":"last_market_dso_stats()"},{"location":"grid-operator-api/#grid_fees","text":"This command is used to send the new grid fee for a specific market. The grid fee needs to be set as a positive value and the unit is cents/kWh. This batch command receives two arguments: area_uuid and fee_cents_kwh . Here is an example: self.add_to_batch_commands.grid_fees(area_uuid=62f827ec-ef86-4782-b5c3-88327751d97d\", fee_cents_kwh=3.2) After adding all the wanted commands in the batch, the API can execute it with the following command: response = self.execute_batch_commands() In return the simulation will provide a response for all commands submitted.","title":"grid_fees()"},{"location":"grid-operator-api/#api-template-script","text":"A Grid Operator API template script is available on github . This shows an example of what can be done with this API, and offers a flexible structure, easy to modify to implement custom grid fee strategies. In this script two template strategies are available already.","title":"API template script"},{"location":"grid-operator-api/#time-of-use-tou","text":"This is a strategy where grid fee is applied depending on the time of the day (hours and minutes) regardless of the market conditions. After analysing import and export patterns of their client, grid operators can create a time-based curve, increasing fees at peak predicted times (e.g. morning and dinner time). Here is an example of ToU strategy that was used by the DSOs in one of the experiments at Odyssey hackathon .","title":"Time-of-Use (ToU)"},{"location":"grid-operator-api/#aziiz-pricing","text":"The Aziiz model is using past market information to determine the next grid fee. The model looks at past imports and exports on a specific market, applies a moving average and then based on this number sets the next grid fee for that market. This model has the advantage of integrating market conditions into its strategy. For instance if past market slots experienced high imports, the model will increase fees in the relevant market to incentivise market participants to contain the energy within that area.","title":"Aziiz pricing"},{"location":"grid-operator-api/#script-configuration","text":"As mentioned on this page, at the start of the API script the user needs to specify the markets she/he wishes to connect and manage and the oracle name. Right after that the user selects the strategy to use (Time of Use or Aziiz model). To select the Time of Use strategy the user needs to set TimeOfUse to True and Aziiz to False. On the other hand, to select the Aziiz model, the user has to set TimeOfUse to False and Aziiz to True. If the Aziiz model is selected, the user can tune parameters such as applying the moving average and specifying the number of past market slots to average. For both strategies, the script reads an Excel file to adjust the grid fees ( ToU.xlsx and Aziiz.xlsx ). In ToU.xlsx the user can define the grid fees for each market she/he manages for every quarter hours of the day. In Aziiz.xlsx grid fees can be set for every peak import/export thresholds for each market. The Aziiz strategy will compare the average of the last markets\u2019 peak import/export to the threshold. If the average is lower than the threshold the relevant grid fee will be applied (for instance on the figure below if the average peak is equal to 22kWh, the next grid fee will be 3 cents/KWh. Each sheet\u2019s name represents the market connected to. On_market_slot event is used to gather market statistics and set the grid fees for the next market slot. In these lines , the API is requesting dso market statistics from the simulation. After that, the API is storing some of the relevant market data to local variables, easier to manipulate. To improve the API monitoring, the script is printing relevant data in the terminal: In these lines , the script applies the grid fee depending on the fee strategy defined at the start. If the Time of Use was set, the markets\u2019 grid fee is set based on the ToU excel file. If the Aziiz model was chosen the next fee is defined based on the Aziiz excel file. Additionally if the peak import/export is higher than all threshold defined in the excel sheets this sets the next fee as 2000cts/kWh. All the fees are added to the batch command and then executed . After that the script prints the current fee and next fee for each market. Later, the on_event_or_response is overwritten. By default we do not perform any operation in this event but the user could add some if needed. For instance the user could record all the grid fee change responses received in that event. Lastly the API script overwrites the on_finish event so that whenever the function is triggered the script stops. If the user wishes to save some information recorded within the API client this would be the opportunity to export them to external files. The rest of the scrip is used to connect to a running simulation/collaboration/canary network. These lines should work as is and no changes are required. Please find the following tutorial describing the required steps to run the grid operator API locally and on a collaboration:","title":"Script Configuration"},{"location":"inter-area-agent/","text":"The Inter-Area Agent (IAA) plays a crucial role in the communication architecture of Grid Singularity\u2019s exchange engine (D3A), allowing different markets in the hierarchy to interact and trade with each other. IAA is created for each market (households/buildings, streets, etc. that do not have preset trading strategies) and mainly deals with forwarding bids and offers markets of different hierarchy levels. The following illustration shows a sample grid setup and the role of the IAA in the market hierarchy during one time slot: The IAA is responsible for modelling hierarchical market operations, as follows: Forwarding bids and offers from a lower hierarchy (market) to an upper hierarchy. Reacting to bids, offers and trades reported by IAAs in connected markets, in order to propagate the event for an offer/bid that has been forwarded from this IAA. Triggering the matching of bids and offers for the two-sided market. To prioritize local trades, IAAs forward bids and offers to higher/lower markets with a two-tick delay.","title":"Bids/Offers Process and Hierarchical Market Structure"},{"location":"ios-installation-instructions/","text":"Step 1: Installation prerequisites: \u00b6 make sure the command line compiler tools are installed: \u00b6 xcode-select --install (Select Install in the window that opens) Step 2: Install homebrew \u00b6 /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" Step 3: Install other required libraries: \u00b6 brew install automake libtool pkg-config libffi gmp openssl readline xz Step 4: Install pyenv: \u00b6 brew install pyenv echo -e 'if command -v pyenv 1>/dev/null 2>&1; then\\n eval \"$(pyenv init -)\"\\nfi' >> ~/.bash_profile Step 5: Close and re-open the terminal \u00b6 Step 6: Install python 3.6 and set as default: \u00b6 pyenv install 3.8.6 pyenv global 3.8.6 Step 7: Install virtualenvwrapper: \u00b6 pip install virtualenvwrapper echo -e 'export WORKON_HOME=~/Envs\\nsource ~/.pyenv/versions/3.8.6/bin/virtualenvwrapper.sh' >> ~/.bash_profile Step 8: Setup paths for compiling python libraries: \u00b6 echo -e 'BREW_PREFIX=\"$(brew --prefix openssl)\"\\nexport CFLAGS=\"-I${BREW_PREFIX}/include\"\\nexport LDFLAGS=\"-L${BREW_PREFIX}/lib\"' >> ~/.bash_profile Step 9: Close and re-open the terminal \u00b6 Step 10: Clone Grid Singularity D3A repository (do this inside the directory where you want the project to be): \u00b6 git clone \"https://github.com/gridsingularity/d3a.git\" cd d3a Step 11: Create and initialize d3a virtualenv \u00b6 brew install npm npm install --global ganache-cli mkvirtualenv d3a pip install pendulum pip-tools pip install -e . You now should have a working d3a setup. For help in the terminal ani to test your installation, run d3a run -\u2013help .","title":"Mac Installation Instructions"},{"location":"ios-installation-instructions/#step-1-installation-prerequisites","text":"","title":"Step 1: Installation prerequisites:"},{"location":"ios-installation-instructions/#make-sure-the-command-line-compiler-tools-are-installed","text":"xcode-select --install (Select Install in the window that opens)","title":"make sure the command line compiler tools are installed:"},{"location":"ios-installation-instructions/#step-2-install-homebrew","text":"/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"","title":"Step 2: Install homebrew"},{"location":"ios-installation-instructions/#step-3-install-other-required-libraries","text":"brew install automake libtool pkg-config libffi gmp openssl readline xz","title":"Step 3: Install other required libraries:"},{"location":"ios-installation-instructions/#step-4-install-pyenv","text":"brew install pyenv echo -e 'if command -v pyenv 1>/dev/null 2>&1; then\\n eval \"$(pyenv init -)\"\\nfi' >> ~/.bash_profile","title":"Step 4: Install pyenv:"},{"location":"ios-installation-instructions/#step-5-close-and-re-open-the-terminal","text":"","title":"Step 5: Close and re-open the terminal"},{"location":"ios-installation-instructions/#step-6-install-python-36-and-set-as-default","text":"pyenv install 3.8.6 pyenv global 3.8.6","title":"Step 6: Install python 3.6 and set as default:"},{"location":"ios-installation-instructions/#step-7-install-virtualenvwrapper","text":"pip install virtualenvwrapper echo -e 'export WORKON_HOME=~/Envs\\nsource ~/.pyenv/versions/3.8.6/bin/virtualenvwrapper.sh' >> ~/.bash_profile","title":"Step 7: Install virtualenvwrapper:"},{"location":"ios-installation-instructions/#step-8-setup-paths-for-compiling-python-libraries","text":"echo -e 'BREW_PREFIX=\"$(brew --prefix openssl)\"\\nexport CFLAGS=\"-I${BREW_PREFIX}/include\"\\nexport LDFLAGS=\"-L${BREW_PREFIX}/lib\"' >> ~/.bash_profile","title":"Step 8: Setup paths for compiling python libraries:"},{"location":"ios-installation-instructions/#step-9-close-and-re-open-the-terminal","text":"","title":"Step 9: Close and re-open the terminal"},{"location":"ios-installation-instructions/#step-10-clone-grid-singularity-d3a-repository-do-this-inside-the-directory-where-you-want-the-project-to-be","text":"git clone \"https://github.com/gridsingularity/d3a.git\" cd d3a","title":"Step 10: Clone Grid Singularity D3A repository (do this inside the directory where you want the project to be):"},{"location":"ios-installation-instructions/#step-11-create-and-initialize-d3a-virtualenv","text":"brew install npm npm install --global ganache-cli mkvirtualenv d3a pip install pendulum pip-tools pip install -e . You now should have a working d3a setup. For help in the terminal ani to test your installation, run d3a run -\u2013help .","title":"Step 11: Create and initialize d3a virtualenv"},{"location":"library/","text":"Libraries contain preconfigured energy assets, markets, and even small grids that can be reused in different simulations (e.g. loads, PVs, houses and even entire communities). The list of libraries is paginated. You can either click through the pages by pressing the Prev or Next button in the bottom right corner or use the search field in the top right corner to filter the list by the library names. The following buttons and labels can be seen in the Library page: Denotes public libraries (other users can see the Library and the uploaded profiles): & (in the search bar) Quicklook labels for showing type and number of assets and the number of markets in the library: With this button the user can edit library content or view public libraries: With this button the user can rename, duplicate or delete an existing library (only user\u2019s own library may be deleted): The user can also create a new library (button redirects to Grid setup ):","title":"Asset and Data Library"},{"location":"licensing/","text":"Grid Singularity\u2019s software is available under an open source GNU General Public License . We believe that disruptive innovation yields new solutions to bring about the energy transition and can only be achieved by an open source community. The GPLv.3 license protects our code in a way that anyone who wishes to pursue proprietary commercialisation of the software would need to apply for a license, while open source applications supporting sustainable development continue to be free.","title":"Licensing and Open Source Ethos"},{"location":"linux-installation-instructions/","text":"Installing Grid Singularity energy exchange (D3A) on Linux Ubuntu 18.04: \u00b6 Step 1: In case you have not already installed git, python3.8 and pip (otherwise please go directly to step 2): \u00b6 sudo apt-get update sudo apt-get install git-core software-properties-common -y sudo add-apt-repository ppa:deadsnakes/ppa sudo apt-get update sudo apt-get install python3.8 -y sudo apt-get install git-core -y sudo apt-get install python3-pip -y Step 2: Install virtualenv and create a python virtual environment \u00b6 pip3 install virtualenv mkdir envs cd envs virtualenv -p /usr/bin/python3.8 d3a How to activate the environment: \u00b6 source d3a/bin/activate How to deactivate the environment: \u00b6 deactivate Step 3: Please add the following lines to your .bashrc and reopen the shell: \u00b6 export LC_ALL=C.UTF-8 export LANG=C.UTF-8 Step 4: Clone the Grid Singularity D3A repository to a directory of your choice: \u00b6 git clone https://github.com/gridsingularity/d3a.git Step 5: Install the Grid Singularity energy exchange (D3A): \u00b6 Activate your virtual environment and go into the d3a repository \u00b6 source d3a/bin/activate Install pip-tools \u00b6 pip3 install pendulum pip-tools Install dependencies \u00b6 pip install -e. Now, if you run d3a run -\u2013help , the help of d3a should be shown. Installing Grid Singularity energy exchange (D3A) on Linux Ubuntu 20.04: \u00b6 Please follow the installation instructions for Ubuntu 18.04 If case you encounter the following error error: command 'x86_64-linux-gnu-gcc' failed with exit status 1 please install the following package: sudo apt-get install build-essential python3.8-dev -y","title":"Linux Installation Instructions"},{"location":"linux-installation-instructions/#installing-grid-singularity-energy-exchange-d3a-on-linux-ubuntu-1804","text":"","title":"Installing Grid Singularity energy exchange (D3A) on Linux Ubuntu 18.04:"},{"location":"linux-installation-instructions/#step-1-in-case-you-have-not-already-installed-git-python38-and-pip-otherwise-please-go-directly-to-step-2","text":"sudo apt-get update sudo apt-get install git-core software-properties-common -y sudo add-apt-repository ppa:deadsnakes/ppa sudo apt-get update sudo apt-get install python3.8 -y sudo apt-get install git-core -y sudo apt-get install python3-pip -y","title":"Step 1: In case you have not already installed git, python3.8 and pip (otherwise please go directly to step 2):"},{"location":"linux-installation-instructions/#step-2-install-virtualenv-and-create-a-python-virtual-environment","text":"pip3 install virtualenv mkdir envs cd envs virtualenv -p /usr/bin/python3.8 d3a","title":"Step 2: Install virtualenv and create a python virtual environment"},{"location":"linux-installation-instructions/#how-to-activate-the-environment","text":"source d3a/bin/activate","title":"How to activate the environment:"},{"location":"linux-installation-instructions/#how-to-deactivate-the-environment","text":"deactivate","title":"How to deactivate the environment:"},{"location":"linux-installation-instructions/#step-3-please-add-the-following-lines-to-your-bashrc-and-reopen-the-shell","text":"export LC_ALL=C.UTF-8 export LANG=C.UTF-8","title":"Step 3: Please add the following lines to your .bashrc and reopen the shell:"},{"location":"linux-installation-instructions/#step-4-clone-the-grid-singularity-d3a-repository-to-a-directory-of-your-choice","text":"git clone https://github.com/gridsingularity/d3a.git","title":"Step 4: Clone the Grid Singularity D3A repository to a directory of your choice:"},{"location":"linux-installation-instructions/#step-5-install-the-grid-singularity-energy-exchange-d3a","text":"","title":"Step 5: Install the Grid Singularity energy exchange (D3A):"},{"location":"linux-installation-instructions/#activate-your-virtual-environment-and-go-into-the-d3a-repository","text":"source d3a/bin/activate","title":"Activate your virtual environment and go into the d3a repository"},{"location":"linux-installation-instructions/#install-pip-tools","text":"pip3 install pendulum pip-tools","title":"Install pip-tools"},{"location":"linux-installation-instructions/#install-dependencies","text":"pip install -e. Now, if you run d3a run -\u2013help , the help of d3a should be shown.","title":"Install dependencies"},{"location":"linux-installation-instructions/#installing-grid-singularity-energy-exchange-d3a-on-linux-ubuntu-2004","text":"Please follow the installation instructions for Ubuntu 18.04 If case you encounter the following error error: command 'x86_64-linux-gnu-gcc' failed with exit status 1 please install the following package: sudo apt-get install build-essential python3.8-dev -y","title":"Installing Grid Singularity energy exchange (D3A) on Linux Ubuntu 20.04:"},{"location":"map/","text":"In the User Interface , each energy asset and market can be pinned on a map with geographic coordinates in the form of a geotag, linked to a physical address . If a geotag is set at the market level, all submarkets and their assets are tied to these coordinates. In this example, Neuk\u00f6ln market includes all submarkets and assets under the same geotag (House 1, House 2, PV 4, Market and PV 5). If a market geo-tag type is set to location , the market can be pinned on the map and all of its submarkets and assets will inherit the same location: In this example, House 2\u2019s assets are assigned the same location as the House 2 submarket. Once the user has added locations via geotags for its markets and energy assets, the simulation will be shown on the Grid Singularity\u2019s public map, which will disclose the location of the simulation\u2019s highest market and the total number of markets and energy assets. For a video tutorial on the map feature, please follow this link .","title":"Map"},{"location":"markets/","text":"Market Types \u00b6 The main goal of an electricity market exchange is to balance the grid in terms of demand and supply. Since efficient storage of large quantities of energy is currently not economically feasible and electrical current varies within seconds, a market mechanism that efficiently accounts for the physical energy production and consumption is required. Generally, trading occurs in three types of markets with different time intervals: Spot market : short-term trades for immediate or near-term delivery. Energy transactions are divided into small time blocks (typically 15 minute slots) that can either be traded on the Day-ahead or in the Intraday market. Balancing market : imbalances that occur due to deviations between energy traded in the spot market and actual energy consumption and production are absorbed by balance responsible parties (BRP) that are reimbursed for their service with a fee based on the energy deviation. Futures market : trades for the longer term future consumption and production of energy are agreed in advance. This market is currently outside the scope of Grid Singularity energy exchange implementation. The current implementation of Grid Singularity software focuses on the spot and balancing markets. Balancing markets take place immediately after each spot market slot (if enabled). The duration of the markets can be configured. Currently, three spot market types are implemented: One-sided Pay-as-Offer Two-sided Pay-as-Bid Two-sided Pay-as-Clear Market Slots \u00b6 The energy spot market is broken into time slots, with the default set to 15 minutes of simulated time. For a one-day simulation, 96 market slots would occur with the default setting. Learn how to adjust market slot length here . Depending on the market type, bids and offers are either matched within or at the end of each slot. Bids and offers that remain unmatched at the end of a market slot are annulled, and assets may be penalised for any energy they physically produce or consume that is not transacted for. Market Ticks \u00b6 Each slot is further segmented into ticks. The default setting for a tick is 15 seconds of simulated time (simulated time is the time unit within a simulation as opposed to real-time which is the real-life time that the simulation takes; e.g. a simulation can simulate 7 days of trading in minutes or hours), and this configuration may be changed. The default 15 minute market slot is made up of 60 15-second ticks. In a pay-as-bid market, the market is cleared at the end of each tick. If an order is not matched, it is propagated to all adjacent markets by an Inter-Area Agent after two ticks. If an order is not matched at the end of two next ticks, it is further propagated to connected markets in the subsequent ticks following the same logic.","title":"Market Types: Spot, Balancing, and Futures"},{"location":"markets/#market-types","text":"The main goal of an electricity market exchange is to balance the grid in terms of demand and supply. Since efficient storage of large quantities of energy is currently not economically feasible and electrical current varies within seconds, a market mechanism that efficiently accounts for the physical energy production and consumption is required. Generally, trading occurs in three types of markets with different time intervals: Spot market : short-term trades for immediate or near-term delivery. Energy transactions are divided into small time blocks (typically 15 minute slots) that can either be traded on the Day-ahead or in the Intraday market. Balancing market : imbalances that occur due to deviations between energy traded in the spot market and actual energy consumption and production are absorbed by balance responsible parties (BRP) that are reimbursed for their service with a fee based on the energy deviation. Futures market : trades for the longer term future consumption and production of energy are agreed in advance. This market is currently outside the scope of Grid Singularity energy exchange implementation. The current implementation of Grid Singularity software focuses on the spot and balancing markets. Balancing markets take place immediately after each spot market slot (if enabled). The duration of the markets can be configured. Currently, three spot market types are implemented: One-sided Pay-as-Offer Two-sided Pay-as-Bid Two-sided Pay-as-Clear","title":"Market Types"},{"location":"markets/#market-slots","text":"The energy spot market is broken into time slots, with the default set to 15 minutes of simulated time. For a one-day simulation, 96 market slots would occur with the default setting. Learn how to adjust market slot length here . Depending on the market type, bids and offers are either matched within or at the end of each slot. Bids and offers that remain unmatched at the end of a market slot are annulled, and assets may be penalised for any energy they physically produce or consume that is not transacted for.","title":"Market Slots"},{"location":"markets/#market-ticks","text":"Each slot is further segmented into ticks. The default setting for a tick is 15 seconds of simulated time (simulated time is the time unit within a simulation as opposed to real-time which is the real-life time that the simulation takes; e.g. a simulation can simulate 7 days of trading in minutes or hours), and this configuration may be changed. The default 15 minute market slot is made up of 60 15-second ticks. In a pay-as-bid market, the market is cleared at the end of each tick. If an order is not matched, it is propagated to all adjacent markets by an Inter-Area Agent after two ticks. If an order is not matched at the end of two next ticks, it is further propagated to connected markets in the subsequent ticks following the same logic.","title":"Market Ticks"},{"location":"model-load/","text":"The load is an energy asset that consumes energy over time. It is possible to use a single load to represent an entire consuming building, as well as to configure multiple loads to represent different assets within a building (e.g. washing machine, air-conditioner, etc.). User Interface Configuration \u00b6 The following parameters can be configured: Load name : Must be unique Load profile : The user can choose between two options: User upload profile (a load profile can be uploaded when compliant with Upload File Formats) User configure profile (the user provides the load average power) Average power : average consuming power of the load in Watts. Hours per day : The number of hours the load operates per day. Hours of day : The time range in which the load operates. Initial buying rate : Initial energy buying rate at the beginning of each market slot in cents/kWh. Final buying rate : Final energy buying rate at the end of each market slot in cents/kWh. It can either be a user-defined value or equal to the Market Maker + Grid Fee. Rate increase : Explicit rate increase increment per update interval in cents/kWh Fit to limits : Derive bidding behavior from a linear fitted curve of a buying rate between initial_buying_rate and final_buying_rate within the bidding interval. If activated, energy rate_increase = (final_buying_rate - initial_buying_rate) / max(int((slot_length / update_interval) -1), 1) Update interval : The frequency at which the rate is updated. The Load configuration interface is shown below: Backend Configuration \u00b6 To implement the load in a backend simulation, two options are available : User configure Profile Market ( 'Load' , strategy = LoadHoursStrategy ( avg_power_W = 200 , hrs_per_day = 6 , hrs_of_day = list ( range ( 12 , 18 )), initial_buying_rate = 0 , final_buying_rate = 35 )) User upload Profile user_profile_path = os . path . join ( d3a_path , \"assets/load.csv\" ) Market ( 'Load' , strategy = LoadProfileStrategy ( daily_load_profile = user_profile_path , initial_buying_rate = 0 , final_buying_rate = 35 )) Addendum: hrs_of_day and hrs_per_day \u00b6 hrs_of_day defines the allowed time-window in which the load has to consume for a time defined by hrs_per_day. For example, a user can input 5 hrs_per_day and give a wider range for hrs_of_day like (2,18). The Load will try to consume as fast as possible during this time if there is any offered energy to purchase within the limits of initial_buying_rate and final_buying_rate set parameters. If there is sufficient energy at affordable rates, the load will consume in the first 5 hours, i.e. from 02:00 until 07:00, with no energy demand unmatched. In case energy prices are too high during the time-interval from 04:00 to 16:00, the load will consume from 02:00 until 04:00, turn off, and consume from 16:00 until 18:00, resulting in one hour of energy demand unmatched. For information on changes in buying and selling rates, please see: Trading strategies","title":"Load"},{"location":"model-load/#user-interface-configuration","text":"The following parameters can be configured: Load name : Must be unique Load profile : The user can choose between two options: User upload profile (a load profile can be uploaded when compliant with Upload File Formats) User configure profile (the user provides the load average power) Average power : average consuming power of the load in Watts. Hours per day : The number of hours the load operates per day. Hours of day : The time range in which the load operates. Initial buying rate : Initial energy buying rate at the beginning of each market slot in cents/kWh. Final buying rate : Final energy buying rate at the end of each market slot in cents/kWh. It can either be a user-defined value or equal to the Market Maker + Grid Fee. Rate increase : Explicit rate increase increment per update interval in cents/kWh Fit to limits : Derive bidding behavior from a linear fitted curve of a buying rate between initial_buying_rate and final_buying_rate within the bidding interval. If activated, energy rate_increase = (final_buying_rate - initial_buying_rate) / max(int((slot_length / update_interval) -1), 1) Update interval : The frequency at which the rate is updated. The Load configuration interface is shown below:","title":"User Interface Configuration"},{"location":"model-load/#backend-configuration","text":"To implement the load in a backend simulation, two options are available : User configure Profile Market ( 'Load' , strategy = LoadHoursStrategy ( avg_power_W = 200 , hrs_per_day = 6 , hrs_of_day = list ( range ( 12 , 18 )), initial_buying_rate = 0 , final_buying_rate = 35 )) User upload Profile user_profile_path = os . path . join ( d3a_path , \"assets/load.csv\" ) Market ( 'Load' , strategy = LoadProfileStrategy ( daily_load_profile = user_profile_path , initial_buying_rate = 0 , final_buying_rate = 35 ))","title":"Backend Configuration"},{"location":"model-load/#addendum-hrs_of_day-and-hrs_per_day","text":"hrs_of_day defines the allowed time-window in which the load has to consume for a time defined by hrs_per_day. For example, a user can input 5 hrs_per_day and give a wider range for hrs_of_day like (2,18). The Load will try to consume as fast as possible during this time if there is any offered energy to purchase within the limits of initial_buying_rate and final_buying_rate set parameters. If there is sufficient energy at affordable rates, the load will consume in the first 5 hours, i.e. from 02:00 until 07:00, with no energy demand unmatched. In case energy prices are too high during the time-interval from 04:00 to 16:00, the load will consume from 02:00 until 04:00, turn off, and consume from 16:00 until 18:00, resulting in one hour of energy demand unmatched. For information on changes in buying and selling rates, please see: Trading strategies","title":"Addendum: hrs_of_day and hrs_per_day"},{"location":"model-market-maker/","text":"The Market Maker mimics the behaviour of a typical energy utility and is used as a price reference point. Only one Market Maker can be set per simulation. The Market Maker can be configured to sell an infinite amount of energy as well as to buy an infinite amount of energy to simulate a Feed-in Tariff. User Interface Configuration \u00b6 The following parameters can be set: Name : The name of the Market Maker. Mode : The user has two options: Infinite power plant: In this mode, it has the ability to meet the infinite energy demand of consumers at the highest rate possible in that grid. Infinite bus: In this mode, the Market Maker has not only the ability to meet the infinite energy demand of the consumer but can also absorb the infinite generation surplus of prosumers/producers at the lowest rate possible in that grid. Role : The user has two options: Grid connected : In this mode, the Market Maker is connected to the grid and thus can fulfil the energy demand of any consumer and absorb surplus generation (if infinite bus mode selected) Islanded : In this mode, the Market Maker would only be used as a reference point for the highest possible energy_rate in that grid. Selling rate type : The user can either select User Input to define a fixed selling rate or upload their custom selling rate profile. Selling rate : The fixed rate the Market Maker will enforce, if User Input is chosen for the selling rate type. Buying rate type (infinite bus only) : The user can either select User Input to define a fixed buying rate or upload their custom buying rate profile. Buying rate (infinite bus only) : The fixed rate the Market Maker will enforce, if User Input is chosen for the buying rate type. The Market Maker configuration interface is shown below: Backend Configuration \u00b6 To implement a market maker in a backend simulation, two methods are available : infinite power plant : Market ( 'Market Maker' , strategy = MarketMakerStrategy ( energy_rate = selling_rate , grid_connected = True )) infinite bus : Market ( 'Market Maker' , strategy = InfiniteBusStrategy ( energy_buy_rate = 22 , energy_sell_rate = 22 ))","title":"Market Maker and Infinite Bus"},{"location":"model-market-maker/#user-interface-configuration","text":"The following parameters can be set: Name : The name of the Market Maker. Mode : The user has two options: Infinite power plant: In this mode, it has the ability to meet the infinite energy demand of consumers at the highest rate possible in that grid. Infinite bus: In this mode, the Market Maker has not only the ability to meet the infinite energy demand of the consumer but can also absorb the infinite generation surplus of prosumers/producers at the lowest rate possible in that grid. Role : The user has two options: Grid connected : In this mode, the Market Maker is connected to the grid and thus can fulfil the energy demand of any consumer and absorb surplus generation (if infinite bus mode selected) Islanded : In this mode, the Market Maker would only be used as a reference point for the highest possible energy_rate in that grid. Selling rate type : The user can either select User Input to define a fixed selling rate or upload their custom selling rate profile. Selling rate : The fixed rate the Market Maker will enforce, if User Input is chosen for the selling rate type. Buying rate type (infinite bus only) : The user can either select User Input to define a fixed buying rate or upload their custom buying rate profile. Buying rate (infinite bus only) : The fixed rate the Market Maker will enforce, if User Input is chosen for the buying rate type. The Market Maker configuration interface is shown below:","title":"User Interface Configuration"},{"location":"model-market-maker/#backend-configuration","text":"To implement a market maker in a backend simulation, two methods are available : infinite power plant : Market ( 'Market Maker' , strategy = MarketMakerStrategy ( energy_rate = selling_rate , grid_connected = True )) infinite bus : Market ( 'Market Maker' , strategy = InfiniteBusStrategy ( energy_buy_rate = 22 , energy_sell_rate = 22 ))","title":"Backend Configuration"},{"location":"model-markets/","text":"Markets contain submarkets and energy assets. Energy assets can post bids and offers in their market. Markets are interconnected by inter-area agents in a hierarchical network, which pass bids and offers between markets until they are matched, following a select market clearing mechanism . User Interface configuration \u00b6 The following market parameters can be set: Name : Must be unique Grid fee : If set to yes and with a non-None value, a fee will be applied to each trade that passes through or is cleared in this market. The grid fee is either constant , expressed in cents/kWh, or variable , expressed as a share of total price in percentage terms (%) depending on the parameters set in the simulation general settings . Transformers capacity : Import and export limits of the transformer in kVA. In the current implementation these limits are purely visual indicators and do not limit actual import/export of the market. Baseline import/export : Allows the user to compare the current simulation imports/exports to a baseline, set in kWh. These values are used in the calculation of the Peak Percentage KPI . The simulation configuration interface is shown below: Backend configuration \u00b6 These parameters can be set in the backend in the Area / Market class : Area ( 'Market' , [ ... \"some assets here\" ], grid_fee_constant = 2 , throughput = ThroughputParameters ( import_capacity_kVA = 2.0 , export_capacity_kVA = 2.0 , baseline_peak_energy_import_kWh = 0.4 , baseline_peak_energy_export_kWh = 0.4 ))","title":"Market Settings"},{"location":"model-markets/#user-interface-configuration","text":"The following market parameters can be set: Name : Must be unique Grid fee : If set to yes and with a non-None value, a fee will be applied to each trade that passes through or is cleared in this market. The grid fee is either constant , expressed in cents/kWh, or variable , expressed as a share of total price in percentage terms (%) depending on the parameters set in the simulation general settings . Transformers capacity : Import and export limits of the transformer in kVA. In the current implementation these limits are purely visual indicators and do not limit actual import/export of the market. Baseline import/export : Allows the user to compare the current simulation imports/exports to a baseline, set in kWh. These values are used in the calculation of the Peak Percentage KPI . The simulation configuration interface is shown below:","title":"User Interface configuration"},{"location":"model-markets/#backend-configuration","text":"These parameters can be set in the backend in the Area / Market class : Area ( 'Market' , [ ... \"some assets here\" ], grid_fee_constant = 2 , throughput = ThroughputParameters ( import_capacity_kVA = 2.0 , export_capacity_kVA = 2.0 , baseline_peak_energy_import_kWh = 0.4 , baseline_peak_energy_export_kWh = 0.4 ))","title":"Backend configuration"},{"location":"model-power-plant/","text":"A finite power plant is an energy supplier that offers a configurable amount of power per time slot at a set rate. User Interface Configuration \u00b6 The following parameters can be configured: Name : Must be unique. Energy rate : Selling price of the power plant in cents/kWh. Maximum available power : Maximum power that the power plant can supply in kW (in the backend this parameter can also be set based on an uploaded profile). The configuration interface is shown below: Backend Configuration \u00b6 To implement the power plant in a backend simulation one option is available: Finite Power Plant profile_kW = { 0 : 0.1 , 8 : 0.15 , 12 : 0.2 , 19 : 0.15 , 22 : 0.1 } Market ( \"Power Plant', strategy=FinitePowerPlant(energy_rate=31.3, max_available_power_kW=profile_kW))","title":"Power Plant"},{"location":"model-power-plant/#user-interface-configuration","text":"The following parameters can be configured: Name : Must be unique. Energy rate : Selling price of the power plant in cents/kWh. Maximum available power : Maximum power that the power plant can supply in kW (in the backend this parameter can also be set based on an uploaded profile). The configuration interface is shown below:","title":"User Interface Configuration"},{"location":"model-power-plant/#backend-configuration","text":"To implement the power plant in a backend simulation one option is available: Finite Power Plant profile_kW = { 0 : 0.1 , 8 : 0.15 , 12 : 0.2 , 19 : 0.15 , 22 : 0.1 } Market ( \"Power Plant', strategy=FinitePowerPlant(energy_rate=31.3, max_available_power_kW=profile_kW))","title":"Backend Configuration"},{"location":"model-pv/","text":"A photovoltaic (PV) is an energy asset that converts solar irradiation into electricity. In our software, each PV component can represent a single panel, array of panels or an entire PV park. User Interface Configuration \u00b6 The following parameters can be configured: Name : Must be unique Panel count : Number of PV panels, each with a power of 250W. Solar Profile : The user can choose among multiple template solar profiles (sunny, partially cloudy or cloudy). The usery can also create a custom Gaussian curve or upload their own generation profile. Initial selling rate : Initial (and maximum) energy rate that the PV offers at the beginning of each market slot in cents/kWh. Final selling rate : Final energy rate that the PV offers at the end of each market slot in cents/kWh. Rate decrease : Explicit rate decrease increment in cents/kWh. Fit to limits : Derive bidding behavior from a linear fitted curve of a selling rate ranging from initial_selling_rate to final_selling_rate within the bidding interval. If activated, energy_rate_decrease_per_update = (initial_selling_rate - final_selling_rate) / max(int((slot_length / update_interval) -1), 1) Update interval : The frequency at which the rate is updated. The PV configuration interface is shown in the figure below: Backend Configuration \u00b6 There are two options to implement a PV in a backend: Solar Profile (for template generation profile) Market ( 'H2 PV' , strategy = PVStrategy ( panel_count = 4 , initial_selling_rate = 30 , final_selling_rate = 5 , fit_to_limit = True , update_interval = duration ( minutes = 5 ))) User Profile (for uploaded generation profile) user_profile_path = os . path . join ( d3a_path , \"assets/Solar_Curve_W_sunny.csv\" ) Market ( 'H1 PV' , strategy = PVUserProfileStrategy ( power_profile = user_profile_path , panel_count = ))","title":"PV"},{"location":"model-pv/#user-interface-configuration","text":"The following parameters can be configured: Name : Must be unique Panel count : Number of PV panels, each with a power of 250W. Solar Profile : The user can choose among multiple template solar profiles (sunny, partially cloudy or cloudy). The usery can also create a custom Gaussian curve or upload their own generation profile. Initial selling rate : Initial (and maximum) energy rate that the PV offers at the beginning of each market slot in cents/kWh. Final selling rate : Final energy rate that the PV offers at the end of each market slot in cents/kWh. Rate decrease : Explicit rate decrease increment in cents/kWh. Fit to limits : Derive bidding behavior from a linear fitted curve of a selling rate ranging from initial_selling_rate to final_selling_rate within the bidding interval. If activated, energy_rate_decrease_per_update = (initial_selling_rate - final_selling_rate) / max(int((slot_length / update_interval) -1), 1) Update interval : The frequency at which the rate is updated. The PV configuration interface is shown in the figure below:","title":"User Interface Configuration"},{"location":"model-pv/#backend-configuration","text":"There are two options to implement a PV in a backend: Solar Profile (for template generation profile) Market ( 'H2 PV' , strategy = PVStrategy ( panel_count = 4 , initial_selling_rate = 30 , final_selling_rate = 5 , fit_to_limit = True , update_interval = duration ( minutes = 5 ))) User Profile (for uploaded generation profile) user_profile_path = os . path . join ( d3a_path , \"assets/Solar_Curve_W_sunny.csv\" ) Market ( 'H1 PV' , strategy = PVUserProfileStrategy ( power_profile = user_profile_path , panel_count = ))","title":"Backend Configuration"},{"location":"model-storage/","text":"The storage simulates energy assets capable of storing or discharging energy (e.g. Lithium batteries, compressed air energy storage). User Interface Configuration \u00b6 The following parameters can be configured: Name : Must be unique Battery capacity : Total energy capacity. Initial capacity : Can be set in two ways: Initial State of Charge - SOC (in %) Initial Energy (in kWh) Minimum SOC : Minimum energy to leave in the storage. Max power rating for battery : Power limit for each market slot for sold and bought energy. Initial selling rate : Initial energy rate for selling energy at the beginning of each market slot in cents/kWh. Final selling rate : Final energy rate for selling energy at the end of each market slot in cents/kWh. Rate decrease : Explicit rate decrease increment in cents/kWh. Initial buying rate : Initial energy rate for buying energy at the beginning of each market slot in cents/kWh. Final buying rate : Final energy rate for buying energy at the end of each market slot in cents/kWh. Rate increase : Explicit rate increase increment in cents/kWh. Fit to limits : Derive bidding behavior from a linear fitted curve of a buying rate between initial_buying_rate and final_buying_rate and a selling rate between initial_selling_rate and final_selling_rate within the bidding interval. If activated: energy_rate_increase = (final_buying_rate - initial_buying_rate) / max(int((slot_length / update_interval) -1), 1) energy_rate_decrease_per_update = (initial_selling_rate - final_selling_rate) / max(int((slot_length / update_interval) -1), 1) Update interval : The frequency at which the rate is updated. Capacity based method : The storage can trade energy based on a capacity dependent sell price (see addendum). Note: For the time being, the storage component has a 100% electric-to-electric efficiency by default. Changing this characteristic is not possible at the moment but it will be possible in the near future. Users are welcome to add additional features to our open source code base on GitHub. The storage configuration interface is shown below: Backend Configuration \u00b6 To implement the storage in a backend simulation one option is available: Energy Storage System Market ( 'Storage' , strategy = StorageStrategy ( initial_soc = 50 , energy_rate_decrease_per_update = 3 , battery_capacity_kWh = 1.2 , max_abs_battery_power_kW = 5 , final_buying_rate = 16.99 , final_selling_rate = 17.01 ))) Addendum: Storage Capacity Based Method \u00b6 This method was created to sell energy at lower prices during high state of charge - SOC (when the battery has more energy stored) and at higher prices during low SOC (when the battery can afford to sell its stored energy for less). If the cap_price_strategy is True , the offer price for the storage is calculated according to: offer_rate = initial_selling_rate - ((initial_selling_rate - final_selling_rate)\\*soc/100) As an example, considering an initial_selling_rate of 30 cents/kWh and a final_selling_rate of 20 cents/kWh, a storage with an SOC of 1% would sell its energy at 29.9 cents/kWh, and a battery at 100% SOC would sell its energy at 20 cents/kWh. Storage Behaviour in Local Energy Markets \u00b6 In general all bids and offers follow the physical constraint of the set max_abs_battery_power_kW value. The accumulated energy per market slot cannot exceed this power value times the length of the market slot. Energy sold and bought cancel each other out, meaning that if 2kWh are both sold and bought in the same market slot, the relative power remains 0kW. For the buying rate increase and selling rate decrease behaviour, please see the Trading Strategies page . Buying Energy in One-Sided Market : \u00b6 On each tick, the storage scans the connected market for affordable offers* if there is storage space to be filled (if the current SOC is lower than 100%). Once an offer is found, it is either fully or partially accepted, depending on the demand. The storage always seeks 100% SOC when buying energy. = affordable offers are offers that have a price lower or equal to the current acceptable energy rate. The acceptable energy rate changes during a market slot depending on the initial_buying_rate , final_buying_rate , energy_rate_decrease_per_update and update_interval setting. Buying Energy in Two-Sided Market : \u00b6 On each tick, the storage either places a bid for the quantity of energy it needs to reach 100% SOC or updates the price of an existing bid in the market where the bid rate depends on the initial_buying_rate , final_buying_rate , energy_rate_decrease_per_update and update_interval setting. Selling Energy \u00b6 At the beginning of each market slot, the storage places an offer for all the energy it has stored (not including the energy that is needed to keep the storage at least at min_allowed_soc). This offer is updated at each update_interval pursuant to the rate decrease settings. This mechanism applies in both one and two-sided market types. Consequently, it is possible for the storage to have both an offer and a bid placed in the same market.","title":"Storage"},{"location":"model-storage/#user-interface-configuration","text":"The following parameters can be configured: Name : Must be unique Battery capacity : Total energy capacity. Initial capacity : Can be set in two ways: Initial State of Charge - SOC (in %) Initial Energy (in kWh) Minimum SOC : Minimum energy to leave in the storage. Max power rating for battery : Power limit for each market slot for sold and bought energy. Initial selling rate : Initial energy rate for selling energy at the beginning of each market slot in cents/kWh. Final selling rate : Final energy rate for selling energy at the end of each market slot in cents/kWh. Rate decrease : Explicit rate decrease increment in cents/kWh. Initial buying rate : Initial energy rate for buying energy at the beginning of each market slot in cents/kWh. Final buying rate : Final energy rate for buying energy at the end of each market slot in cents/kWh. Rate increase : Explicit rate increase increment in cents/kWh. Fit to limits : Derive bidding behavior from a linear fitted curve of a buying rate between initial_buying_rate and final_buying_rate and a selling rate between initial_selling_rate and final_selling_rate within the bidding interval. If activated: energy_rate_increase = (final_buying_rate - initial_buying_rate) / max(int((slot_length / update_interval) -1), 1) energy_rate_decrease_per_update = (initial_selling_rate - final_selling_rate) / max(int((slot_length / update_interval) -1), 1) Update interval : The frequency at which the rate is updated. Capacity based method : The storage can trade energy based on a capacity dependent sell price (see addendum). Note: For the time being, the storage component has a 100% electric-to-electric efficiency by default. Changing this characteristic is not possible at the moment but it will be possible in the near future. Users are welcome to add additional features to our open source code base on GitHub. The storage configuration interface is shown below:","title":"User Interface Configuration"},{"location":"model-storage/#backend-configuration","text":"To implement the storage in a backend simulation one option is available: Energy Storage System Market ( 'Storage' , strategy = StorageStrategy ( initial_soc = 50 , energy_rate_decrease_per_update = 3 , battery_capacity_kWh = 1.2 , max_abs_battery_power_kW = 5 , final_buying_rate = 16.99 , final_selling_rate = 17.01 )))","title":"Backend Configuration"},{"location":"model-storage/#addendum-storage-capacity-based-method","text":"This method was created to sell energy at lower prices during high state of charge - SOC (when the battery has more energy stored) and at higher prices during low SOC (when the battery can afford to sell its stored energy for less). If the cap_price_strategy is True , the offer price for the storage is calculated according to: offer_rate = initial_selling_rate - ((initial_selling_rate - final_selling_rate)\\*soc/100) As an example, considering an initial_selling_rate of 30 cents/kWh and a final_selling_rate of 20 cents/kWh, a storage with an SOC of 1% would sell its energy at 29.9 cents/kWh, and a battery at 100% SOC would sell its energy at 20 cents/kWh.","title":"Addendum: Storage Capacity Based Method"},{"location":"model-storage/#storage-behaviour-in-local-energy-markets","text":"In general all bids and offers follow the physical constraint of the set max_abs_battery_power_kW value. The accumulated energy per market slot cannot exceed this power value times the length of the market slot. Energy sold and bought cancel each other out, meaning that if 2kWh are both sold and bought in the same market slot, the relative power remains 0kW. For the buying rate increase and selling rate decrease behaviour, please see the Trading Strategies page .","title":"Storage Behaviour in Local Energy Markets"},{"location":"model-storage/#buying-energy-in-one-sided-market","text":"On each tick, the storage scans the connected market for affordable offers* if there is storage space to be filled (if the current SOC is lower than 100%). Once an offer is found, it is either fully or partially accepted, depending on the demand. The storage always seeks 100% SOC when buying energy. = affordable offers are offers that have a price lower or equal to the current acceptable energy rate. The acceptable energy rate changes during a market slot depending on the initial_buying_rate , final_buying_rate , energy_rate_decrease_per_update and update_interval setting.","title":"Buying Energy in One-Sided Market:"},{"location":"model-storage/#buying-energy-in-two-sided-market","text":"On each tick, the storage either places a bid for the quantity of energy it needs to reach 100% SOC or updates the price of an existing bid in the market where the bid rate depends on the initial_buying_rate , final_buying_rate , energy_rate_decrease_per_update and update_interval setting.","title":"Buying Energy in Two-Sided Market:"},{"location":"model-storage/#selling-energy","text":"At the beginning of each market slot, the storage places an offer for all the energy it has stored (not including the energy that is needed to keep the storage at least at min_allowed_soc). This offer is updated at each update_interval pursuant to the rate decrease settings. This mechanism applies in both one and two-sided market types. Consequently, it is possible for the storage to have both an offer and a bid placed in the same market.","title":"Selling Energy"},{"location":"one-sided-pay-as-offer/","text":"In the One-Sided Pay-as-Offer market, agents representing energy producers, including prosumers ( sellers ) post offers in the market with an energy price determined by the assets' trading strategy . Agents representing consumers ( buyers ) can see the offers available in their local market, filter affordable offers and then select the most favorable offer. The energy rate on which the seller and buyer settle is the price of the offer (pay-as-offer). Consequently, the trade rate may differ for trades settled in the same slot. The auction is continuous , meaning that once an offer is posted, it can be accepted right away, even before the end of each market slot .","title":"One-Sided Pay-as-Offer Market"},{"location":"peak-percentage/","text":"The energy peak imports/exports is the maximum value of the aggregate imports/exports of each asset inside a market. The user has the possibility to set a baseline_peak_energy_import_kWh and a baseline_peak_energy_export_kWh that they may have gotten from another simulation in order to calculate the energy peak percentage, a tool used to measure how much the peak imports or exports have changed between a defined baseline and the current simulation. The user may be interested in the Energy Peak Percentage value to assess the impact of applied grid fees or different energy storage strategies on the peak imports and exports of a market. The Energy Peak Percentage can be calculated as follows : Import_peak_percentage = import_peak_energy_kWh / import_baseline_peak_energy_kWh * 100 Export_peak_percentage = export_peak_energy_kWh / export_baseline_peak_energy_kWh * 100 If the energy peak percentage is below 100% , the peak was reduced vs. the baseline. The energy peak was increased if the energy peak percentage value is above 100% .","title":"Peak Percentage"},{"location":"percentage-fees/","text":"The percentage grid fee is a market based fee, defined as a ratio (%) of the clearing price that is added to each trade that is cleared, as shown in the figure below. The price of a bid or offer changes as it is propagated into different markets to account for market fees. This way, a trading agent posting an offer will never receive less than offered and an agent making a bid will never pay more than bid. Example Calculation in One-Sided Pay-as-Offer Market \u00b6 In the One-Sided Pay-as-Offer market, there are no bids, only offers. The offers are propagated throughout the markets in the hierarchy. The grid fees are taken into account when an offer is forwarded to the higher market, by the higher market itself. Therefore the agent is not responsible for adapting the offer price to include the grid fees. The grid fees' unit is a ratio of the original offer price, therefore the formula to calculate the new offer price when placing an offer to a market is the following: offer_price_after_fees = offer_price + original_offer_price * grid_fee_ratio If the offer is not purchased after two ticks, it is moved into the next market, where the price is increased by that market\u2019s grid fee. In the provided example, the PV offer of 0.10\u20ac is first placed in the House 2 Market where it gains zero fees. Then it propagates into the Neighborhood 2 Market, gaining the market\u2019s fee of 5% of the original offer price 0.10*0.05+0.10=0.105\u20ac . If unmatched, it propagates into the Grid Market, with an additional 10% fee of the original offer is applied: 0.10*0.10+0.105=0.115\u20ac . Continuing into the Neighborhood 1 Market, the offer gains another fee of 5% of the original price 0.10*0.05+0.115=0.12\u20ac . Continuing into the House 1 Market, the offer gains zero additional fees as there is no fee in that market. The Load buys the offer in the House 1 Market at the Clearing Price of 0.12\u20ac. Starting with the initial offer price, the total fees are calculated 0.10*(1+0.05+0.10+0.05)=0.02 to yield the Trade Price of 0.12\u20ac. The Load pays the Trade Price of 0.12\u20ac, which includes 0.10\u20ac revenue for the PV, 0.005\u20ac fees for the Neighborhood Market 1, 0.01\u20ac fees for the Grid Market, and 0.005\u20ac fees for the Neighborhood Market 2. Since the market type is pay-as-offer, the offer rates are used as Clearing Rates. The trade price is then calculated by multiplying the clearing rate with the energy volume. For each market trade, the market grid fee is calculated based on the original offer rate and it is subtracted from the trade_price, in order to calculate the trade price after fees (and thus the revenue for the seller). The following formula is used: market_fees = grid_fee_ratio * original_rate * energy_portion trade_price_after_fees = energy * trade_rate - market_fees trade_price = energy * trade_rate Example Calculation in Two-Sided Pay-as-Bid Market \u00b6 In the Two-Sided Pay-as-Bid market, both bids and offers are propagated through the markets in the hierarchy. If a bid or offer is not purchased after two ticks , it propagates into the next market. In order to prevent double accounting of a market's grid fee when a bid and an offer are matched in that market, market fees are added to offers when they enter that market (target market) and subtracted from bids when they leave that market and enter another (source market). The formula for propagating the offers is the same as for the one-sided market: offer_price_after_fees = offer_price + original_offer_price * grid_fee_ratio The IAA subtracts the fees from the bid before propagating it to a higher market. The formula for an area to update the bid to include grid fees is the following: bid_price_after_fees = bid_price - original_bid_price * grid_fee_ratio In the case of the Two-Sided Pay-as-Bid market, the offer has moved into the Grid Market by the same mechanism as for the One-Sided Pay-as-Offer market. The bid of 0.30\u20ac follows a similar mechanism and is placed into the House 1 Market where there are zero fees. If the bid is not purchased after two ticks, it is moved into the Neighborhood 1 Market. As explained above, only the fees from the source market are added, which are zero in this case. Hence the bid remains at 0.30\u20ac. Next, the bid is moved to the Grid Market, and incurs the fees of the source market, the Neighborhood 1 Market of 5% to 0.30-0.30*0.05=0.285\u20ac . In the example above, the bid and offer are matched in the Grid Market. When the offer entered the Grid Market, its price was immediately updated to account for the Grid Market's fees 0.10*0.10+0.105=0.115\u20ac . The bid, however, did not add the 10% fee as only the fees from the source markets are added. In the case that the bid was not matched in the Grid Market and moved into the Neighborhood 2 Market, the 10% fee from the Grid Market would be added to the bid. In this case, the bid would become 0.285-0.30*0.10=0.255\u20ac . In the Grid Market, the Load bid is listed as 0.285\u20ac and the PV offer is listed as 0.115\u20ac. As the bid rate is greater than the offer rate, a trade can be scheduled. The trade clears at the bid rate, resulting in a Clearing Price of 0.285\u20ac. The algorithm to calculate the final grid fees for each trade is decentralised, allowing the markets to act more independently without having to share information regarding their fees with other markets. In order to calculate the fee correctly based on the original price, the algorithm needs to be able to calculate the supply side and demand side fee. It is easily calculated using the most recent forwarded rate and the original bid or offer rate: demand_side_fee = 1 - (forwarded_bid_rate / original_bid_rate) supply_side_fee = (forwarded_offer_rate / original_offer_rate) - 1 The provided example has the following values: supply_side_fee=(0.115/0.1)-1=0.15 demand_side_fee=1-(0.285/0.3)=0.05 After calculating the supply and the demand side fee, the trade revenue can be determined. Note the original_trade_rate is the amount that the original buyer (in our case the Load) will need to pay, and therefore the original bid price in a Pay-as-Bid market. The formula is the following: total_fee_ratio = supply_side_fee + demand_side_fee revenue = original_trade_rate / (1 + total_fee_ratio) In the provided example, revenue = 0.30/(1+0.15+0.05)=0.25 The grid fees are then calculated based on the revenue and the individual market fees: fees = revenue * grid_fee_ratio For the Grid Market in the provided example, the fees are 0.25*0.1=0.025 , and for each Neighborhood market, the fees are 0.25*0.05=0.0125 . Finally, the trade rate is adapted according to include the supply side grid fee, in order to include the fees of the current market: trade_rate = revenue * (1 + supply_side_fee) trade_price = energy * trade_rate In the provided example, the trade price for each market is: Grid Market = 0.25 * (1 + 0.15) = 0.2875 Neighborhood 2 Market = 0.25 * (1 + 0.05) = 0.2625 Neighborhood 1 Market = 0.25 * (1 + 0.2) = 0.3 House 1 Market = 0.25 * (1 + 0.2) = 0.3 House 2 Market = 0.25 * (1 + 0) = 0.25 The Load pays the Trade Price of 0.30\u20ac, which includes 0.25\u20ac revenue for the PV, 0.0125\u20ac fees for the Neighborhood Market 1, 0.025\u20ac fees for the Grid Market, and 0.0125\u20ac fees for the Neighborhood Market 2. Example Calculation in Two-Sided Pay-as-Clear Market \u00b6 This market clearing type is currently in development. We welcome your suggestions on its design!","title":"Percentage Grid Fee Calculation"},{"location":"percentage-fees/#example-calculation-in-one-sided-pay-as-offer-market","text":"In the One-Sided Pay-as-Offer market, there are no bids, only offers. The offers are propagated throughout the markets in the hierarchy. The grid fees are taken into account when an offer is forwarded to the higher market, by the higher market itself. Therefore the agent is not responsible for adapting the offer price to include the grid fees. The grid fees' unit is a ratio of the original offer price, therefore the formula to calculate the new offer price when placing an offer to a market is the following: offer_price_after_fees = offer_price + original_offer_price * grid_fee_ratio If the offer is not purchased after two ticks, it is moved into the next market, where the price is increased by that market\u2019s grid fee. In the provided example, the PV offer of 0.10\u20ac is first placed in the House 2 Market where it gains zero fees. Then it propagates into the Neighborhood 2 Market, gaining the market\u2019s fee of 5% of the original offer price 0.10*0.05+0.10=0.105\u20ac . If unmatched, it propagates into the Grid Market, with an additional 10% fee of the original offer is applied: 0.10*0.10+0.105=0.115\u20ac . Continuing into the Neighborhood 1 Market, the offer gains another fee of 5% of the original price 0.10*0.05+0.115=0.12\u20ac . Continuing into the House 1 Market, the offer gains zero additional fees as there is no fee in that market. The Load buys the offer in the House 1 Market at the Clearing Price of 0.12\u20ac. Starting with the initial offer price, the total fees are calculated 0.10*(1+0.05+0.10+0.05)=0.02 to yield the Trade Price of 0.12\u20ac. The Load pays the Trade Price of 0.12\u20ac, which includes 0.10\u20ac revenue for the PV, 0.005\u20ac fees for the Neighborhood Market 1, 0.01\u20ac fees for the Grid Market, and 0.005\u20ac fees for the Neighborhood Market 2. Since the market type is pay-as-offer, the offer rates are used as Clearing Rates. The trade price is then calculated by multiplying the clearing rate with the energy volume. For each market trade, the market grid fee is calculated based on the original offer rate and it is subtracted from the trade_price, in order to calculate the trade price after fees (and thus the revenue for the seller). The following formula is used: market_fees = grid_fee_ratio * original_rate * energy_portion trade_price_after_fees = energy * trade_rate - market_fees trade_price = energy * trade_rate","title":"Example Calculation in One-Sided Pay-as-Offer Market"},{"location":"percentage-fees/#example-calculation-in-two-sided-pay-as-bid-market","text":"In the Two-Sided Pay-as-Bid market, both bids and offers are propagated through the markets in the hierarchy. If a bid or offer is not purchased after two ticks , it propagates into the next market. In order to prevent double accounting of a market's grid fee when a bid and an offer are matched in that market, market fees are added to offers when they enter that market (target market) and subtracted from bids when they leave that market and enter another (source market). The formula for propagating the offers is the same as for the one-sided market: offer_price_after_fees = offer_price + original_offer_price * grid_fee_ratio The IAA subtracts the fees from the bid before propagating it to a higher market. The formula for an area to update the bid to include grid fees is the following: bid_price_after_fees = bid_price - original_bid_price * grid_fee_ratio In the case of the Two-Sided Pay-as-Bid market, the offer has moved into the Grid Market by the same mechanism as for the One-Sided Pay-as-Offer market. The bid of 0.30\u20ac follows a similar mechanism and is placed into the House 1 Market where there are zero fees. If the bid is not purchased after two ticks, it is moved into the Neighborhood 1 Market. As explained above, only the fees from the source market are added, which are zero in this case. Hence the bid remains at 0.30\u20ac. Next, the bid is moved to the Grid Market, and incurs the fees of the source market, the Neighborhood 1 Market of 5% to 0.30-0.30*0.05=0.285\u20ac . In the example above, the bid and offer are matched in the Grid Market. When the offer entered the Grid Market, its price was immediately updated to account for the Grid Market's fees 0.10*0.10+0.105=0.115\u20ac . The bid, however, did not add the 10% fee as only the fees from the source markets are added. In the case that the bid was not matched in the Grid Market and moved into the Neighborhood 2 Market, the 10% fee from the Grid Market would be added to the bid. In this case, the bid would become 0.285-0.30*0.10=0.255\u20ac . In the Grid Market, the Load bid is listed as 0.285\u20ac and the PV offer is listed as 0.115\u20ac. As the bid rate is greater than the offer rate, a trade can be scheduled. The trade clears at the bid rate, resulting in a Clearing Price of 0.285\u20ac. The algorithm to calculate the final grid fees for each trade is decentralised, allowing the markets to act more independently without having to share information regarding their fees with other markets. In order to calculate the fee correctly based on the original price, the algorithm needs to be able to calculate the supply side and demand side fee. It is easily calculated using the most recent forwarded rate and the original bid or offer rate: demand_side_fee = 1 - (forwarded_bid_rate / original_bid_rate) supply_side_fee = (forwarded_offer_rate / original_offer_rate) - 1 The provided example has the following values: supply_side_fee=(0.115/0.1)-1=0.15 demand_side_fee=1-(0.285/0.3)=0.05 After calculating the supply and the demand side fee, the trade revenue can be determined. Note the original_trade_rate is the amount that the original buyer (in our case the Load) will need to pay, and therefore the original bid price in a Pay-as-Bid market. The formula is the following: total_fee_ratio = supply_side_fee + demand_side_fee revenue = original_trade_rate / (1 + total_fee_ratio) In the provided example, revenue = 0.30/(1+0.15+0.05)=0.25 The grid fees are then calculated based on the revenue and the individual market fees: fees = revenue * grid_fee_ratio For the Grid Market in the provided example, the fees are 0.25*0.1=0.025 , and for each Neighborhood market, the fees are 0.25*0.05=0.0125 . Finally, the trade rate is adapted according to include the supply side grid fee, in order to include the fees of the current market: trade_rate = revenue * (1 + supply_side_fee) trade_price = energy * trade_rate In the provided example, the trade price for each market is: Grid Market = 0.25 * (1 + 0.15) = 0.2875 Neighborhood 2 Market = 0.25 * (1 + 0.05) = 0.2625 Neighborhood 1 Market = 0.25 * (1 + 0.2) = 0.3 House 1 Market = 0.25 * (1 + 0.2) = 0.3 House 2 Market = 0.25 * (1 + 0) = 0.25 The Load pays the Trade Price of 0.30\u20ac, which includes 0.25\u20ac revenue for the PV, 0.0125\u20ac fees for the Neighborhood Market 1, 0.025\u20ac fees for the Grid Market, and 0.0125\u20ac fees for the Neighborhood Market 2.","title":"Example Calculation in Two-Sided Pay-as-Bid Market"},{"location":"percentage-fees/#example-calculation-in-two-sided-pay-as-clear-market","text":"This market clearing type is currently in development. We welcome your suggestions on its design!","title":"Example Calculation in Two-Sided Pay-as-Clear Market"},{"location":"references/","text":"Grid Singularity Medium articles \u00b6 Grid Singularity. (September 23, 2019). An Energy Exchange Engine for Local Energy Marketplaces , https://gridsingularity.medium.com/an-energy-exchange-engine-for-local-energy-marketplaces-28d5be23705e Grid Singularity. (February 17, 2020). Stakeholders\u2019 Interest in Energy Market Design Innovation; Key Takeaways from the Odyssey Connect Energy Singularity Panel , https://gridsingularity.medium.com/stakeholders-interest-in-energy-market-design-innovation-key-takeaways-from-the-odyssey-connect-a6d18056ab34 Grid Singularity. (February 21, 2020). A Case for Flexibility Markets Enabled by Local Peer-to-Peer Exchanges , https://gridsingularity.medium.com/a-case-for-flexibility-markets-enabled-by-local-peer-to-peer-exchanges-43300b625cb5 Grid Singularity. (April 1, 2020). Energy Communities: a Game Changer for the European Electricity Grid , https://gridsingularity.medium.com/energy-communities-a-game-changer-for-the-european-electricity-grid-fd588a3063b0 Grid Singularity. (April 14, 2020). Deploying Local Electricity Markets to Optimise PV Integration; A Study of Three LEM Scenarios in Germany , https://gridsingularity.medium.com/deploying-local-electricity-markets-to-optimise-pv-integration-a-study-of-three-lem-scenarios-in-cf125b26f4dc Grid Singularity. (June 18, 2020). Analysis of Local Electricity Markets as a Platform to Modernise Consumer and Grid Interaction , https://gridsingularity.medium.com/analysis-of-local-electricity-markets-as-a-platform-to-modernise-consumer-and-grid-interaction-3fff63ef74e7 Grid Singularity. (August 27, 2020). Modelling study to assess the potential benefits of trading in and between local energy communities in Germany , https://gridsingularity.medium.com/modelling-study-to-assess-the-potential-benefits-of-trading-in-and-between-local-energy-d721395ddd4b Grid Singularity. (September 10, 2020). En Route to Energy Singularity Odyssey Momentum: Learnings from the 2020 Chaos Experiment , https://gridsingularity.medium.com/en-route-to-energy-singularity-odyssey-momentum-learnings-from-the-2020-chaos-experiment-8dc38ff26869 Grid Singularity. (November 25, 2020). Energy Singularity Challenge 2020: Social Energy Networks , https://gridsingularity.medium.com/energy-singularity-challenge-2020-social-energy-networks-157b390e5f39 Grid Singularity. (December 10, 2020). Energy Singularity Challenge 2020: Testing Novel Grid Fee Models and Intelligent Peer-to-Peer Trading Strategies , https://gridsingularity.medium.com/energy-singularity-challenge-2020-testing-novel-grid-fee-models-and-intelligent-peer-to-peer-6a0d715a9063 Books \u00b6 Ana Trbovich, Sarah Hambridge, Dirk van den Biggelaar, Ewald Hesse, Fereidoon Sioshansi, Chapter 13 - D3A energy exchange for a transactive grid, Editor(s): Fereidoon Sioshansi, Behind and Beyond the Meter, Academic Press, 2020, Pages 267-284, ISBN 9780128199510, https://doi.org/10.1016/B978-0-12-819951-0.00013-X . (http://www.sciencedirect.com/science/article/pii/B978012819951000013X) Scientific articles and studies \u00b6 BBEn, 100 prozent erneuerbar stiftung, Grid Singularity, Neue Kraft mit der Nachbarschaft , October 2020, https://www.buendnis-buergerenergie.de/fileadmin/nkmdn_Lokale_Strommaerkte.pdf Trbovich, Ana S. \u2018In Pursuit of Good Governance for the Energy Industry Blockchain\u2019. Journal of Energy Markets , May 2019, https://www.risk.net/node/6637136 . Danzi, P. Hambridge,S. Stefanovi\u0107, \u010c. Popovski,P. \u2018Blockchain-Based and Multi-Layered Electricity Imbalance Settlement Architecture\u2019. IEEE, December 27,2018. https://ieeexplore.ieee.org/abstract/document/8587577/references#references","title":"References"},{"location":"references/#grid-singularity-medium-articles","text":"Grid Singularity. (September 23, 2019). An Energy Exchange Engine for Local Energy Marketplaces , https://gridsingularity.medium.com/an-energy-exchange-engine-for-local-energy-marketplaces-28d5be23705e Grid Singularity. (February 17, 2020). Stakeholders\u2019 Interest in Energy Market Design Innovation; Key Takeaways from the Odyssey Connect Energy Singularity Panel , https://gridsingularity.medium.com/stakeholders-interest-in-energy-market-design-innovation-key-takeaways-from-the-odyssey-connect-a6d18056ab34 Grid Singularity. (February 21, 2020). A Case for Flexibility Markets Enabled by Local Peer-to-Peer Exchanges , https://gridsingularity.medium.com/a-case-for-flexibility-markets-enabled-by-local-peer-to-peer-exchanges-43300b625cb5 Grid Singularity. (April 1, 2020). Energy Communities: a Game Changer for the European Electricity Grid , https://gridsingularity.medium.com/energy-communities-a-game-changer-for-the-european-electricity-grid-fd588a3063b0 Grid Singularity. (April 14, 2020). Deploying Local Electricity Markets to Optimise PV Integration; A Study of Three LEM Scenarios in Germany , https://gridsingularity.medium.com/deploying-local-electricity-markets-to-optimise-pv-integration-a-study-of-three-lem-scenarios-in-cf125b26f4dc Grid Singularity. (June 18, 2020). Analysis of Local Electricity Markets as a Platform to Modernise Consumer and Grid Interaction , https://gridsingularity.medium.com/analysis-of-local-electricity-markets-as-a-platform-to-modernise-consumer-and-grid-interaction-3fff63ef74e7 Grid Singularity. (August 27, 2020). Modelling study to assess the potential benefits of trading in and between local energy communities in Germany , https://gridsingularity.medium.com/modelling-study-to-assess-the-potential-benefits-of-trading-in-and-between-local-energy-d721395ddd4b Grid Singularity. (September 10, 2020). En Route to Energy Singularity Odyssey Momentum: Learnings from the 2020 Chaos Experiment , https://gridsingularity.medium.com/en-route-to-energy-singularity-odyssey-momentum-learnings-from-the-2020-chaos-experiment-8dc38ff26869 Grid Singularity. (November 25, 2020). Energy Singularity Challenge 2020: Social Energy Networks , https://gridsingularity.medium.com/energy-singularity-challenge-2020-social-energy-networks-157b390e5f39 Grid Singularity. (December 10, 2020). Energy Singularity Challenge 2020: Testing Novel Grid Fee Models and Intelligent Peer-to-Peer Trading Strategies , https://gridsingularity.medium.com/energy-singularity-challenge-2020-testing-novel-grid-fee-models-and-intelligent-peer-to-peer-6a0d715a9063","title":"Grid Singularity Medium articles"},{"location":"references/#books","text":"Ana Trbovich, Sarah Hambridge, Dirk van den Biggelaar, Ewald Hesse, Fereidoon Sioshansi, Chapter 13 - D3A energy exchange for a transactive grid, Editor(s): Fereidoon Sioshansi, Behind and Beyond the Meter, Academic Press, 2020, Pages 267-284, ISBN 9780128199510, https://doi.org/10.1016/B978-0-12-819951-0.00013-X . (http://www.sciencedirect.com/science/article/pii/B978012819951000013X)","title":"Books"},{"location":"references/#scientific-articles-and-studies","text":"BBEn, 100 prozent erneuerbar stiftung, Grid Singularity, Neue Kraft mit der Nachbarschaft , October 2020, https://www.buendnis-buergerenergie.de/fileadmin/nkmdn_Lokale_Strommaerkte.pdf Trbovich, Ana S. \u2018In Pursuit of Good Governance for the Energy Industry Blockchain\u2019. Journal of Energy Markets , May 2019, https://www.risk.net/node/6637136 . Danzi, P. Hambridge,S. Stefanovi\u0107, \u010c. Popovski,P. \u2018Blockchain-Based and Multi-Layered Electricity Imbalance Settlement Architecture\u2019. IEEE, December 27,2018. https://ieeexplore.ieee.org/abstract/document/8587577/references#references","title":"Scientific articles and studies"},{"location":"releases/","text":"Version 1.0.0 \u00b6 The following features were implemented : Our new user interface (UI), found at Grid Singularity map will replace the old one at d3a.io . This new UI is intended to make creating and running simulations much easier for users who might be new to thinking about their energy use and simulating their own energy community. Additional features in the map include a search bar , which facilitates searching for an address or town on the map. After running the simulation, highlighted results displayed directly above each home and community in the map. There are standard (template) homes and profiles that can be used by users who do not have information about actual energy consumption and/or production, generated from loadprofilegenerator.de and energydatamap.com . We provide additional information on the Canary Test Network for live data simulations, which is the next step in building an energy community Animated color visuals in the map view assist analysis, with a color assigned to each home and community on the map when the simulation is running: green for net exports, blue for neutral, and red for net imports We also provide Map 3D view, where users can view their simulations and homes in 3-Dimensions Side navigation bar summarizes the contents of a users\u2019 energy community to additionally aid optimal energy community configuration Home meter asset, a new asset type which can be configured directly in the codebase simulation file to allow users to upload smart meter net consumption and production profiles Version 0.12.0 \u00b6 The following features were implemented : Market slot length realtime: This can be set to simulations and collaborations. It slows down the running pace with a constant value (speed can go from the fasted as possible up until real-time. Public library is updated: New loads and PVs profiles were added to the public library. A total of 24 loads, representing various types of households was generated using loadprofilegenerator.de . PV production profiles were taken from energydatamap.com for different cities. These new loads and PVs have profiles of a full year (2021). Users can now download the registry page as a JSON file, to facilitate the connection with the API to a collaboration/Canary Network. Version 0.11.0 \u00b6 The following features were implemented : Time Resolution setting for graphs: Users can choose to view data in the graphs in 2 hour, 1 hour, or 15 minutes time resolution. This allows for faster loading of the graphs as the simulation run time is extended. Users can change the time resolution for the Energy Trade Profile, Energy Pricing, and Asset Profile graphs. Add a Library as an Event : Users can add grid components from the Library into their simulation while it is running. Canary Network Enhancements: Canary Networks are automatically restarted in the event of a software deploy or other system disruption. Users can view previous weeks of Canary Network data and download the results . Canary Network simulations can run for weeks at a time and store all data for future analysis and research. Users can trade through the Grid Singularity Asset and Grid Operator APIs through a cloud web service. This feature allows users to automate their trading algorithms and connect to the API from the cloud instead of hosting and monitoring on a local computer. Version 0.10.0 \u00b6 The following features were implemented : Canary Networks : An admin user can create a Canary Network simulation, which duplicates a collaboration simulation and allows the admin to connect each energy asset in the grid to its live data stream in order to simulate trading on the asset's live metered data readings. The Canary Network runs in real-time , with incoming data collected during each 15 minute market slot. Researcher users can trade on behalf of energy assets using the registry to connect to the live data stream which broadcasts the energy required for each asset through the Asset API . Grid Operator users can change the grid fees and grid parameters of each grid market using the registry which connects them to their markets through the Grid Operator API . Therefore, the Canary Network realizes the digital twin model of an energy asset and enables Researcher users to trade in real-time on behalf of their assets as a proof of concept. Once a Canary Network is established, it continues to run and agents can trade over weeks and months of time, for long term study of energy asset data and agent and market behavior. Previous weeks of data and results are saved in the results page weekly history. Island or Grid-connect a Market Maker as an event: Users can now change the role and mode of the Market Maker as an event, allowing users to simulate blackouts by changing the Market Maker to an islanding role, or simulating other impacts resulting from a change in the Market Maker parameters, such as showing the effect of connecting an islanded Market Maker to the grid. Version 0.9.0 \u00b6 The following features were implemented : Market API , which allows grid operators and researchers to monitor metrics and set grid fees in the select local energy market simulation collaboration Easier registration for researchers and grid operators to manage multiple assets and use market API through the Registry page. Bids and offers are prioritised in their first market by setting a wait time of 2 ticks before allowing them to propagate to higher markets in the grid hierarchy. This wait time is set in the backend as the minimum bid or offer age parameter. Grid fees integrated in the Results page - Energy Pricing graph for each market Total grid fees reported in the Scoreboard page that demonstrates market performance metrics for each collaboration simulation. Net Energy calculation added to Results page - Energy Trade Profile graph in order to calculate the peak energy at a market node in the simulation. The current peak imports and exports were previously calculated based on the cumulative trades, but are now calculated from the net energy consumption, which can be a net import or export. Updated load final selling rate and PV initial buying rate in the template strategies now take the total grid fees into account in addition to the market maker (usually utility) rate. Users can now run three simulations and/or collaborations at once (previous limit was two) Version 0.8.0 \u00b6 The following features were implemented : Simulation Location Map. Users can geo-tag all energy resources and markets in their simulation to make a map view of the simulation and results. A summary of all simulations can be viewed in a global map, to see where Grid Singularity is running simulations all over the world! Version 0.7.0 \u00b6 The following features were implemented : Detailed energy trade profile graph . Zoom in to each 15 minute market slot to view the scheduled trades with 1 minute resolution. Grid Operator user can change grid parameters inside a collaboration and while it is running, like grid fees or the transformer capacity. Allow collaboration participants to register for events while the simulation is running. Allows users to simulate a growing community. Information Aggregator to compile and send average market measurements to assist data scientists in building smart strategies to trade through the API . Version 0.6.0 \u00b6 The following features were implemented : Bid and Offer matching graph Analyze all bids, offers, and trades in a market and see why they match based on their strategies. Simulation events Add, delete, or update areas or energy resources in a simulation while it is running. This allows users to grow their simulations in real-time and analyze the impacts of energy resources coming online and changes to grid parameters such as grid fees. Timeline to view events and zoom in View all events in a timeline and click on each event to view its relevant grid configuration and results. Zoom in to view results for a specific day. Pause or stop a simulation Pause a simulation to freeze it while adding an event. Stop a simulation pre-maturely in order to run another version sooner. Configure an infinite bus as part of the Market Maker Configure an Infinite Bus in order to add a feed-in-tariff to the simulation. Version 0.5.0 \u00b6 The following features were implemented : Constant based Grid Fees Self Sufficiency, Self Consumption , and Energy Peak Percentage KPIs Simulation runtime status indicator Increased node limit to 1000 nodes Collaborations Scoreboard Select visible charts on Results page Colors for Energy Bills Bought and Sold Version 0.4.0 \u00b6 The following features were implemented : Grid fees configuration User roles, including 'Collaborations' feature for multi user testing and Grid Singularity-hosted challenges API connection to energy devices allowing bids and offers to be submitted by external algorithms Version 0.3.0 \u00b6 The following features were implemented : Run simulations with up to 250 nodes Compare results of two simulations side by side New navigation side bar with Home, Projects, and Library easily accessible Version 0.2.0 \u00b6 The following features were implemented : Run simulations for one week Choose your market type: additional access to two-sided pay as bid and two-sided pay as clear market types New user friendly device strategies Configure your market maker Scrollable graphs on the results page optimized for longer simulations Download simulation results","title":"Releases Archive"},{"location":"releases/#version-100","text":"The following features were implemented : Our new user interface (UI), found at Grid Singularity map will replace the old one at d3a.io . This new UI is intended to make creating and running simulations much easier for users who might be new to thinking about their energy use and simulating their own energy community. Additional features in the map include a search bar , which facilitates searching for an address or town on the map. After running the simulation, highlighted results displayed directly above each home and community in the map. There are standard (template) homes and profiles that can be used by users who do not have information about actual energy consumption and/or production, generated from loadprofilegenerator.de and energydatamap.com . We provide additional information on the Canary Test Network for live data simulations, which is the next step in building an energy community Animated color visuals in the map view assist analysis, with a color assigned to each home and community on the map when the simulation is running: green for net exports, blue for neutral, and red for net imports We also provide Map 3D view, where users can view their simulations and homes in 3-Dimensions Side navigation bar summarizes the contents of a users\u2019 energy community to additionally aid optimal energy community configuration Home meter asset, a new asset type which can be configured directly in the codebase simulation file to allow users to upload smart meter net consumption and production profiles","title":"Version 1.0.0"},{"location":"releases/#version-0120","text":"The following features were implemented : Market slot length realtime: This can be set to simulations and collaborations. It slows down the running pace with a constant value (speed can go from the fasted as possible up until real-time. Public library is updated: New loads and PVs profiles were added to the public library. A total of 24 loads, representing various types of households was generated using loadprofilegenerator.de . PV production profiles were taken from energydatamap.com for different cities. These new loads and PVs have profiles of a full year (2021). Users can now download the registry page as a JSON file, to facilitate the connection with the API to a collaboration/Canary Network.","title":"Version 0.12.0"},{"location":"releases/#version-0110","text":"The following features were implemented : Time Resolution setting for graphs: Users can choose to view data in the graphs in 2 hour, 1 hour, or 15 minutes time resolution. This allows for faster loading of the graphs as the simulation run time is extended. Users can change the time resolution for the Energy Trade Profile, Energy Pricing, and Asset Profile graphs. Add a Library as an Event : Users can add grid components from the Library into their simulation while it is running. Canary Network Enhancements: Canary Networks are automatically restarted in the event of a software deploy or other system disruption. Users can view previous weeks of Canary Network data and download the results . Canary Network simulations can run for weeks at a time and store all data for future analysis and research. Users can trade through the Grid Singularity Asset and Grid Operator APIs through a cloud web service. This feature allows users to automate their trading algorithms and connect to the API from the cloud instead of hosting and monitoring on a local computer.","title":"Version 0.11.0"},{"location":"releases/#version-0100","text":"The following features were implemented : Canary Networks : An admin user can create a Canary Network simulation, which duplicates a collaboration simulation and allows the admin to connect each energy asset in the grid to its live data stream in order to simulate trading on the asset's live metered data readings. The Canary Network runs in real-time , with incoming data collected during each 15 minute market slot. Researcher users can trade on behalf of energy assets using the registry to connect to the live data stream which broadcasts the energy required for each asset through the Asset API . Grid Operator users can change the grid fees and grid parameters of each grid market using the registry which connects them to their markets through the Grid Operator API . Therefore, the Canary Network realizes the digital twin model of an energy asset and enables Researcher users to trade in real-time on behalf of their assets as a proof of concept. Once a Canary Network is established, it continues to run and agents can trade over weeks and months of time, for long term study of energy asset data and agent and market behavior. Previous weeks of data and results are saved in the results page weekly history. Island or Grid-connect a Market Maker as an event: Users can now change the role and mode of the Market Maker as an event, allowing users to simulate blackouts by changing the Market Maker to an islanding role, or simulating other impacts resulting from a change in the Market Maker parameters, such as showing the effect of connecting an islanded Market Maker to the grid.","title":"Version 0.10.0"},{"location":"releases/#version-090","text":"The following features were implemented : Market API , which allows grid operators and researchers to monitor metrics and set grid fees in the select local energy market simulation collaboration Easier registration for researchers and grid operators to manage multiple assets and use market API through the Registry page. Bids and offers are prioritised in their first market by setting a wait time of 2 ticks before allowing them to propagate to higher markets in the grid hierarchy. This wait time is set in the backend as the minimum bid or offer age parameter. Grid fees integrated in the Results page - Energy Pricing graph for each market Total grid fees reported in the Scoreboard page that demonstrates market performance metrics for each collaboration simulation. Net Energy calculation added to Results page - Energy Trade Profile graph in order to calculate the peak energy at a market node in the simulation. The current peak imports and exports were previously calculated based on the cumulative trades, but are now calculated from the net energy consumption, which can be a net import or export. Updated load final selling rate and PV initial buying rate in the template strategies now take the total grid fees into account in addition to the market maker (usually utility) rate. Users can now run three simulations and/or collaborations at once (previous limit was two)","title":"Version 0.9.0"},{"location":"releases/#version-080","text":"The following features were implemented : Simulation Location Map. Users can geo-tag all energy resources and markets in their simulation to make a map view of the simulation and results. A summary of all simulations can be viewed in a global map, to see where Grid Singularity is running simulations all over the world!","title":"Version 0.8.0"},{"location":"releases/#version-070","text":"The following features were implemented : Detailed energy trade profile graph . Zoom in to each 15 minute market slot to view the scheduled trades with 1 minute resolution. Grid Operator user can change grid parameters inside a collaboration and while it is running, like grid fees or the transformer capacity. Allow collaboration participants to register for events while the simulation is running. Allows users to simulate a growing community. Information Aggregator to compile and send average market measurements to assist data scientists in building smart strategies to trade through the API .","title":"Version 0.7.0"},{"location":"releases/#version-060","text":"The following features were implemented : Bid and Offer matching graph Analyze all bids, offers, and trades in a market and see why they match based on their strategies. Simulation events Add, delete, or update areas or energy resources in a simulation while it is running. This allows users to grow their simulations in real-time and analyze the impacts of energy resources coming online and changes to grid parameters such as grid fees. Timeline to view events and zoom in View all events in a timeline and click on each event to view its relevant grid configuration and results. Zoom in to view results for a specific day. Pause or stop a simulation Pause a simulation to freeze it while adding an event. Stop a simulation pre-maturely in order to run another version sooner. Configure an infinite bus as part of the Market Maker Configure an Infinite Bus in order to add a feed-in-tariff to the simulation.","title":"Version 0.6.0"},{"location":"releases/#version-050","text":"The following features were implemented : Constant based Grid Fees Self Sufficiency, Self Consumption , and Energy Peak Percentage KPIs Simulation runtime status indicator Increased node limit to 1000 nodes Collaborations Scoreboard Select visible charts on Results page Colors for Energy Bills Bought and Sold","title":"Version 0.5.0"},{"location":"releases/#version-040","text":"The following features were implemented : Grid fees configuration User roles, including 'Collaborations' feature for multi user testing and Grid Singularity-hosted challenges API connection to energy devices allowing bids and offers to be submitted by external algorithms","title":"Version 0.4.0"},{"location":"releases/#version-030","text":"The following features were implemented : Run simulations with up to 250 nodes Compare results of two simulations side by side New navigation side bar with Home, Projects, and Library easily accessible","title":"Version 0.3.0"},{"location":"releases/#version-020","text":"The following features were implemented : Run simulations for one week Choose your market type: additional access to two-sided pay as bid and two-sided pay as clear market types New user friendly device strategies Configure your market maker Scrollable graphs on the results page optimized for longer simulations Download simulation results","title":"Version 0.2.0"},{"location":"results/","text":"User Interface Results \u00b6 Grid Singularity\u2019s UI (d3a.io) offers visual representations of simulation results. These are updated while the simulation is running and stored indefinitely until the user decides to delete or to rerun the simulation. The user is able to view Results for each area or asset in the grid configuration. Navigating the grid configuration in the UI \u00b6 As shown in the image above, the user can select a market or an energy asset from a drop down to view specific results for that market or an asset while on the Results page. In the figure above, the Community market is selected. The Results page then displays relevant plots and tables for the selected market or asset. There is also the possibility to select which charts / tables you want to view / hide, as shown in the image above. This section discusses the information available in each chart / table. Energy availability \u00b6 This plot shows whether each consuming energy asset (i.e. load) inside the selected market had access to the energy it needed for each market slot. On the x-axis, the time is given. If the participating asset agent was able to purchase the energy it required for that time slot, the block will be colored green . If not, it will be colored purple . The granularity of the plot is one hour , so if there was a trade interval within the hour in which the agent was not able to buy the demanded energy, the entire block will be colored purple. The user can hover the cursor over a purple block to view a list of the energy assets that were not able to buy energy in that time slot. Self-sufficiency and self-consumption \u00b6 These two pie charts display Self-Sufficiency and Self-Consumption level of the selected area. Please see this page for more information. When the user hovers the cursor over these plots, the following quantitative energy metrics are shown: Self-consumed energy [kWh] Total demanded energy [kWh] Total produced energy [kWh] Cumulative trading \u00b6 This plot shows the total cumulative trade volumes traded among market participants (agents representing assets or markets) in the selected market in the course of the simulation. Each market participant is displayed as a uniquely colored bar that represents the energy sold (shown as negative) or bought (shown as positive). In the example below, the energy sold by House 1 is colored purple, and the House 1 bar is positive, meaning that it bought some of the energy it produced for its own use (self-consumption). The rest of the energy it sold is shown as a thin purple layer appearing in the bars of the other market participants that acted as buyers. This color coding allows the user to visually track the energy trade flows in the selected market. External Trades represent the import/export from/to a higher level market by the Inter-area agent of the selected market, and hence the difference between energy traded amongst the selected market participants and the total accumulated trades. The external trades bar represents energy produced in this market, but sold to an outside market, as well as the energy bought from an external source and sold to a participant in this market. The energy bought externally is teal in this example and the bar is negative for external trades. The energy that was sold to other market participants is indicated by a positive teal colored bar. A negative external trades bar means that the participants within the select market purchased energy externally and a positive external trades bar means that participants sold energy to an external market. Energy bills and net energy \u00b6 In the Community market shown in the figure below, the participating agents are the inter-area agents of the houses that lie within that market. The energy bill table provides information on the cumulative trade volumes of all market participants and the costs associated with trades. For each market and energy asset, the energy bought and sold during the simulation is listed, along with a total net energy consumption. The Totals column can be considered as the net energy consumption and final bill for the listed agent, which may represent an energy asset or a market (e.g. a house). The Totals row represents the total of trades that are made by all participants inside the selected market. Energy trade profile \u00b6 The energy profile shows the supply and demand of trades made inside the selected market for each market slot of the simulation. The negative side of the y-axis represents the energy sold, and the positive y-axis shows the energy bought. The different colors represent the different market participants (energy assets and markets). As all buyers and sellers of each trade are accounted for in a select market, the supply and demand sides are exact mirrors of each other in terms of volume. If peak analysis is switched on, the internal trades are hidden and only the trades including external participants are displayed. This shows how much energy required the use of transmission lines outside of the selected market. On the peak analysis plot, two lines are shown: the current peak imports and the current peak exports , representing the maximum energy imported and exported for the selected market. Another feature of this graph is viewing the Net energy , shown below. When peak analysis is activated, only net external trades of each participant are displayed. The net displays the difference between the total import and export for each market slot, useful in understanding the impact to transmission capacity . Detailed energy trade profile \u00b6 This graph is a market slot level breakdown of the energy trade profile. With this graph, the user can select a specific market slot to see when each trade was cleared during that slot, with a resolution of 30 simulated seconds. The graph's length is the market slot length (15 minutes by default). The market slot can be selected with the drop down (days) and the slider (hours and minutes). Energy pricing \u00b6 In this plot, energy pricing is shown. Depending on market design and grid configuration, there could be different price settlements in the same market slot. In this case, a minimum , maximum , and average of the trade price is shown. If no trade occurred during a certain market interval, no lines are plotted. If grid fees are set in that market as a constant value, a fourth line is plotted to reflect its price. Bids, Offers, and Trades per Market Slot \u00b6 In this plot, each bid, offer and trade posted/cleared in the selected market is shown according to its posting/clearing times, allowing the user to analyse how specific offers/bids were or were not matched and validate or further investigate their trading strategy. The x-axis of this graph is the market slot length (15 minutes by default), and the y-axis shows the bid and offer price. Each market slot of the simulation can be selected and viewed with the drop down (days) and the slider (hours & minutes). Compare results \u00b6 The user has the possibility to compare the results of two separate simulations. The user can also duplicate the simulation setup, download results or delete the configuration by using the appropriate buttons shown below: Backend Results \u00b6 After running a simulation in the backend, the user can export simulation results. This functionality is enabled by default. If you want to disable the export of simulation results, use the --no-export flag for the simulation run. Another useful parameter is: --export-path , used to change the output path of the simulation results. The default path is $HOME/d3a-simulation/ . The simulation results include analytical information about the bids, offers and trades that took place in the course of the simulation. Information about energy characteristics of each asset and market are also included (eg. battery state of charge, energy traded/requested/deficit). A detailed description of these files is available on the data download page. In addition to text files, some graphs that display aggregated market information during the course of the simulation are also exposed. These can be found under the plot directory and are very similar to the ones available in the UI : unmatched_loads_*.html : Plots the volume of energy that loads have not been able to purchase (power outage) energy_profile_*.html : Similar plot to energy trade profile average_trade_price_*.html : Similar plot to energy pricing asset_profile_*.html : each energy asset within the simulation has its own plot showing its profile (consumption, generation, State of Charge), the actual energy traded and energy rates.","title":"Results Dashboard"},{"location":"results/#user-interface-results","text":"Grid Singularity\u2019s UI (d3a.io) offers visual representations of simulation results. These are updated while the simulation is running and stored indefinitely until the user decides to delete or to rerun the simulation. The user is able to view Results for each area or asset in the grid configuration.","title":"User Interface Results"},{"location":"results/#navigating-the-grid-configuration-in-the-ui","text":"As shown in the image above, the user can select a market or an energy asset from a drop down to view specific results for that market or an asset while on the Results page. In the figure above, the Community market is selected. The Results page then displays relevant plots and tables for the selected market or asset. There is also the possibility to select which charts / tables you want to view / hide, as shown in the image above. This section discusses the information available in each chart / table.","title":"Navigating the grid configuration in the UI"},{"location":"results/#energy-availability","text":"This plot shows whether each consuming energy asset (i.e. load) inside the selected market had access to the energy it needed for each market slot. On the x-axis, the time is given. If the participating asset agent was able to purchase the energy it required for that time slot, the block will be colored green . If not, it will be colored purple . The granularity of the plot is one hour , so if there was a trade interval within the hour in which the agent was not able to buy the demanded energy, the entire block will be colored purple. The user can hover the cursor over a purple block to view a list of the energy assets that were not able to buy energy in that time slot.","title":"Energy availability"},{"location":"results/#self-sufficiency-and-self-consumption","text":"These two pie charts display Self-Sufficiency and Self-Consumption level of the selected area. Please see this page for more information. When the user hovers the cursor over these plots, the following quantitative energy metrics are shown: Self-consumed energy [kWh] Total demanded energy [kWh] Total produced energy [kWh]","title":"Self-sufficiency and self-consumption"},{"location":"results/#cumulative-trading","text":"This plot shows the total cumulative trade volumes traded among market participants (agents representing assets or markets) in the selected market in the course of the simulation. Each market participant is displayed as a uniquely colored bar that represents the energy sold (shown as negative) or bought (shown as positive). In the example below, the energy sold by House 1 is colored purple, and the House 1 bar is positive, meaning that it bought some of the energy it produced for its own use (self-consumption). The rest of the energy it sold is shown as a thin purple layer appearing in the bars of the other market participants that acted as buyers. This color coding allows the user to visually track the energy trade flows in the selected market. External Trades represent the import/export from/to a higher level market by the Inter-area agent of the selected market, and hence the difference between energy traded amongst the selected market participants and the total accumulated trades. The external trades bar represents energy produced in this market, but sold to an outside market, as well as the energy bought from an external source and sold to a participant in this market. The energy bought externally is teal in this example and the bar is negative for external trades. The energy that was sold to other market participants is indicated by a positive teal colored bar. A negative external trades bar means that the participants within the select market purchased energy externally and a positive external trades bar means that participants sold energy to an external market.","title":"Cumulative trading"},{"location":"results/#energy-bills-and-net-energy","text":"In the Community market shown in the figure below, the participating agents are the inter-area agents of the houses that lie within that market. The energy bill table provides information on the cumulative trade volumes of all market participants and the costs associated with trades. For each market and energy asset, the energy bought and sold during the simulation is listed, along with a total net energy consumption. The Totals column can be considered as the net energy consumption and final bill for the listed agent, which may represent an energy asset or a market (e.g. a house). The Totals row represents the total of trades that are made by all participants inside the selected market.","title":"Energy bills and net energy"},{"location":"results/#energy-trade-profile","text":"The energy profile shows the supply and demand of trades made inside the selected market for each market slot of the simulation. The negative side of the y-axis represents the energy sold, and the positive y-axis shows the energy bought. The different colors represent the different market participants (energy assets and markets). As all buyers and sellers of each trade are accounted for in a select market, the supply and demand sides are exact mirrors of each other in terms of volume. If peak analysis is switched on, the internal trades are hidden and only the trades including external participants are displayed. This shows how much energy required the use of transmission lines outside of the selected market. On the peak analysis plot, two lines are shown: the current peak imports and the current peak exports , representing the maximum energy imported and exported for the selected market. Another feature of this graph is viewing the Net energy , shown below. When peak analysis is activated, only net external trades of each participant are displayed. The net displays the difference between the total import and export for each market slot, useful in understanding the impact to transmission capacity .","title":"Energy trade profile"},{"location":"results/#detailed-energy-trade-profile","text":"This graph is a market slot level breakdown of the energy trade profile. With this graph, the user can select a specific market slot to see when each trade was cleared during that slot, with a resolution of 30 simulated seconds. The graph's length is the market slot length (15 minutes by default). The market slot can be selected with the drop down (days) and the slider (hours and minutes).","title":"Detailed energy trade profile"},{"location":"results/#energy-pricing","text":"In this plot, energy pricing is shown. Depending on market design and grid configuration, there could be different price settlements in the same market slot. In this case, a minimum , maximum , and average of the trade price is shown. If no trade occurred during a certain market interval, no lines are plotted. If grid fees are set in that market as a constant value, a fourth line is plotted to reflect its price.","title":"Energy pricing"},{"location":"results/#bids-offers-and-trades-per-market-slot","text":"In this plot, each bid, offer and trade posted/cleared in the selected market is shown according to its posting/clearing times, allowing the user to analyse how specific offers/bids were or were not matched and validate or further investigate their trading strategy. The x-axis of this graph is the market slot length (15 minutes by default), and the y-axis shows the bid and offer price. Each market slot of the simulation can be selected and viewed with the drop down (days) and the slider (hours & minutes).","title":"Bids, Offers, and Trades per Market Slot"},{"location":"results/#compare-results","text":"The user has the possibility to compare the results of two separate simulations. The user can also duplicate the simulation setup, download results or delete the configuration by using the appropriate buttons shown below:","title":"Compare results"},{"location":"results/#backend-results","text":"After running a simulation in the backend, the user can export simulation results. This functionality is enabled by default. If you want to disable the export of simulation results, use the --no-export flag for the simulation run. Another useful parameter is: --export-path , used to change the output path of the simulation results. The default path is $HOME/d3a-simulation/ . The simulation results include analytical information about the bids, offers and trades that took place in the course of the simulation. Information about energy characteristics of each asset and market are also included (eg. battery state of charge, energy traded/requested/deficit). A detailed description of these files is available on the data download page. In addition to text files, some graphs that display aggregated market information during the course of the simulation are also exposed. These can be found under the plot directory and are very similar to the ones available in the UI : unmatched_loads_*.html : Plots the volume of energy that loads have not been able to purchase (power outage) energy_profile_*.html : Similar plot to energy trade profile average_trade_price_*.html : Similar plot to energy pricing asset_profile_*.html : each energy asset within the simulation has its own plot showing its profile (consumption, generation, State of Charge), the actual energy traded and energy rates.","title":"Backend Results"},{"location":"self-sufficiency-consumption/","text":"Self-sufficiency : % of energy needs covered by local generation Self-consumption : % of local energy generation consumed locally self_sufficiency(market) = self_consumed_energy / total_energy_demanded self_consumption(market) = self_consumed_energy / total_energy_produced The example provided in the figure below has the following grid architecture: total_house1_pv_production = 10kWh house1_pv \u2192 house1_load = 1kWh house1_pv \u2192 house1_storage = 5kWh house1_pv \u2192 house2_load = 4kWh house1_storage \u2192 house1_load = 2kWh house1_storage \u2192 house2_load = 3kWh house1_self_consumer_energy = ( house1_pv \u2192 house1_load ) + ( house1_pv \u2192 house1_storage \u2192 house1_load ) = 1 + 2 = 3kWh house1_total_energy_demanded (only includes the demanded energy from house1\u2019s load asset) = 3kWh In this example, self-sufficiency of the house 1 is self_sufficiency(house1) = house1_self_consumer_energy / house1_total_energy_demanded self_sufficiency(house1) = 3 / 3 = 1 \u2192 100% Self-consumption of the house 1 is self_consumption(house1) = house1_self_consumer_energy / house1_total_energy_produced self_consumption(house1) = 3 / 10 = 0.3 \u2192 30% In the Grid , the highest level of the hierarchy : self_sufficiency = 10 / 10 = 1 \u2192 100% self_consumption = 10 / 10 = 1 \u2192 100%","title":"Self-Sufficiency and Self-Consumption"},{"location":"technical-approach/","text":"Grid Singularity energy exchange engine (D3A) organizes the grid into hierarchical markets . For example, household assets are initially grouped into a household market, which are in turn grouped into higher-level markets such as neighborhoods, districts, or regions. Since the grid is already organized by different voltage levels, the hierarchies of markets in the D3A can reflect the different voltage levels of the grid. This allows grid fees to be accounted for in each market . This type of structure enables grid operators to source flexibility for targeted congestion management or frequency balancing . It also facilitates easy scaling by connecting diverse energy communities. Market participants such as energy assets are represented by agents , trading algorithms defined by user-set parameters, which act like traders . Energy prices are established by bids and offers and are issued by agents according to the trading strategies of market participants. Energy assets trade with each other and with other submarkets inside a parent market. In this way energy trading can be organized into groups or communities by registering assets in the relevant markets. These markets are then stacked in a market hierarchy to allow inter-market trading across the entire grid infrastructure, while prioritizing trade in the local markets. The utility is also represented by an agent, the Market Maker . Trading happens at the most cost-efficient level following a select market mechanism . This will typically be locally, but if an actor (e.g., a grid operator) has set certain parameters that place a better bid into the market due to a high need (e.g. for grid flexibility), inter-area trading agents can match it with offers from a lower or higher-level market. Grid operators may also levy flexible grid fees on local markets to help manage congestion. It is important to note that the D3A is not, itself, trading energy or providing balancing services. Rather, it is creating the exchange , registering assets, and providing the mechanism of agents to allow assets and markets to place bids and offers and trade directly with one another (i.e., peer-to-peer) in a fully decentralized manner, or, if there is insufficient local generation, from the utility. This decentralized structure removes limits to scaling. If the D3A is deployed to facilitate a local distributed energy exchange, the traditional roles of the grid operator, which manages the connection to the power grid, and the utility, as a provider of energy, would continue to be required to integrate the local energy market with the wider grid network. The primary difference is that a utility would no longer be the only market actor with which a household exchanges energy, but one of multiple. Grid Singularity\u2019s D3A is a highly innovative and effective grid modernization solution. First, it creates a resilient market by ensuring equal access, transparent pricing, and trading at optimal market levels (i.e., between assets and buildings or facility and grid). Second, it incentivizes and facilitates the integration of clean DERs onto the grid closer to load centers. Third, grid operators can use it to implement flexible grid tariffs to benefit from the local market flexibility to alleviate congestion. Fourth, the Grid Singularity API provides instantaneous granular data to the grid operator\u2013which historically has relied upon changes in detected load and alterations from the forecast\u2013enabling the operator to improve management, flexibility, and grid performance. Fifth, peer-to-peer trading is market-driven , not based upon predetermined pricing, which optimizes local consumption and thus the use of (cheaper) local renewables, increasing affordability, reducing reliance and overall/peak load on the grid, supporting efficient asset utilization, and reducing system losses. Sixth, it increases community self-sufficiency and energy savings , providing emergency power backup, and mitigating the need for new transmission infrastructure. Seventh, the software empowers customer engagement in energy markets by lowering barriers, creating cost incentives, and increasing choice (e.g., type of energy consumed or preferred trading partner). Finally, the peer-to-peer trading system incentivizes private investment in electric system infrastructure by increasing revenue from renewable DERs and providing decision-making tools. Grid Singularity fosters interoperability and open-source development, collaborating with other market actors that provide grid management and asset aggregation services. Our software is agnostic to regulation , with regulatory compliance such as balance reporting provided by implementation partners.","title":"Grid Singularity Technical Approach"},{"location":"two-sided-pay-as-bid/","text":"In the Two-Sided Pay-as-Bid market, buyers are able to place bids in the market, alongside the offers placed by sellers. Each market collects and matches bids and offers issued by trading agents, and dispatches bids and offers to other markets via the Inter-Area Agent (IAA). Bids and offers can also be annulled by the trading agent. The auction is continuous , meaning that once an offer or bid is posted, it can be matched right away, even before the end of the market slot. An Inter-Area Agent is created and operated by each market (area) . Its role is to forward offers and bids to the connected markets. The market constantly triggers the matching between bids and offers according to the matching algorithm as illustrated in the figure below.","title":"Two-Sided Pay-as-Bid Market"},{"location":"two-sided-pay-as-clear/","text":"In the Two-Sided Pay-as-Clear market, buyers are able to place bids in the market alongside the offers placed by sellers. The market collects and matches bids and offers issued by trading agents, and dispatches bids and offers to other markets via the Inter-Area Agent (IAA). Bids and offers can also be annulled by the trading agent. IAAs are created and operated by each market (area) to forward bids and offers to the connected markets. Currently, there is a merit-order-effect mechanism implemented for bid and offer matching where bids and offers are aggregated and cleared in a specified clearing interval. At the end of each interval, bids are arranged in a descending order, offers in an ascending order and the equilibrium quantity of energy and price is calculated. The clearing point (the quantity of energy that is accepted trade volume for a specific energy rate clearing price ) is determined by the point where the arranged bid curve for the buyers drops below the offer curve for the sellers. The highest bids are matched with the lowest offers. The matching rate is the clearing price (cents/kWh). The remaining bids and offers (right of the clearing point in the plot above) are not cleared at this clearing point and remain in the market for later matching.","title":"Two-Sided Pay-as-Clear Market"},{"location":"ui-initialisation/","text":"To start using the Grid Singularity Energy Exchange ), you need to register your account by selecting a user email and password. You will then receive an email with a link to confirm your account. You can design your own project by clicking on \u201cnew project\u201d and then create a new simulation. The first step in setting up a simulation is to define the simulation general and market settings, described in more detail below. The next step is to design your grid. Once you arrive in the grid setup, the first thing that you will have to do is to define the market maker. Subsequently, you can start building the digital twin of your grid including submarkets and relevant energy assets that can all be individually configured. The setup is intended to represent the physical architecture of the real energy market (country, region, neighbourhood, house, etc.). After your grid setup is complete, you can run your simulation. When it is finished you can view multiple scrollable plots and tables on the Results page. For a step-by-step explanation on how to set up your simulation, please watch our tutorial . You can also contact us at contact@gridsingularity.com or on slack Slack Note: For smoother simulations and smaller queues, we have set some boundaries. First, the simulations are limited in their duration. You can currently set the duration from 1 to 7 days . Furthermore, the number of agents per simulation is limited. Each market and asset is represented by an agent and you can define up to 1000 agents . Please see instructions on Backend simulation configuration here .","title":"Setting up a simulation in the User Interface"},{"location":"upload-file-formats/","text":"Files can be uploaded to generate custom energy supply or load profiles. The following file formats are supported: Comma Separated Values (.csv) \u00b6 The separation can be done by comma , or semicolon ; . Two time formats are supported, see below. Power set-points are given in Watts . The software handles any conversions to energy (in kWh). All entered csv data values need to be positive hh:mm \u00b6 Example: INTERVAL;POWER(W): 00:00;10 00:15;10 00:30;10 00:45;10 01:00;10 YYYY-MM-DDThh:mm \u00b6 Example: INTERVAL,POWER(W) 2019-01-01T00:00,10.0 2019-01-01T00:15,10.0 2019-01-01T00:30,10.0 2019-01-01T00:45,10.0 2019-01-01T01:00,10.0 Note: If you upload csv files with date information, the start-date of the simulation should be identical in the csv files and simulation settings .","title":"File Upload Format"},{"location":"upload-file-formats/#comma-separated-values-csv","text":"The separation can be done by comma , or semicolon ; . Two time formats are supported, see below. Power set-points are given in Watts . The software handles any conversions to energy (in kWh). All entered csv data values need to be positive","title":"Comma Separated Values (.csv)"},{"location":"upload-file-formats/#hhmm","text":"Example: INTERVAL;POWER(W): 00:00;10 00:15;10 00:30;10 00:45;10 01:00;10","title":"hh:mm"},{"location":"upload-file-formats/#yyyy-mm-ddthhmm","text":"Example: INTERVAL,POWER(W) 2019-01-01T00:00,10.0 2019-01-01T00:15,10.0 2019-01-01T00:30,10.0 2019-01-01T00:45,10.0 2019-01-01T01:00,10.0 Note: If you upload csv files with date information, the start-date of the simulation should be identical in the csv files and simulation settings .","title":"YYYY-MM-DDThh:mm"},{"location":"version-update/","text":"Grid Singularity energy exchange engine (D3A) Update \u00b6 Please start by opening a terminal and activating the Grid Singularity D3A virtual environment as described in the Installation Instructions. Then type: git pull origin/master fab sync If fab sync does not work on your machine, please try: pip install -e . Grid Singularity API Client Update \u00b6 Please start by opening a terminal and activating the API client virtual environment as described in the API Installation Instructions. Then type: pip uninstall d3a-api-client Press y when prompted. Once the uninstall is complete, type: pip install git+https://github.com/gridsingularity/d3a-api-client.git","title":"Version Updates"},{"location":"version-update/#grid-singularity-energy-exchange-engine-d3a-update","text":"Please start by opening a terminal and activating the Grid Singularity D3A virtual environment as described in the Installation Instructions. Then type: git pull origin/master fab sync If fab sync does not work on your machine, please try: pip install -e .","title":"Grid Singularity energy exchange engine (D3A) Update"},{"location":"version-update/#grid-singularity-api-client-update","text":"Please start by opening a terminal and activating the API client virtual environment as described in the API Installation Instructions. Then type: pip uninstall d3a-api-client Press y when prompted. Once the uninstall is complete, type: pip install git+https://github.com/gridsingularity/d3a-api-client.git","title":"Grid Singularity API Client Update"},{"location":"vision/","text":"The Grid Singularity Energy Exchange Engine is developed by Grid Singularity as an interface ( map.gridsingularity ) and open source codebase (see Licensing ) to model, simulate, optimize and (coming soon) download and deploy interconnected, grid-aware energy marketplaces. Grid Singularity has been proclaimed the World Tech Pioneer by the World Economic Forum and is also known as a co-founder of the Energy Web Foundation that gathers leading energy corporations globally co-developing a shared blockchain-based platform. Our team is guided by the following principles: Grid Singularity facilitates a bottom-up market design by connecting aggregators, which in turn connect households and distributed energy assets digitally represented by trading agents, and grid operators through an application interface ( Grid Operator API and Asset API ). The backend code offers the full functionality of the active version of the D3A, while the user friendly User Interface (UI) offers eased access to the majority of features found in the backend. New features are typically developed in the backend first and are made available in the UI after internal testing for usability and accuracy. Our software empowers energy communities. An energy community is a grouping of multiple energy actors: consumers, producers and prosumers (consumers who also produce energy) with the goal to exchange energy locally to improve economic, social and environmental welfare. The European Union defines these communities as citizen energy communities or renewable energy communities (see Energy Communities: a Game Changer for the European Electricity Grid , 2020) and they are also known as energy cooperatives, microgrids, self-consumption communities or community choice aggregators (CCAs) in different markets. Modelling simulation studies carried out by Grid Singularity and German and Dutch energy communities and utilities using real-world data have revealed that the use of Grid Singularity\u2019s Energy Exchange Engine can increase community self-sufficiency and self-consumption by 7.7% and 5.7%, respectively, and reduce energy bills by around 21% , which could be reinvested in additional storage or other distributed energy assets (DERs). Utilization of Grid Singularity\u2019s exchange engine by a grid operator could reduce peak loading and congestion by purchasing grid balancing services and levying flexible grid fees . The initial simulation experiments undertaken by Grid Singularity and German and Dutch energy grid operators revealed 10% reductions in peak loading and congestion, expected to improve with innovation in trading algorithms and grid tariff models. Importantly, Grid Singularity\u2019s energy exchange engine furnishes both prosumers and regular consumers with equitable access to energy trading. Simulations studies, undertaken by using real data from a German energy community EWS Sch\u00f6nau, showed that activating local peer-to-peer trading benefits not just a community endowed in distributed resources but also a neighbouring community devoid of such resources: Week Electricity Bills No intercommunity trade With intercommunity trade Absolute change Relative change November EWS Sch\u00f6nau 787.1 \u20ac 793.7 \u20ac 6.6 \u20ac 0.84 % May -679.5 \u20ac -789.7 \u20ac -110.2 \u20ac -16.22 % November Community without own generation 2068.3 \u20ac 2018.8 \u20ac -49.5 \u20ac -2.39 % May 952.9 \u20ac 865.8 \u20ac -87.1 \u20ac -9.14 % Table: EWS Schonau and consumer community electricity bills with and without inter-community trading for the weeks of November and May To efficiently manage energy within a community while preserving end-user freedom and decentralization, a local energy market (LEM) enabling peer-to-peer and community trading can be established. Grid Singularity\u2019s simulation tool available at d3a.io can be used to configure a grid-aware LEM, leading to future physical deployment. The user can build a \u201cdigital twin\u201d representation of physical energy systems and energy markets (using real-world data) and run complex simulations in order to assess the impact of different actions or assets in the system.","title":"Grid Singularity Vision"},{"location":"vm-installation-instructions/","text":"If the D3A is already installed and updated on your virtual machine you can skip to step 4. Step 1: Windows environment settings (not always required, please try starting with Step 2) \u00b6 Enable Intel Virtualization on your computer in BIOS. Go to your Windows Features setting and disable Windows Hypervisor Platform (or Hyper-V) and enable Virtual Machine Platform. Step 2: Install Virtualbox and Vagrant \u00b6 It is recommended to use Chocolatey as a package management tool for Windows. Open your terminal (cmd.exe) as administrator and install chocolatey by running the following command : @\"%SystemRoot%\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\" -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command \"[System.Net.ServicePointManager]::SecurityProtocol = 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))\" && SET \"PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin\" Install Virtualbox from a Windows console choco install virtualbox Install Vagrant (this is a software wrapper around virtualbox and other supervisors, that allows easy creation, download, and installation of virtual machines. choco install vagrant vagrant plugin install vagrant-disksize Step 3: Install D3A while sharing a folder between guest and host machine via vagrant \u00b6 Create a new-folder that you want to share across guest and host machines. Add the Vagrantfile from D3A repository into your newly created folder. Open a terminal and go into your newly-created folder with: cd <path-to-your-folder> If it is your first time do: vagrant up If vagrant was already running, please delete re-initialize with the following steps first : Delete old vagrant images via : vagrant destroy --force Remove residues of old vagrant boxes via : vagrant box remove ubuntu/<your-box-name> --all --force Step 4: Reload your virtual machine: \u00b6 vagrant reload Step 5: Access your virtual machine terminal to run D3A: \u00b6 vagrant ssh Step 6: Share folder to Windows host by running these three commands: \u00b6 cp -r /home/vagrant/d3a /vagrant/ Share d3a-api-client : cp -r /home/vagrant/d3a-api-client /vagrant/ If you have results you want to export to windows : cd /home/vagrant/d3a-simulation/ zip -r <your-zip-filename>.zip ./<folder-to-be-zipped>/ cp -r <your-zip-filename>.zip /vagrant/ Step 7: Run Grid Singularity D3A simulation \u00b6 Activate the D3A environment: source /home/vagrant/envs/d3a/bin/activate Run simulation with: cd /vagrant/d3a d3a run Step 8: Run the D3A API client in Vagrant \u00b6 Activate the API-client environment: source /home/vagrant/envs/api-client/bin/activate To run your API script, run the following command (template here): python your_api_script.py","title":"Virtual Machine Installation Instructions"},{"location":"vm-installation-instructions/#step-1-windows-environment-settings-not-always-required-please-try-starting-with-step-2","text":"Enable Intel Virtualization on your computer in BIOS. Go to your Windows Features setting and disable Windows Hypervisor Platform (or Hyper-V) and enable Virtual Machine Platform.","title":"Step 1: Windows environment settings (not always required, please try starting with Step 2)"},{"location":"vm-installation-instructions/#step-2-install-virtualbox-and-vagrant","text":"It is recommended to use Chocolatey as a package management tool for Windows. Open your terminal (cmd.exe) as administrator and install chocolatey by running the following command : @\"%SystemRoot%\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\" -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command \"[System.Net.ServicePointManager]::SecurityProtocol = 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))\" && SET \"PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin\" Install Virtualbox from a Windows console choco install virtualbox Install Vagrant (this is a software wrapper around virtualbox and other supervisors, that allows easy creation, download, and installation of virtual machines. choco install vagrant vagrant plugin install vagrant-disksize","title":"Step 2: Install Virtualbox and Vagrant"},{"location":"vm-installation-instructions/#step-3-install-d3a-while-sharing-a-folder-between-guest-and-host-machine-via-vagrant","text":"Create a new-folder that you want to share across guest and host machines. Add the Vagrantfile from D3A repository into your newly created folder. Open a terminal and go into your newly-created folder with: cd <path-to-your-folder> If it is your first time do: vagrant up If vagrant was already running, please delete re-initialize with the following steps first : Delete old vagrant images via : vagrant destroy --force Remove residues of old vagrant boxes via : vagrant box remove ubuntu/<your-box-name> --all --force","title":"Step 3: Install D3A while sharing a folder between guest and host machine via vagrant"},{"location":"vm-installation-instructions/#step-4-reload-your-virtual-machine","text":"vagrant reload","title":"Step 4: Reload your virtual machine:"},{"location":"vm-installation-instructions/#step-5-access-your-virtual-machine-terminal-to-run-d3a","text":"vagrant ssh","title":"Step 5: Access your virtual machine terminal to run D3A:"},{"location":"vm-installation-instructions/#step-6-share-folder-to-windows-host-by-running-these-three-commands","text":"cp -r /home/vagrant/d3a /vagrant/ Share d3a-api-client : cp -r /home/vagrant/d3a-api-client /vagrant/ If you have results you want to export to windows : cd /home/vagrant/d3a-simulation/ zip -r <your-zip-filename>.zip ./<folder-to-be-zipped>/ cp -r <your-zip-filename>.zip /vagrant/","title":"Step 6: Share folder to Windows host by running these three commands:"},{"location":"vm-installation-instructions/#step-7-run-grid-singularity-d3a-simulation","text":"Activate the D3A environment: source /home/vagrant/envs/d3a/bin/activate Run simulation with: cd /vagrant/d3a d3a run","title":"Step 7: Run Grid Singularity D3A simulation"},{"location":"vm-installation-instructions/#step-8-run-the-d3a-api-client-in-vagrant","text":"Activate the API-client environment: source /home/vagrant/envs/api-client/bin/activate To run your API script, run the following command (template here): python your_api_script.py","title":"Step 8: Run the D3A API client in Vagrant"}]}