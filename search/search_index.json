{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"api-overview/","text":"Definition \u00b6 To enable users to interact with a running collaboration or a canary test network, two different application interfaces (APIs) are available. The Asset API allows the user to manage multiple energy assets by implementing custom trading strategies. The Grid Operator API allows the user to manage multiple markets by implementing custom grid fee strategies. Both interfaces allow strategies to incorporate market and asset statistics. Two examples of template API scripts are available in the Grid Singularity\u2019s GitHub repository: Asset API and Grid Operator API . These two APIs interact with Grid Singularity simulations through the open source Grid Singularity\u2019s API client . API Client Installation \u00b6 Note: If you are running the Grid Singularity energy exchange engine (D3A) using a virtual machine and vagrant , the latest api-client is already installed on your machine and you can skip to the Launch Simulation section below. If you are running the engine locally, please follow the following instructions. Install Redis server. Open a new terminal and type \u00b6 brew install redis Install d3a-client \u00b6 mkvirtualenv d3a-api-env pip install git+https://github.com/gridsingularity/d3a-api-client.git Update d3a-client (as needed when an update is deployed) \u00b6 pip uninstall d3a-api-client pip install git+https://github.com/gridsingularity/d3a-api-client.git User Interface \u00b6 To connect the API to simulations, the user needs to register and be approved for a collaborative simulation by following these steps . Once the user successfully registers for the relevant assets or markets, the user needs to adapt their API scripts. Backend \u00b6 Start Redis server \u00b6 To use the API locally, your script interacts with the simulation using a local Redis instance. To start the redis instance, open a new terminal and run the following command : redis-server /usr/local/etc/redis.conf Open external connection to API for Assets \u00b6 In the setup file (template available here ), an asset must be designated as open to external connection via the API. This is controlled when setting up the simulation in the setup file by designating the ExternalStrategy for each relevant energy assets : Area ( 'house-1-s' , [ Area ( 'h1-load-s' , strategy = LoadProfileExternalStrategy ( daily_load_profile = load1 , initial_buying_rate = Houses_initial_buying_rate , use_market_maker_rate = True ) ), Area ( 'h1-pv-s' , strategy = PVUserProfileExternalStrategy ( power_profile = pv1 , initial_selling_rate = PV_initial , final_selling_rate = PV_final ) ), Area ( 'h1-storage-s' , strategy = StorageExternalStrategy ( initial_soc = 50 ) ), ], grid_fee_percentage = 0 , grid_fee_const = 0 , external_connection_available = True ), By default, trading strategies do not allow API connections unless the ExternalStrategy is used. Please also ensure that the appropriate libraries are imported to use the API (as in the template setup file provided). Open Markets for external connection \u00b6 The API supports multiple markets managed with the Grid Operator API . Access is controlled when setting up the simulation, using the Area class\u2019 boolean argument called external_connection_available: Area ( 'Member 2' , [ ... ], # Children of the area external_connection_available = True ), If set to true, the area allows all of its submarkets and assets to request the the area\u2019s market statistics through the API. By default, this external_connection_available is set to False . Launch simulation \u00b6 This requires you to have the backend codebase installed on your machine to run simulations (see installation instructions). First navigate to the D3A folder in a new terminal, then activate the D3A environment with the command: workon d3a Then run: d3a -l INFO run -t 15s -s 15m --setup odyssey_momentum.odyssey_training --start-date 2014-10-01 --enable-external-connection After a few seconds, trading should begin, resembling the figure below. Initialise and start the API : \u00b6 Before launching the API script, the user needs to adapt the following information in their script (script template available here) : Oracle name \u00b6 This parameter is only relevant when using the API on the User-Interface. This defines the name of the aggregator / API name that manages the markets and energy assets. Once the name is set it cannot be changed within the same running collaboration. oracle_name = 'oracle' Assets/markets list \u00b6 The list of assets / markets needs to be updated to include the assets registered to user through the registration process, in arrays as follows: load_names = [ 'Load 1' , 'Load 2' ] pv_names = [ 'PV 1' ] storage_names = [ 'Storage 1' ] market_names = [ \"Grid\" , \"Community\" ] Environment setting : \u00b6 The user needs to define if the simulation is run locally (using the backend and redis) or on User-Interface. If it is run on the backend the user needs to set : RUN_ON_D3A_WEB = False If it is run on the UI the user need to set the parameter to True and specify the simulation ID (found in the simulation\u2019s URL) : RUN_ON_D3A_WEB = True simulation_id = '9682dc94-ad8f-4661-bfbb-a3b8a3b209a9' Once the script is adapted, the user can launch it with the following command, replacing the template name with the updated script\u2019s name : python assets_api_template.py","title":"Overview"},{"location":"api-overview/#definition","text":"To enable users to interact with a running collaboration or a canary test network, two different application interfaces (APIs) are available. The Asset API allows the user to manage multiple energy assets by implementing custom trading strategies. The Grid Operator API allows the user to manage multiple markets by implementing custom grid fee strategies. Both interfaces allow strategies to incorporate market and asset statistics. Two examples of template API scripts are available in the Grid Singularity\u2019s GitHub repository: Asset API and Grid Operator API . These two APIs interact with Grid Singularity simulations through the open source Grid Singularity\u2019s API client .","title":"Definition"},{"location":"api-overview/#api-client-installation","text":"Note: If you are running the Grid Singularity energy exchange engine (D3A) using a virtual machine and vagrant , the latest api-client is already installed on your machine and you can skip to the Launch Simulation section below. If you are running the engine locally, please follow the following instructions.","title":"API Client Installation"},{"location":"api-overview/#install-redis-server-open-a-new-terminal-and-type","text":"brew install redis","title":"Install Redis server. Open a new terminal and type"},{"location":"api-overview/#install-d3a-client","text":"mkvirtualenv d3a-api-env pip install git+https://github.com/gridsingularity/d3a-api-client.git","title":"Install d3a-client"},{"location":"api-overview/#update-d3a-client-as-needed-when-an-update-is-deployed","text":"pip uninstall d3a-api-client pip install git+https://github.com/gridsingularity/d3a-api-client.git","title":"Update d3a-client (as needed when an update is deployed)"},{"location":"api-overview/#user-interface","text":"To connect the API to simulations, the user needs to register and be approved for a collaborative simulation by following these steps . Once the user successfully registers for the relevant assets or markets, the user needs to adapt their API scripts.","title":"User Interface"},{"location":"api-overview/#backend","text":"","title":"Backend"},{"location":"api-overview/#start-redis-server","text":"To use the API locally, your script interacts with the simulation using a local Redis instance. To start the redis instance, open a new terminal and run the following command : redis-server /usr/local/etc/redis.conf","title":"Start Redis server"},{"location":"api-overview/#open-external-connection-to-api-for-assets","text":"In the setup file (template available here ), an asset must be designated as open to external connection via the API. This is controlled when setting up the simulation in the setup file by designating the ExternalStrategy for each relevant energy assets : Area ( 'house-1-s' , [ Area ( 'h1-load-s' , strategy = LoadProfileExternalStrategy ( daily_load_profile = load1 , initial_buying_rate = Houses_initial_buying_rate , use_market_maker_rate = True ) ), Area ( 'h1-pv-s' , strategy = PVUserProfileExternalStrategy ( power_profile = pv1 , initial_selling_rate = PV_initial , final_selling_rate = PV_final ) ), Area ( 'h1-storage-s' , strategy = StorageExternalStrategy ( initial_soc = 50 ) ), ], grid_fee_percentage = 0 , grid_fee_const = 0 , external_connection_available = True ), By default, trading strategies do not allow API connections unless the ExternalStrategy is used. Please also ensure that the appropriate libraries are imported to use the API (as in the template setup file provided).","title":"Open external connection to API for Assets"},{"location":"api-overview/#open-markets-for-external-connection","text":"The API supports multiple markets managed with the Grid Operator API . Access is controlled when setting up the simulation, using the Area class\u2019 boolean argument called external_connection_available: Area ( 'Member 2' , [ ... ], # Children of the area external_connection_available = True ), If set to true, the area allows all of its submarkets and assets to request the the area\u2019s market statistics through the API. By default, this external_connection_available is set to False .","title":"Open Markets for external connection"},{"location":"api-overview/#launch-simulation","text":"This requires you to have the backend codebase installed on your machine to run simulations (see installation instructions). First navigate to the D3A folder in a new terminal, then activate the D3A environment with the command: workon d3a Then run: d3a -l INFO run -t 15s -s 15m --setup odyssey_momentum.odyssey_training --start-date 2014-10-01 --enable-external-connection After a few seconds, trading should begin, resembling the figure below.","title":"Launch simulation"},{"location":"api-overview/#initialise-and-start-the-api","text":"Before launching the API script, the user needs to adapt the following information in their script (script template available here) :","title":"Initialise and start the API :"},{"location":"api-overview/#oracle-name","text":"This parameter is only relevant when using the API on the User-Interface. This defines the name of the aggregator / API name that manages the markets and energy assets. Once the name is set it cannot be changed within the same running collaboration. oracle_name = 'oracle'","title":"Oracle name"},{"location":"api-overview/#assetsmarkets-list","text":"The list of assets / markets needs to be updated to include the assets registered to user through the registration process, in arrays as follows: load_names = [ 'Load 1' , 'Load 2' ] pv_names = [ 'PV 1' ] storage_names = [ 'Storage 1' ] market_names = [ \"Grid\" , \"Community\" ]","title":"Assets/markets list"},{"location":"api-overview/#environment-setting","text":"The user needs to define if the simulation is run locally (using the backend and redis) or on User-Interface. If it is run on the backend the user needs to set : RUN_ON_D3A_WEB = False If it is run on the UI the user need to set the parameter to True and specify the simulation ID (found in the simulation\u2019s URL) : RUN_ON_D3A_WEB = True simulation_id = '9682dc94-ad8f-4661-bfbb-a3b8a3b209a9' Once the script is adapted, the user can launch it with the following command, replacing the template name with the updated script\u2019s name : python assets_api_template.py","title":"Environment setting :"},{"location":"assets-api/","text":"The Grid Singularity API client allows you to create agents that follow custom trading strategies to buy and sell energy in the energy market. The agent can request and receive information through the Asset API, feed that information into an algorithm, and post bids or offers on a live simulated exchange. API Commands \u00b6 Event-Triggered Functions \u00b6 In order to facilitate bid and offer management and scheduling, a python file with the class Oracle is provided. The Oracle class acts as an information aggregator for all of the energy assets (e.g. loads and PVs) you manage, and allows you to post bids and offers on their behalf. A few functions are triggered on different types of events, and can be overridden, useful to take actions when market events occur. Each new market ( ON_MARKET_CYCLE(SELF, MARKET_INFO) ) \u00b6 When a new market slot is available the client will get notified via an event. It is possible to capture this event and perform operations after it by overriding the on_market_cycle method. Ex: def on_market_cycle(self, market_info): In the variable market_info you will get a dictionary with information on the market and your assets. You receive information for each asset you manage. The return values are the following : { \"name\" : \"house2\" , \"id\" : \"13023c7d-205d-4b3a-a434-02375eb277ca\" , \"start_time\" : # s tart - t ime o f t he marke t slo t , \"duration_min\" : # 15 , \"asset_info\" : { \"energy_requirement_kWh\" : # e ner gy t ha t t he asse t has t o buy duri n g t his marke t slo t , \"available_energy_kWh\" : # e ner gy t ha t t he asse t has t o sell duri n g t his marke t slo t }, \"event\" : \"market\" , \"asset_bill\" : { \"bought\" : # e ner gy bough t i n kWh , \"sold\" : # e ner gy sold i n kWh , \"spent\" : # mo ne y spe nt i n \u20ac , \"earned\" : # mo ne y ear ne d i n \u20ac , \"total_energy\" : # bough t - sold , \"total_cost\" : # spe nt - ear ne d , \"market_fee\" : # \u20ac t ha t goes i n grid fee , \"type\" : # t ype o f t he s trate gy }, \"last_market_stats\" : { \"min_trade_rate\" : # mi n imum tra de price i n \u20ac/kWh , \"max_trade_rate\" : # maximum tra de price i n \u20ac/kWh , \"avg_trade_rate\" : # average tra de price i n \u20ac/kWh , \"total_traded_energy_kWh\" : # t o tal e ner gy tra ded i n kWh } } On % of market slot completion (ON_TICK(SELF, TICK_INFO)) \u00b6 Each 10% of market slot completion (e.g. 10%, 20%, 30%, \u2026), the same information as market_info will be passed, with updated asset energy requirements based on trades. This can be used to update your bid or offer price at these milestones. On trade(ON_TRADE(SELF, TRADE_INFO)) \u00b6 Each time the asset you manage completes a trade, information about the trade is passed through trade_info. This information can be stored locally or acted upon. On simulation finish (ON_FINISHED(SELF)) \u00b6 This executes when the simulation finishes, and can be used to trigger exporting data, training a model or exiting the code. Sending bids and offers \u00b6 The oracle is able to post bids and offers for multiple assets at the same time. This is implemented already in the template. A batch_command dictionary structure is used. To update an existing bid with a load and update both your bid and offer with a storage asset, you would use: batch_commands = {} batch_commands [ asset_event [ \"area_uuid\" ]] = [ { \"type\" : \"update_bid\" , \"price\" : price , \"energy\" : energy },] batch_commands [ asset_event [ \"area_uuid\" ]] = [ { \"type\" : \"update_bid\" , \"price\" : buy_price , \"energy\" : buy_energy }, { \"type\" : \"update_offer\" , \"price\" : sell_price , \"energy\" : sell_energy },) self . batch_command ( batch_commands ) Note: The total amount of energy bid at any point is limited to the energy requirement of the asset. Updating a bid during a market slot deletes other active bids. Additionally, the price of your bids/offers must be a positive float otherwise it will get rejected by the market. Trading Strategies \u00b6 A simple trading strategy is available in the template agent . See the TODO flags there to see how you may configure your trading strategy and extract market and asset data.","title":"Asset API"},{"location":"assets-api/#api-commands","text":"","title":"API Commands"},{"location":"assets-api/#event-triggered-functions","text":"In order to facilitate bid and offer management and scheduling, a python file with the class Oracle is provided. The Oracle class acts as an information aggregator for all of the energy assets (e.g. loads and PVs) you manage, and allows you to post bids and offers on their behalf. A few functions are triggered on different types of events, and can be overridden, useful to take actions when market events occur.","title":"Event-Triggered Functions"},{"location":"assets-api/#each-new-market-on_market_cycleself-market_info","text":"When a new market slot is available the client will get notified via an event. It is possible to capture this event and perform operations after it by overriding the on_market_cycle method. Ex: def on_market_cycle(self, market_info): In the variable market_info you will get a dictionary with information on the market and your assets. You receive information for each asset you manage. The return values are the following : { \"name\" : \"house2\" , \"id\" : \"13023c7d-205d-4b3a-a434-02375eb277ca\" , \"start_time\" : # s tart - t ime o f t he marke t slo t , \"duration_min\" : # 15 , \"asset_info\" : { \"energy_requirement_kWh\" : # e ner gy t ha t t he asse t has t o buy duri n g t his marke t slo t , \"available_energy_kWh\" : # e ner gy t ha t t he asse t has t o sell duri n g t his marke t slo t }, \"event\" : \"market\" , \"asset_bill\" : { \"bought\" : # e ner gy bough t i n kWh , \"sold\" : # e ner gy sold i n kWh , \"spent\" : # mo ne y spe nt i n \u20ac , \"earned\" : # mo ne y ear ne d i n \u20ac , \"total_energy\" : # bough t - sold , \"total_cost\" : # spe nt - ear ne d , \"market_fee\" : # \u20ac t ha t goes i n grid fee , \"type\" : # t ype o f t he s trate gy }, \"last_market_stats\" : { \"min_trade_rate\" : # mi n imum tra de price i n \u20ac/kWh , \"max_trade_rate\" : # maximum tra de price i n \u20ac/kWh , \"avg_trade_rate\" : # average tra de price i n \u20ac/kWh , \"total_traded_energy_kWh\" : # t o tal e ner gy tra ded i n kWh } }","title":"Each new market (ON_MARKET_CYCLE(SELF, MARKET_INFO))"},{"location":"assets-api/#on-of-market-slot-completion-on_tickself-tick_info","text":"Each 10% of market slot completion (e.g. 10%, 20%, 30%, \u2026), the same information as market_info will be passed, with updated asset energy requirements based on trades. This can be used to update your bid or offer price at these milestones.","title":"On % of market slot completion (ON_TICK(SELF, TICK_INFO))"},{"location":"assets-api/#on-tradeon_tradeself-trade_info","text":"Each time the asset you manage completes a trade, information about the trade is passed through trade_info. This information can be stored locally or acted upon.","title":"On trade(ON_TRADE(SELF, TRADE_INFO))"},{"location":"assets-api/#on-simulation-finish-on_finishedself","text":"This executes when the simulation finishes, and can be used to trigger exporting data, training a model or exiting the code.","title":"On simulation finish (ON_FINISHED(SELF))"},{"location":"assets-api/#sending-bids-and-offers","text":"The oracle is able to post bids and offers for multiple assets at the same time. This is implemented already in the template. A batch_command dictionary structure is used. To update an existing bid with a load and update both your bid and offer with a storage asset, you would use: batch_commands = {} batch_commands [ asset_event [ \"area_uuid\" ]] = [ { \"type\" : \"update_bid\" , \"price\" : price , \"energy\" : energy },] batch_commands [ asset_event [ \"area_uuid\" ]] = [ { \"type\" : \"update_bid\" , \"price\" : buy_price , \"energy\" : buy_energy }, { \"type\" : \"update_offer\" , \"price\" : sell_price , \"energy\" : sell_energy },) self . batch_command ( batch_commands ) Note: The total amount of energy bid at any point is limited to the energy requirement of the asset. Updating a bid during a market slot deletes other active bids. Additionally, the price of your bids/offers must be a positive float otherwise it will get rejected by the market.","title":"Sending bids and offers"},{"location":"assets-api/#trading-strategies","text":"A simple trading strategy is available in the template agent . See the TODO flags there to see how you may configure your trading strategy and extract market and asset data.","title":"Trading Strategies"},{"location":"balancing-implementation/","text":"Figure: Structure of Balancing Market in Grid Singularity energy exchange (D3A) Grid Singularity energy exchange (D3A) bottom-up market design allows participants to engage in Local Energy Market (LEM) for energy trading, providing energy balance at a local level. D3A flexibility trading also facilitates the procurement of flexibility locally from participants to assist distribution grid operation in balancing the grid. Assets \u00b6 In the Grid Singularity D3A, balancing has been implemented using: Fast responding non-critical loads to provide load shedding Battery storage Commercial power plants The trading strategies of energy assets like Loads , Storages and Power Plants can be used to balance the grid by placing balancing offers. These assets participate in the balancing market only if they are registered in the Asset Registry . Asset Registry \u00b6 How to register an energy asset in the registry in the the setup file: The balancing asset registry is a dictionary that contains the names of assets as keys and the balancing rates as tuple values: (demand balancing rate, supply balancing rate). asset_registry_dict = { \"H1 General Load\": (33, 35), \"H2 General Load\": (33, 35), \"H1 Storage1\": (33, 35), \"H1 Storage2\": (33, 35), } Balancing Market \u00b6 The present setting is a One-Sided Pay-as-Offer market , which accepts balancing_offers from energy assets and connected hierarchies of balancing_market . balancing_offers could be positive or negative. It also facilitates the balancing_trade . Balancing Agent \u00b6 The balancing agent follows the lead of the spot_market_trade of its lower hierarchy. Whenever there is a trade in the lower hierarchy of spot_market , it will try to secure a share of spot market trades in the balancing market. Constant Parameters \u00b6 The following are the constant parameters related to the balancing market, with defaults available here . ENABLE_BALANCING_MARKET \u2192 (Default: False) (It enables the simulation with Balancing Market) BALANCING_SPOT_TRADE_RATIO \u2192 (Default: 0.2) (It dictates the ratio of spot_market_energy to be traded in balancing market) BALANCING_OFFER_DEMAND_RATIO \u2192 (Default: 0.1) (It dictates the ratio of spot_market_energy to be offered in balancing market as demand_balancing_offer ) BALANCING_OFFER_SUPPLY_RATIO \u2192 (Default: 0.1) (It dictates the ratio of spot_market_energy to be offered in balancing market as supply_balancing_offer ) BALANCING_FLEXIBLE_LOADS_SUPPORT \u2192 (Default: True) (It enables Load Strategy to place supply_balancing_offer (effectively curtailing it's load)) Multiple examples of balancing market setup are available here .","title":"Balancing Market Implementation"},{"location":"balancing-implementation/#assets","text":"In the Grid Singularity D3A, balancing has been implemented using: Fast responding non-critical loads to provide load shedding Battery storage Commercial power plants The trading strategies of energy assets like Loads , Storages and Power Plants can be used to balance the grid by placing balancing offers. These assets participate in the balancing market only if they are registered in the Asset Registry .","title":"Assets"},{"location":"balancing-implementation/#asset-registry","text":"How to register an energy asset in the registry in the the setup file: The balancing asset registry is a dictionary that contains the names of assets as keys and the balancing rates as tuple values: (demand balancing rate, supply balancing rate). asset_registry_dict = { \"H1 General Load\": (33, 35), \"H2 General Load\": (33, 35), \"H1 Storage1\": (33, 35), \"H1 Storage2\": (33, 35), }","title":"Asset Registry"},{"location":"balancing-implementation/#balancing-market","text":"The present setting is a One-Sided Pay-as-Offer market , which accepts balancing_offers from energy assets and connected hierarchies of balancing_market . balancing_offers could be positive or negative. It also facilitates the balancing_trade .","title":"Balancing Market"},{"location":"balancing-implementation/#balancing-agent","text":"The balancing agent follows the lead of the spot_market_trade of its lower hierarchy. Whenever there is a trade in the lower hierarchy of spot_market , it will try to secure a share of spot market trades in the balancing market.","title":"Balancing Agent"},{"location":"balancing-implementation/#constant-parameters","text":"The following are the constant parameters related to the balancing market, with defaults available here . ENABLE_BALANCING_MARKET \u2192 (Default: False) (It enables the simulation with Balancing Market) BALANCING_SPOT_TRADE_RATIO \u2192 (Default: 0.2) (It dictates the ratio of spot_market_energy to be traded in balancing market) BALANCING_OFFER_DEMAND_RATIO \u2192 (Default: 0.1) (It dictates the ratio of spot_market_energy to be offered in balancing market as demand_balancing_offer ) BALANCING_OFFER_SUPPLY_RATIO \u2192 (Default: 0.1) (It dictates the ratio of spot_market_energy to be offered in balancing market as supply_balancing_offer ) BALANCING_FLEXIBLE_LOADS_SUPPORT \u2192 (Default: True) (It enables Load Strategy to place supply_balancing_offer (effectively curtailing it's load)) Multiple examples of balancing market setup are available here .","title":"Constant Parameters"},{"location":"balancing-market/","text":"Definition \u00b6 Electrical power systems are characterized by voltage and frequency and the flow of electricity is a continuous process. Buffering or storing electrical energy at each node is still not feasible, therefore electrical energy needs to be generated exactly at the time of consumption. Differences in supply and demand causes the nominal frequency (50Hz in EU) to deviate. Consequently, supply and demand need to be monitored in real time to implement adjustments to maintain equilibrium and nominal frequency. Significant deviation from the nominal leads to cascading effect culminating in a blackout . Transmission system operators (TSOs) oversee fast, flexible, fossil fuel-based generation units and demand response service from large consumers, ensuring the continuation of operation during significant transient faults in the energy system. These generators form the basis of frequency control strategies used in balancing these electrical systems. Each control strategy has specific purposes and features and can be categorized in three groups, as shown in the figure below. Primary Control (Frequency Containment Reserve - FCR) Secondary Control (Automatic Frequency Restoration Reserves - aFRR) Tertiary Control (Manual Frequency Restoration Reserves - mFRR) Figure: The three tiers of grid control and its activation structure In conventional grid structures: \u00b6 Primary control is an automatic function that is almost instantaneously activated to stabilise the frequency drops/spikes. It is the fastest type of frequency control with a response time of a few seconds and operates using a joint process involving all TSOs of the synchronous area. This is shown in the figure below. For example, if there is an increase in demand, the energy used to compensate for this demand comes from the kinetic energy stored in large rotating synchronous generators that start decreasing its velocity. This is referred to as Inertial response . For the generators to recover the speed, the speed controller of each generator acts to increase the generator power to clear the imbalance. Within a period of 30 seconds, each generating unit is able to generate the required power and stabilise this production for at least 15 minutes or depending on the requirements of the TSO within the synchronous region. Primary control is done using generation plants that are connected to the high voltage power supply with the exception of renewable energy sources which are non-schedulable due to its intermittent nature. Figure: Recovery of the system from a contingency event and action by primary frequency control (PFR) Secondary control is performed automatically by all the generators to restore the nominal frequency, the power exchanges and reserve of the generators used in primary control. The generators involved in this regulation function through dedicated reserve power that are set in conjunction with central controllers. The reserve control power is negotiated in a contract conjunction with the TSO and is a percentage of the maximum available power with a predefined minimum value to ensure that it can be dispatched whenever needed. This service is remunerated according to the set contracts. Tertiary control is not an automatic function and is executed upon request by the grid operator. The reserve margins used for the secondary control are restored through tertiary control. The differences between the primary, secondary and tertiary frequency control is the time the production and response can be activated, and the remuneration for each. Primary frequency control is symmetrical as the capacity for control has been scheduled and usually balances between ramping up and down the production and therefore not remunerated. Secondary and tertiary control are not symmetrical as the capacity can be used only for ramping up or down the production to restore the frequency and are remunerated. Review of the three levels of regulation \u00b6 Response Time Duration Time Operation Purpose Primary Control 10-30 Seconds 15 Minutes Automatic Act in case of frequency variation in order to stabilize frequency value Secondary Control 200 Seconds 120 minutes Automatic Act to bring back frequency value to the nominal value and restore the power reserve of the generators used for the primary frequency control Tertiary Control 15 Minutes Indicated by TSO Upon Request Act to restore power reserves of the generators used for the secondary frequency control Table: Main features of frequency control strategies In our transactive energy low voltage grid structure primary, secondary and tertiary control are controlled by an area controller called the balancing agent. Area control structure of market consisting of all three tiers of control (source: Martin Fornage, A generalized transactive energy based framework: Enphase Energy. Powerpoint presentation 2015) The balancing agent monitors the health of the system and is in control of all its allocated resources. It also had the ability to control the physical connect and disconnect from upstream and downstream resources according to the type of control required. Primary control happens simultaneously as the spot market through a droop curve. Grid forming assets have different droop curves based on their behaviour (Loads, Storage, PV) which are used to keep the voltage and frequency towards nominal in case of a deviation. Local balancing is therefore done through primary control. Secondary control (Inertia Control) is done through a time schedule. The schedule is received from the upper tertiary control or from a ledger. Secondary balancing agents adjust the primary balancing agents resources within its market by disconnecting and connecting them in case of failure of upstream structure or failure to meet the schedule. Tertiary control negotiates the schedules upstream or downstream at lowest cost of operation and provides a marketplace for energy in and out of the market area. The inputs of the tertiary control are the bids, offers and error signals from secondary control. The outputs are the schedules to resources.","title":"Balancing Market Structure"},{"location":"balancing-market/#definition","text":"Electrical power systems are characterized by voltage and frequency and the flow of electricity is a continuous process. Buffering or storing electrical energy at each node is still not feasible, therefore electrical energy needs to be generated exactly at the time of consumption. Differences in supply and demand causes the nominal frequency (50Hz in EU) to deviate. Consequently, supply and demand need to be monitored in real time to implement adjustments to maintain equilibrium and nominal frequency. Significant deviation from the nominal leads to cascading effect culminating in a blackout . Transmission system operators (TSOs) oversee fast, flexible, fossil fuel-based generation units and demand response service from large consumers, ensuring the continuation of operation during significant transient faults in the energy system. These generators form the basis of frequency control strategies used in balancing these electrical systems. Each control strategy has specific purposes and features and can be categorized in three groups, as shown in the figure below. Primary Control (Frequency Containment Reserve - FCR) Secondary Control (Automatic Frequency Restoration Reserves - aFRR) Tertiary Control (Manual Frequency Restoration Reserves - mFRR) Figure: The three tiers of grid control and its activation structure","title":"Definition"},{"location":"balancing-market/#in-conventional-grid-structures","text":"Primary control is an automatic function that is almost instantaneously activated to stabilise the frequency drops/spikes. It is the fastest type of frequency control with a response time of a few seconds and operates using a joint process involving all TSOs of the synchronous area. This is shown in the figure below. For example, if there is an increase in demand, the energy used to compensate for this demand comes from the kinetic energy stored in large rotating synchronous generators that start decreasing its velocity. This is referred to as Inertial response . For the generators to recover the speed, the speed controller of each generator acts to increase the generator power to clear the imbalance. Within a period of 30 seconds, each generating unit is able to generate the required power and stabilise this production for at least 15 minutes or depending on the requirements of the TSO within the synchronous region. Primary control is done using generation plants that are connected to the high voltage power supply with the exception of renewable energy sources which are non-schedulable due to its intermittent nature. Figure: Recovery of the system from a contingency event and action by primary frequency control (PFR) Secondary control is performed automatically by all the generators to restore the nominal frequency, the power exchanges and reserve of the generators used in primary control. The generators involved in this regulation function through dedicated reserve power that are set in conjunction with central controllers. The reserve control power is negotiated in a contract conjunction with the TSO and is a percentage of the maximum available power with a predefined minimum value to ensure that it can be dispatched whenever needed. This service is remunerated according to the set contracts. Tertiary control is not an automatic function and is executed upon request by the grid operator. The reserve margins used for the secondary control are restored through tertiary control. The differences between the primary, secondary and tertiary frequency control is the time the production and response can be activated, and the remuneration for each. Primary frequency control is symmetrical as the capacity for control has been scheduled and usually balances between ramping up and down the production and therefore not remunerated. Secondary and tertiary control are not symmetrical as the capacity can be used only for ramping up or down the production to restore the frequency and are remunerated.","title":"In conventional grid structures:"},{"location":"balancing-market/#review-of-the-three-levels-of-regulation","text":"Response Time Duration Time Operation Purpose Primary Control 10-30 Seconds 15 Minutes Automatic Act in case of frequency variation in order to stabilize frequency value Secondary Control 200 Seconds 120 minutes Automatic Act to bring back frequency value to the nominal value and restore the power reserve of the generators used for the primary frequency control Tertiary Control 15 Minutes Indicated by TSO Upon Request Act to restore power reserves of the generators used for the secondary frequency control Table: Main features of frequency control strategies In our transactive energy low voltage grid structure primary, secondary and tertiary control are controlled by an area controller called the balancing agent. Area control structure of market consisting of all three tiers of control (source: Martin Fornage, A generalized transactive energy based framework: Enphase Energy. Powerpoint presentation 2015) The balancing agent monitors the health of the system and is in control of all its allocated resources. It also had the ability to control the physical connect and disconnect from upstream and downstream resources according to the type of control required. Primary control happens simultaneously as the spot market through a droop curve. Grid forming assets have different droop curves based on their behaviour (Loads, Storage, PV) which are used to keep the voltage and frequency towards nominal in case of a deviation. Local balancing is therefore done through primary control. Secondary control (Inertia Control) is done through a time schedule. The schedule is received from the upper tertiary control or from a ledger. Secondary balancing agents adjust the primary balancing agents resources within its market by disconnecting and connecting them in case of failure of upstream structure or failure to meet the schedule. Tertiary control negotiates the schedules upstream or downstream at lowest cost of operation and provides a marketplace for energy in and out of the market area. The inputs of the tertiary control are the bids, offers and error signals from secondary control. The outputs are the schedules to resources.","title":"Review of the three levels of regulation"},{"location":"blockchain/","text":"Purpose \u00b6 Grid Singularity energy exchange engine (D3A) has been designed so that it does not require blockchain technology, but that it can benefit from this technology to provide enhanced functionality. Grid Singularity aims to integrate blockchain for specific benefits: Decentralisation and transparency : blockchain can be used to create decentralized registry and identity. By doing so, the privacy and security of users are enhanced. Data ownership : End-users would have complete control over their data access and use Payments : Trades cleared on the market will be recorded on the chain and the payments executed. While the privacy of users will be preserved, the system would be more transparent. Degrees of Freedom: Bids and offers can be tagged with validated attributes to enable trading degrees of freedom such as preferred trading partner, energy source selection, or location restrictions on trades Asset validation : energy assets, smart meters, and entities can be validated using tools like the Energy Web Switchboard. The Energy Web Chain is the blockchain of choice for Grid Singularity D3A future blockchain implementation. Grid Singularity, an energy technology startup, and the Rocky Mountain Institute, a nonprofit clean technology organisation, jointly founded the Energy Web Foundation (EWF) in January 2017. EWF is a nonprofit foundation gathering an ecosystem of over 100 energy corporations and startups with a shared, public blockchain platform, the Energy Web Chain. While Grid Singularity has significantly contributed to EWF development and the launch of the Energy Web Chain, its role today is supervisory and advisory, with two Grid Singularity representatives serving on the EWF\u2019s Foundation Council . At present, D3A blockchain integration is used just for simulated transactions and it is based on Substrate . We are also in the process of integrating with the Energy Web Switchboard , which will be used as a decentralized asset registry . In the future we plan to move to full implementation on the Energy Web Chain, benefiting from Polkadot\u2019s scaling solution. The current basic blockchain integration uses Substrate, which allows modular business logic to be built directly in the blockchain and facilitates a high transaction throughput. Substrate has components called pallets, where each pallet can represent different functionality, such as smart contracts, storage, auctions, and more . Currently, our integration includes a storage pallet that provides immutable storage of executed transactions, and additional functionalities will continue to be actively developed. Blockchain can optionally be enabled on simulations running locally with the backend code base. There are three configuration parameters. The command-line flag is --enable-bc , used to enable blockchain operations. The two other parameters are the mnemonic to restore your key and interact with the blockchain, and the ENABLE_SUBSTRATE parameter described in the steps below. Connecting to Grid Singularity node \u00b6 https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fcanvas-node.dev.gridsingularity.com When you go to the endpoint, you will see the standard interface. That\u2019s the easiest point of interaction with the node, where you can call extrinsics, upload contracts, deploy them, test their functions, send funds and more. Simulating Grid Singularity local energy markets on Substrate \u00b6 Wallet \u00b6 Ensure that you have the Polkadot Chrome extension (it is a browser extension that allows you to manage accounts for any Substrate-based blockchain). Create an account and save your seed phrase. You will need to save \"your twelve words\" mnemonic to be able to restore your key in general, and later to pass it the models/market/blockchain_utils.py in order to call the contracts on-chain from python code. Make sure never to push your mnemonic to GitHub. Balance \u00b6 If you want to send a transaction manually or through Grid Singularity D3A in the development chain, you need to pay transaction fees ( gas ), which requires that you have funds in your wallet. In the Polkadot User Interface, go to Network \u2192 Accounts where you will see a list of pre-funded addresses called Alice, Bob, and so on. There you can send funds to your newly generated address to be able to pay for the gas. Sending 10 Units will suffice for running hundreds of simulations. These pre-funded accounts serve as a faucet as they do not represent real financial value and the transactions are simulated. Test pallet calls \u00b6 It is possible to manually test the Developer \u2192 Extrinsics \u2192 tradestorage in the UI. You can choose the prefunded addresses as the buyer (Alice) and the seller (Bob). Set a small amount e.g. 1 and rate (e.g.12) (rate here is the price at which the trade is executed). Trade ID is a bytes vector (e.g. 0x1234 ). If the extrinsic hash is successfully submitted, you will see a success message pop up in the top right corner of the UI. The Polkadot user interface does not allow you to directly go to that extrinsic hash, but you can go to Network and find the latest block. You may have to go to its parent or further to see the extrinsic hash. Running Grid Singularity D3A with Substrate \u00b6 Go to src/d3a/blockchain/constants.py and set ENABLE_SUBSTRATE = True and add your mnemonic. That will allow all the blockchain dependencies to be installed with: fab sync Each transaction in the simulation triggers a call to the pallet. Currently, the buyer and the seller are default addresses. In addition to the buyer and seller, the trade structure has a trade ID, energy quantity, and rate. Following D3A\u2019s integration with the decentralized identity registry (Energy Web Switchboard), the addresses will be actual user accounts. In the terminal, you should see the extrinsic hash and the block hash. 17:39:37.466 WARNING ( 333) d3a.d3a_core.simulation : Slot 1 of 96 - (1.0%) 0.00 second elapsed, ETA: 0.01 second 17:39:41.974 INFO ( 122) root : Extrinsic '0xe1357be7db683e0f3f85e101ea017da10fcaa63310e4dc7040e505cad9ac1a0a' sent and included in block '0x2199d0870583183e6f2c591b66e9a1a9cb2399b7b3ed21b21c3804c3cfcf730f' 17:39:41.975 INFO ( 271) d3a.models.market.one_sided : [TRADE] [Grid] [2021-01-26T00:00] {7f15aa} [origin: H1 Storage2 -> Cell Tower] [IAA House 1 -> Cell Tower] 0.025 kWh @ 0.7500000000000001 30.0 db09b600-22a9-4feb-ae4d-620cb6247702 [fee: 0.0 cts.] The block hash will allow you to find your extrinsic hash, as in this example . View events \u2192 tradestorage.TradeMapStored (this event is triggered every time we call the pallet\u2019s store trade map function).","title":"Blockchain Integration"},{"location":"blockchain/#purpose","text":"Grid Singularity energy exchange engine (D3A) has been designed so that it does not require blockchain technology, but that it can benefit from this technology to provide enhanced functionality. Grid Singularity aims to integrate blockchain for specific benefits: Decentralisation and transparency : blockchain can be used to create decentralized registry and identity. By doing so, the privacy and security of users are enhanced. Data ownership : End-users would have complete control over their data access and use Payments : Trades cleared on the market will be recorded on the chain and the payments executed. While the privacy of users will be preserved, the system would be more transparent. Degrees of Freedom: Bids and offers can be tagged with validated attributes to enable trading degrees of freedom such as preferred trading partner, energy source selection, or location restrictions on trades Asset validation : energy assets, smart meters, and entities can be validated using tools like the Energy Web Switchboard. The Energy Web Chain is the blockchain of choice for Grid Singularity D3A future blockchain implementation. Grid Singularity, an energy technology startup, and the Rocky Mountain Institute, a nonprofit clean technology organisation, jointly founded the Energy Web Foundation (EWF) in January 2017. EWF is a nonprofit foundation gathering an ecosystem of over 100 energy corporations and startups with a shared, public blockchain platform, the Energy Web Chain. While Grid Singularity has significantly contributed to EWF development and the launch of the Energy Web Chain, its role today is supervisory and advisory, with two Grid Singularity representatives serving on the EWF\u2019s Foundation Council . At present, D3A blockchain integration is used just for simulated transactions and it is based on Substrate . We are also in the process of integrating with the Energy Web Switchboard , which will be used as a decentralized asset registry . In the future we plan to move to full implementation on the Energy Web Chain, benefiting from Polkadot\u2019s scaling solution. The current basic blockchain integration uses Substrate, which allows modular business logic to be built directly in the blockchain and facilitates a high transaction throughput. Substrate has components called pallets, where each pallet can represent different functionality, such as smart contracts, storage, auctions, and more . Currently, our integration includes a storage pallet that provides immutable storage of executed transactions, and additional functionalities will continue to be actively developed. Blockchain can optionally be enabled on simulations running locally with the backend code base. There are three configuration parameters. The command-line flag is --enable-bc , used to enable blockchain operations. The two other parameters are the mnemonic to restore your key and interact with the blockchain, and the ENABLE_SUBSTRATE parameter described in the steps below.","title":"Purpose"},{"location":"blockchain/#connecting-to-grid-singularity-node","text":"https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fcanvas-node.dev.gridsingularity.com When you go to the endpoint, you will see the standard interface. That\u2019s the easiest point of interaction with the node, where you can call extrinsics, upload contracts, deploy them, test their functions, send funds and more.","title":"Connecting to Grid Singularity node"},{"location":"blockchain/#simulating-grid-singularity-local-energy-markets-on-substrate","text":"","title":"Simulating Grid Singularity local energy markets on Substrate"},{"location":"blockchain/#wallet","text":"Ensure that you have the Polkadot Chrome extension (it is a browser extension that allows you to manage accounts for any Substrate-based blockchain). Create an account and save your seed phrase. You will need to save \"your twelve words\" mnemonic to be able to restore your key in general, and later to pass it the models/market/blockchain_utils.py in order to call the contracts on-chain from python code. Make sure never to push your mnemonic to GitHub.","title":"Wallet"},{"location":"blockchain/#balance","text":"If you want to send a transaction manually or through Grid Singularity D3A in the development chain, you need to pay transaction fees ( gas ), which requires that you have funds in your wallet. In the Polkadot User Interface, go to Network \u2192 Accounts where you will see a list of pre-funded addresses called Alice, Bob, and so on. There you can send funds to your newly generated address to be able to pay for the gas. Sending 10 Units will suffice for running hundreds of simulations. These pre-funded accounts serve as a faucet as they do not represent real financial value and the transactions are simulated.","title":"Balance"},{"location":"blockchain/#test-pallet-calls","text":"It is possible to manually test the Developer \u2192 Extrinsics \u2192 tradestorage in the UI. You can choose the prefunded addresses as the buyer (Alice) and the seller (Bob). Set a small amount e.g. 1 and rate (e.g.12) (rate here is the price at which the trade is executed). Trade ID is a bytes vector (e.g. 0x1234 ). If the extrinsic hash is successfully submitted, you will see a success message pop up in the top right corner of the UI. The Polkadot user interface does not allow you to directly go to that extrinsic hash, but you can go to Network and find the latest block. You may have to go to its parent or further to see the extrinsic hash.","title":"Test pallet calls"},{"location":"blockchain/#running-grid-singularity-d3a-with-substrate","text":"Go to src/d3a/blockchain/constants.py and set ENABLE_SUBSTRATE = True and add your mnemonic. That will allow all the blockchain dependencies to be installed with: fab sync Each transaction in the simulation triggers a call to the pallet. Currently, the buyer and the seller are default addresses. In addition to the buyer and seller, the trade structure has a trade ID, energy quantity, and rate. Following D3A\u2019s integration with the decentralized identity registry (Energy Web Switchboard), the addresses will be actual user accounts. In the terminal, you should see the extrinsic hash and the block hash. 17:39:37.466 WARNING ( 333) d3a.d3a_core.simulation : Slot 1 of 96 - (1.0%) 0.00 second elapsed, ETA: 0.01 second 17:39:41.974 INFO ( 122) root : Extrinsic '0xe1357be7db683e0f3f85e101ea017da10fcaa63310e4dc7040e505cad9ac1a0a' sent and included in block '0x2199d0870583183e6f2c591b66e9a1a9cb2399b7b3ed21b21c3804c3cfcf730f' 17:39:41.975 INFO ( 271) d3a.models.market.one_sided : [TRADE] [Grid] [2021-01-26T00:00] {7f15aa} [origin: H1 Storage2 -> Cell Tower] [IAA House 1 -> Cell Tower] 0.025 kWh @ 0.7500000000000001 30.0 db09b600-22a9-4feb-ae4d-620cb6247702 [fee: 0.0 cts.] The block hash will allow you to find your extrinsic hash, as in this example . View events \u2192 tradestorage.TradeMapStored (this event is triggered every time we call the pallet\u2019s store trade map function).","title":"Running Grid Singularity D3A with Substrate"},{"location":"canary-network/","text":"The Grid Singularity Canary Test Network (CN) is the first peer-to-peer energy exchange with live energy asset data and real-time trading . At the current stage, CN acts as a uni-directional bridge between the physical and digital world, reading real consumption and generation data from real energy assets in real-time, while simulating trading with the grid\u2019s digital twins. Flexible assets\u2019 digital twins such as storage are unbundled from their physical ones, to simulate the benefits of Local Energy Markets without real world energy and financial transactions. All energy trades in the GSy Canary Test Network are simulated, meaning that no real-world financial or energy transaction occurs and flexible assets such as batteries may physically charge or discharge at different times than their simulated behaviour in the Canary Network. The GSy Canary Test Network runs at real time, meaning that assets send their actual energy usage through the Asset API once every 15 minutes . This mimics how deployed exchanges will operate, but provides only a few sets of data points every hour, requiring iterations of experiments to which doesn\u2019t meet the needs of the ongoing research efforts to determine effective market, grid fee, and agent designs. Determining the mechanics for deployable markets require frequent iterations and experimentation. Grid Singularity simulations allow for energy exchanges to be run at warp speed, meaning one week of trading can be simulated and analysed in less than two hours. This functionality allows for rapid prototyping of grid models and experimental setups . CN is designed to host an iterative process to test new ideas in a safe environment, closest as possible to reality. The following link will direct you to the Grid Singularity Canary Test Network tutorial .","title":"Canary Test Network"},{"location":"clearing-purpose/","text":"In a local energy market (LEM), bids and offers are matched according to the selected clearing mechanism. Studies show that different clearing mechanisms offer diverse benefits and limitations relating to market efficiency , fairness , and user choices . Grid Singularity\u2019s energy exchange engine (D3A) currently offers three types of clearing mechanisms: One-Sided Pay-as-Offer Market Two-Sided Pay-as-Bid Market Two-Sided Pay-as-Clear Market","title":"Clearing Mechanism Types"},{"location":"collaboration/","text":"Collaboration is a type of simulation in the Grid Singularity UI that allows multiple users to participate in the same environment. These users can act in a collaborative or competitive way, aiming to optimize specific metrics. Users can connect through the API client to actively engage in the collaboration. User roles \u00b6 Exchange Operator \u00b6 The exchange operator (EO) is responsible for building the digital twin of the electrical grid , including energy assets and markets in the modelling page. Once the setup is complete, the EO facilitates the approval of other users to register to manage a set of markets and energy assets, and subsequently launches the collaboration.The EO is also in charge of expanding the grid (with events ) or registering new users desiring to connect to the exchange over the course of a simulation. Grid Operator \u00b6 The grid operator role is designed specifically for Distribution System Operators (DSOs) and Transmission System Operators (TSOs). Those users have the possibility to register to different markets, on different grid levels in the collaboration. Once registered and approved by the EO, they can manage the relevant markets by using the Grid Operator API to change grid fees in order to influence trades to optimize specific metrics (e.g. peak percentage ). Researcher \u00b6 The researcher role is designed to represent smart meters, PV and battery vendors, community leaders, energy management companies, data scientists and aggregators in collaborations. Researchers can claim assets ( Load , PV and Storage ) and, once approved by the Exchange Operator, are responsible for buying and selling energy for the assets they manage on markets through the Asset API. How to connect \u00b6 If you wish to connect to a collaboration in the framework of an event (e.g. Energy Singularity Chaos Experiment ) or to a Canary Test Network in the framework of a live running exchange please follow these steps: Login on the User-Interface Go to the Collaborations (or Canary Test Network page), where you will see a list of all active collaborations. For each, any user may view the settings and the grid setup. If the collaboration the user wishes to join is public, they can click on Registry and Scoreboard . On this page, each market and asset of the collaboration is listed. The user can apply to manage the trading strategies of assets or the grid fee strategy of markets on the Registry. The EO is able to either approve or deny the request. Once approved, the user can start the API script and wait until the EO starts the collaboration / canary network, when trading will begin.","title":"Collaboration Tool"},{"location":"collaboration/#user-roles","text":"","title":"User roles"},{"location":"collaboration/#exchange-operator","text":"The exchange operator (EO) is responsible for building the digital twin of the electrical grid , including energy assets and markets in the modelling page. Once the setup is complete, the EO facilitates the approval of other users to register to manage a set of markets and energy assets, and subsequently launches the collaboration.The EO is also in charge of expanding the grid (with events ) or registering new users desiring to connect to the exchange over the course of a simulation.","title":"Exchange Operator"},{"location":"collaboration/#grid-operator","text":"The grid operator role is designed specifically for Distribution System Operators (DSOs) and Transmission System Operators (TSOs). Those users have the possibility to register to different markets, on different grid levels in the collaboration. Once registered and approved by the EO, they can manage the relevant markets by using the Grid Operator API to change grid fees in order to influence trades to optimize specific metrics (e.g. peak percentage ).","title":"Grid Operator"},{"location":"collaboration/#researcher","text":"The researcher role is designed to represent smart meters, PV and battery vendors, community leaders, energy management companies, data scientists and aggregators in collaborations. Researchers can claim assets ( Load , PV and Storage ) and, once approved by the Exchange Operator, are responsible for buying and selling energy for the assets they manage on markets through the Asset API.","title":"Researcher"},{"location":"collaboration/#how-to-connect","text":"If you wish to connect to a collaboration in the framework of an event (e.g. Energy Singularity Chaos Experiment ) or to a Canary Test Network in the framework of a live running exchange please follow these steps: Login on the User-Interface Go to the Collaborations (or Canary Test Network page), where you will see a list of all active collaborations. For each, any user may view the settings and the grid setup. If the collaboration the user wishes to join is public, they can click on Registry and Scoreboard . On this page, each market and asset of the collaboration is listed. The user can apply to manage the trading strategies of assets or the grid fee strategy of markets on the Registry. The EO is able to either approve or deny the request. Once approved, the user can start the API script and wait until the EO starts the collaboration / canary network, when trading will begin.","title":"How to connect"},{"location":"constant-fees/","text":"The constant grid fee is a market based fee, defined in \u20ac/kWh and added to each trade that is cleared, as shown in the figure below. The rate of a bid or offer changes as that bid or offer is propagated into different markets . The offer rate increases to account for the added fees for the relevant market, ensuring that the seller receives a revenue equal or greater than the original offer. The bid rate decreases for the same reason. Example Calculation in One-Sided Pay-as-Offer Market \u00b6 In an One-Sided Pay-as-Offer market, there are no bids, only offers. Offers are propagated throughout the markets in the hierarchy shown in the figure above. Grid fees are accounted for when an offer is forwarded to the higher market, adding that market\u2019s grid fees to any previously accumulated fees. The formula to calculate the new offer rate when placing an offer to a higher market is the following: offer_rate_after_fees (\u20ac/kWh) = offer_rate (\u20ac/kWh) + grid_fee (\u20ac/kWh) If the offer is not purchased after two ticks , it is moved into the next market, with the total rate incremented by the amount of that market's grid fee. In the example above, the PV offer of 0.10 \u20ac/kWh is first placed into the House 2 Market where it gains zero fees. Then it moves into the Neighborhood 2 Market, gaining a fee of 0.01 \u20ac/kWh to become 0.11 \u20ac/kWh. Then, if not purchased, it moves into the Grid Market, gaining a fee of 0.02 \u20ac/kWh to become 0.13 \u20ac/kWh. Continuing into the Neighborhood 1 Market, the offer gains a fee of 0.01 \u20ac/kWh to become 0.14 \u20ac/kWh. Continuing into the House 1 Market, the offer gains zero fees. The Load ultimately buys the offer in the House 1 Market at the Clearing Rate of 0.14 \u20ac/kWh. The trade price is calculated by adding the original offer rate ( 0.10 \u20ac/kWh ) and the total fees ( (0.01+0.02+0.01) = 0.04 \u20ac/kWh ), then multiplying by the amount of energy traded ( 1 kWh ) to yield the Trade Price of 0.14\u20ac. The Load pays the Trade Price of 0.14\u20ac, which includes 0.10\u20ac revenue for the PV, 0.01\u20ac fees for the Neighborhood Market 1, 0.02\u20ac fees for the Grid Market, and 0.01\u20ac fees for the Neighborhood Market 2. Since the market type is pay-as-offer, the offer rate is used as the clearing rate. The grid fees are added to the offer rate to determine the trade rate and therefore the trade price in each market. The following formula is used: supply_side_fee (\u20ac/kWh) = forwarded_offer_rate (\u20ac/kWh) - original_offer_rate (\u20ac/kWh) trade_rate (\u20ac/kWh) = clearing rate (\u20ac/kWh) trade_price (\u20ac) = energy (kWh) * trade_rate (\u20ac/kWh) For the provided example, the trade price for each market is: Market_trade_price (\u20ac) = (original_offer_rate (\u20ac/kWh) + supply_side_fee (\u20ac/kWh)) * energy (kWh) Grid Market = (0.10 + 0.03)*1 = 0.13 Neighborhood 2 Market = (0.10 + 0.01)*1 = 0.11 Neighborhood 1 Market = (0.10 + 0.04)*1 = 0.14 House 1 Market = (0.10 + 0.04)*1 = 0.14 House 2 Market = (0.10 + 0)*1 = 0.10 Example Calculation in Two-Sided Pay-as-Bid Market \u00b6 In the Two-Sided Pay-as-Bid market, there are both bids and offers, and both are propagated through the markets in the hierarchy. If a bid or offer is not matched after two ticks , it is moved into the next market. In order to prevent the double accounting of a market's grid fee when a bid and an offer are matched in that market, market fees are added to offers when they enter a new market (target market), and they are subtracted from bids when they leave a market (source market) and enter another one. The formula for propagating the offers is the same as for the one-sided market : offer_rate_after_fees (\u20ac/kWh) = offer_rate (\u20ac/kWh) + grid_fee (\u20ac/kWh) The IAA subtracts the fees from the bid before propagating the bid to the higher market, based on the following formula: bid_rate_after_fees (\u20ac/kWh) = bid_rate (\u20ac/kWh) - grid_fee (\u20ac/kWh) In the case of a Two-Sided Pay-as-Bid market, the offer is moved into the Grid Market by the same mechanism as in the One-Sided Pay-as-Offer market. The bid of 0.30 \u20ac/kWh is placed into the House 1 Market where there are zero fees. If it is not purchased after two ticks, it is moved into the Neighborhood 1 Market. As explained above, only the fees from the source market are added, which are zero in this case. Hence the bid rate remains 0.30 \u20ac/kWh. Next, the bid is moved into the Grid Market, where its value is reduced by the amount of the fees of its source market, the Neighborhood 1 Market at 0.01 \u20ac/kWh, resulting in a rate of 0.29 \u20ac/kWh as it enters the Grid Market. In the example above, the bid and offer are matched in the Grid Market. When the offer entered the Grid Market, its rate was immediately updated to account for the Grid Market fees (0.11 + 0.02). The bid was not updated, and if it was not matched in the Grid Market and moved to the Neighborhood 2 Market, the 0.02 \u20ac/kWh fee from the Grid Market would be subtracted to become (0.29 - 0.02) 0.27 \u20ac/kWh. The fees from the Neighborhood 2 Market would not be added to the bid unless it entered the House 2 Market (fees added according to the source market). In the Grid Market, the Load bid rate is listed as 0.29 \u20ac/kWh and the PV offer as 0.13 \u20ac/kWh. As the bid\u2019s rate is greater than the offer\u2019s rate, a trade can be scheduled. The trade clears at the bid\u2019s rate, resulting in a Clearing Rate of 0.29 \u20ac/kWh. The Grid Singularity energy exchange engine includes an algorithm that calculates the grid fee according to the clearing rate, basing the calculation on the original bid and offer rates. This allows the markets to act more independently and in a decentralized manner, without having to share information regarding their fees with other markets. The algorithm formula is as follows: demand_side_fee (\u20ac/kWh) = original_bid_rate (\u20ac/kWh) - forwarded_bid_rate (\u20ac/kWh) supply_side_fee (\u20ac/kWh) = forwarded_offer_rate (\u20ac/kWh) - original_offer_rate (\u20ac/kWh) For the example, we have the following values: supply_side_fee = 0.13 - 0.10 = 0.03 \u20ac/kWh demand_side_fee = 0.30 - 0.29 = 0.01 \u20ac/kWh After calculating the supply and demand side fee, the trade revenue can be calculated. Note the original_trade_rate is the amount that the original buyer (in our case the Load) will need to pay, therefore in the Pay-as-Bid market type this is the original bid price. The formula is the following: total_fee (\u20ac/kWh) = supply_side_fee (\u20ac/kWh) + demand_side_fee (\u20ac/kWh) revenue_rate (\u20ac/kWh) = original_trade_rate (\u20ac/kWh) - total_fee (\u20ac/kWh) For the example, the revenue will be: revenue = 0.30 - 0.04 = 0.26 \u20ac/kWh Finally, the trade rate is adapted according to the supply side fee, in order to include the fees of the current market: trade_rate (\u20ac/kWh) = revenue_rate (\u20ac/kWh) + supply_side_fee (\u20ac/kWh) trade_price (\u20ac) = energy (kWh) * trade_rate (\u20ac/kWh) For our example, the trade price for each market is: Market_trade_price (\u20ac) = (revenue_rate (\u20ac/kWh) + supply_side_fee (\u20ac/kWh)) * energy (kWh) Grid Market = (0.26 + 0.03)*1 = 0.29, Neighborhood 2 Market = (0.26 + 0.01)*1 = 0.27, Neighborhood 1 Market = (0.26 + 0.04)*1 = 0.30, House 1 Market = (0.26 + 0.04)*1 = 0.30, House 2 Market = (0.26 + 0)*1 = 0.26. The Load pays the Trade Price of 0.30\u20ac, which includes 0.26\u20ac revenue for the PV, 0.01\u20ac fees for Neighborhood Market 1, 0.02\u20ac fees for the Grid Market, and 0.01\u20ac fees for the Neighborhood Market 2. Example Calculation in Two-Sided Pay-as-Clear Market \u00b6 This market clearing type is currently in development. We welcome your suggestions on its design!","title":"Constant Grid Fee Calculation"},{"location":"constant-fees/#example-calculation-in-one-sided-pay-as-offer-market","text":"In an One-Sided Pay-as-Offer market, there are no bids, only offers. Offers are propagated throughout the markets in the hierarchy shown in the figure above. Grid fees are accounted for when an offer is forwarded to the higher market, adding that market\u2019s grid fees to any previously accumulated fees. The formula to calculate the new offer rate when placing an offer to a higher market is the following: offer_rate_after_fees (\u20ac/kWh) = offer_rate (\u20ac/kWh) + grid_fee (\u20ac/kWh) If the offer is not purchased after two ticks , it is moved into the next market, with the total rate incremented by the amount of that market's grid fee. In the example above, the PV offer of 0.10 \u20ac/kWh is first placed into the House 2 Market where it gains zero fees. Then it moves into the Neighborhood 2 Market, gaining a fee of 0.01 \u20ac/kWh to become 0.11 \u20ac/kWh. Then, if not purchased, it moves into the Grid Market, gaining a fee of 0.02 \u20ac/kWh to become 0.13 \u20ac/kWh. Continuing into the Neighborhood 1 Market, the offer gains a fee of 0.01 \u20ac/kWh to become 0.14 \u20ac/kWh. Continuing into the House 1 Market, the offer gains zero fees. The Load ultimately buys the offer in the House 1 Market at the Clearing Rate of 0.14 \u20ac/kWh. The trade price is calculated by adding the original offer rate ( 0.10 \u20ac/kWh ) and the total fees ( (0.01+0.02+0.01) = 0.04 \u20ac/kWh ), then multiplying by the amount of energy traded ( 1 kWh ) to yield the Trade Price of 0.14\u20ac. The Load pays the Trade Price of 0.14\u20ac, which includes 0.10\u20ac revenue for the PV, 0.01\u20ac fees for the Neighborhood Market 1, 0.02\u20ac fees for the Grid Market, and 0.01\u20ac fees for the Neighborhood Market 2. Since the market type is pay-as-offer, the offer rate is used as the clearing rate. The grid fees are added to the offer rate to determine the trade rate and therefore the trade price in each market. The following formula is used: supply_side_fee (\u20ac/kWh) = forwarded_offer_rate (\u20ac/kWh) - original_offer_rate (\u20ac/kWh) trade_rate (\u20ac/kWh) = clearing rate (\u20ac/kWh) trade_price (\u20ac) = energy (kWh) * trade_rate (\u20ac/kWh) For the provided example, the trade price for each market is: Market_trade_price (\u20ac) = (original_offer_rate (\u20ac/kWh) + supply_side_fee (\u20ac/kWh)) * energy (kWh) Grid Market = (0.10 + 0.03)*1 = 0.13 Neighborhood 2 Market = (0.10 + 0.01)*1 = 0.11 Neighborhood 1 Market = (0.10 + 0.04)*1 = 0.14 House 1 Market = (0.10 + 0.04)*1 = 0.14 House 2 Market = (0.10 + 0)*1 = 0.10","title":"Example Calculation in One-Sided Pay-as-Offer Market"},{"location":"constant-fees/#example-calculation-in-two-sided-pay-as-bid-market","text":"In the Two-Sided Pay-as-Bid market, there are both bids and offers, and both are propagated through the markets in the hierarchy. If a bid or offer is not matched after two ticks , it is moved into the next market. In order to prevent the double accounting of a market's grid fee when a bid and an offer are matched in that market, market fees are added to offers when they enter a new market (target market), and they are subtracted from bids when they leave a market (source market) and enter another one. The formula for propagating the offers is the same as for the one-sided market : offer_rate_after_fees (\u20ac/kWh) = offer_rate (\u20ac/kWh) + grid_fee (\u20ac/kWh) The IAA subtracts the fees from the bid before propagating the bid to the higher market, based on the following formula: bid_rate_after_fees (\u20ac/kWh) = bid_rate (\u20ac/kWh) - grid_fee (\u20ac/kWh) In the case of a Two-Sided Pay-as-Bid market, the offer is moved into the Grid Market by the same mechanism as in the One-Sided Pay-as-Offer market. The bid of 0.30 \u20ac/kWh is placed into the House 1 Market where there are zero fees. If it is not purchased after two ticks, it is moved into the Neighborhood 1 Market. As explained above, only the fees from the source market are added, which are zero in this case. Hence the bid rate remains 0.30 \u20ac/kWh. Next, the bid is moved into the Grid Market, where its value is reduced by the amount of the fees of its source market, the Neighborhood 1 Market at 0.01 \u20ac/kWh, resulting in a rate of 0.29 \u20ac/kWh as it enters the Grid Market. In the example above, the bid and offer are matched in the Grid Market. When the offer entered the Grid Market, its rate was immediately updated to account for the Grid Market fees (0.11 + 0.02). The bid was not updated, and if it was not matched in the Grid Market and moved to the Neighborhood 2 Market, the 0.02 \u20ac/kWh fee from the Grid Market would be subtracted to become (0.29 - 0.02) 0.27 \u20ac/kWh. The fees from the Neighborhood 2 Market would not be added to the bid unless it entered the House 2 Market (fees added according to the source market). In the Grid Market, the Load bid rate is listed as 0.29 \u20ac/kWh and the PV offer as 0.13 \u20ac/kWh. As the bid\u2019s rate is greater than the offer\u2019s rate, a trade can be scheduled. The trade clears at the bid\u2019s rate, resulting in a Clearing Rate of 0.29 \u20ac/kWh. The Grid Singularity energy exchange engine includes an algorithm that calculates the grid fee according to the clearing rate, basing the calculation on the original bid and offer rates. This allows the markets to act more independently and in a decentralized manner, without having to share information regarding their fees with other markets. The algorithm formula is as follows: demand_side_fee (\u20ac/kWh) = original_bid_rate (\u20ac/kWh) - forwarded_bid_rate (\u20ac/kWh) supply_side_fee (\u20ac/kWh) = forwarded_offer_rate (\u20ac/kWh) - original_offer_rate (\u20ac/kWh) For the example, we have the following values: supply_side_fee = 0.13 - 0.10 = 0.03 \u20ac/kWh demand_side_fee = 0.30 - 0.29 = 0.01 \u20ac/kWh After calculating the supply and demand side fee, the trade revenue can be calculated. Note the original_trade_rate is the amount that the original buyer (in our case the Load) will need to pay, therefore in the Pay-as-Bid market type this is the original bid price. The formula is the following: total_fee (\u20ac/kWh) = supply_side_fee (\u20ac/kWh) + demand_side_fee (\u20ac/kWh) revenue_rate (\u20ac/kWh) = original_trade_rate (\u20ac/kWh) - total_fee (\u20ac/kWh) For the example, the revenue will be: revenue = 0.30 - 0.04 = 0.26 \u20ac/kWh Finally, the trade rate is adapted according to the supply side fee, in order to include the fees of the current market: trade_rate (\u20ac/kWh) = revenue_rate (\u20ac/kWh) + supply_side_fee (\u20ac/kWh) trade_price (\u20ac) = energy (kWh) * trade_rate (\u20ac/kWh) For our example, the trade price for each market is: Market_trade_price (\u20ac) = (revenue_rate (\u20ac/kWh) + supply_side_fee (\u20ac/kWh)) * energy (kWh) Grid Market = (0.26 + 0.03)*1 = 0.29, Neighborhood 2 Market = (0.26 + 0.01)*1 = 0.27, Neighborhood 1 Market = (0.26 + 0.04)*1 = 0.30, House 1 Market = (0.26 + 0.04)*1 = 0.30, House 2 Market = (0.26 + 0)*1 = 0.26. The Load pays the Trade Price of 0.30\u20ac, which includes 0.26\u20ac revenue for the PV, 0.01\u20ac fees for Neighborhood Market 1, 0.02\u20ac fees for the Grid Market, and 0.01\u20ac fees for the Neighborhood Market 2.","title":"Example Calculation in Two-Sided Pay-as-Bid Market"},{"location":"constant-fees/#example-calculation-in-two-sided-pay-as-clear-market","text":"This market clearing type is currently in development. We welcome your suggestions on its design!","title":"Example Calculation in Two-Sided Pay-as-Clear Market"},{"location":"d3a-documentation/","text":"The commitment made to the energy transition by an increasing number of governments resulted in numerous incentive schemes, spurring growth in renewable power capacity in the European Union and globally . In 2019, the production of wind and solar energy was higher than energy produced with coal in Germany for the first time . This positive trend, however, also created a challenge in that the installed capacity of renewable energy outgrew the capacity of the distribution grid , impeding the grid operators to effectively transmit the energy to the final consumer . As a result, they have called for innovative tools to enable, \u201cmarket-based activation of explicit flexibilities that are able to alter power flows\" . Energy asset owners, from individual households to communities, could also use such tools for more optimal energy consumption, while contributing to wider market flexibility. If equipped with a decision-making agency, the distributed energy resources would become the medium to solve the challenge they have inadvertently created, while further enhancing the system's sustainability. A bottom-up, community energy model could transform our energy system to be more democratic, sustainable and stable. The European Union has recently laid the legal foundations for this reconstruction and other regulators are also supporting this market transformation.","title":"Energy Market Design Challenge"},{"location":"data-download/","text":"After successfully running a simulation in Grid Singularity\u2019s User Interface (d3a.io), the user can download the results file for a deeper analysis. The downloaded folder is organised into two subfolders with relevant files, as follows: Aggregated_results : area_throughput.json : Imported/exported energy for each market slot : Bills.json : Energy bills of all markets and energy assets (more details here ) Cumulative_bills.json : Total energy bills (spent & earned) Cumulative_grid_trades.json : Total energy traded for each market and energy asset and their penalty (for not trading their required energy) asset_statistics.json : asset profiles, energy traded, energy rates (min and max) for each asset each market slot Energy_trade_profile.json : Energy traded in each market Kpi.json : Self-consumption and self-sufficiency (in %), total energy demanded, generated and self-consumed Price_energy_day.json : Min, avg, max and grid fee rates for each market each market slot Progress_info.json : time remaining, simulation duration and percentage completed (if the simulation is complete eta_seconds should report 0 and percentage_completed should report 100) Random_seed.json : Random seed number used in the randomization process for specific events. This can mean the same simulation run multiple times may have slightly different results, as the posting order of bids and offers and matching trades can differ in certain situations (such as when two bids for the same price are randomly selected to be matched with one offer), causing some trades and bills to be different. Simulation_id.json : UUID of the simulation (can also be found in the simulation URL) Status.json : Status of the simulation Unmatched_loads.json : Number of unmatched load per markets reported each market slot bids_offers_trades : The folder structure follows the same logic as the simulation\u2019s grid hierarchy. There are three different csv files : *_bids.csv : Lists every bid posted on the relevant market including their volume, rate and buyer\u2019s name *_offers.csv : Lists every offer posted on the relevant market including their volume, rate and seller\u2019s name *_trades.csv : Lists each traded including their volume, rate, buyer\u2019s and seller\u2019s name","title":"Data Download"},{"location":"default-trading-strategy/","text":"Grid Singularity\u2019s exchange engine (D3A) has a built-in template trading agent. The agent\u2019s trading strategy is deterministic . Each consumer asset will first try to buy energy at a low price and, if not cleared, the price will increase linearly during the market slot until a user-defined maximum is reached. In turn, assets generating energy will try to sell at a high price first and, if not cleared, reduce their rate linearly until a user-set minimum is reached. Offers\u2019 trading settings are as follows: initial_selling_rate final_selling_rate update_interval energy_rate_decrease_per_update fit_to_limit The following plot shows the changing energy rate in a spot market slot (slot_length = 15min) for four different trading settings. If fit_to_limit is set to True , energy_rate_decrease_per_update is ignored and a rate decrease per time is calculated, starting at initial_selling_rate and ending at final_selling_rate while updating the rate at each update_interval . Bids\u2019 Trading settings: initial_buying_rate final_buying_rate update_interval energy_rate_increase_per_update fit_to_limit The following plot shows the energy rate change in a spot market slot (slot_length = 15min) for different trading settings. If fit_to_limit is set to True , energy_rate_increase_per_update is ignored and a rate increase per time is calculated that starts at initial_buying_rate and ends at final_buying_rate while updating the rate at each update_interval . Assets can also deploy more intelligent trading strategies, as demonstrated in the 2020 Energy Singularity Challenge, described in the following two articles: Grid Singularity. (September 10, 2020). En Route to Energy Singularity Odyssey Momentum: Learnings from the 2020 Chaos Experiment Grid Singularity. (November 25, 2020). Energy Singularity Challenge 2020: Social Energy Networks Information on how to set up and train intelligent trading strategies through the Grid Singularity Asset API is available here .","title":"Trading Strategies"},{"location":"energy-bills/","text":"The cumulative energy bills for each market and energy asset are reported on the UI Results page and in a JSON file bills.json for a backend simulation. The bills are reported as the cash flow through each market. For a visual example, the following configuration will be used: This configuration is simulated for one day using the Pay-as-Bid market type and the load bidding to buy energy at 12:00, leading to the propagation of the load bid and the grid operator offer until they are matched as shown in the figure below: The bid and the offer are forwarded to the higher-level Grid market and are matched in this market with a clearing price (and trade price) of 0.45 \u20ac. For more information on how grid fees are calculated, please read the grid fees documentation ). In the bills.json file, the cash flow in each market is reported as follows: \"Parent market\" : { \"Agent\" : { \"bought\" : E ner gy t ha t has bee n bough t duri n g t he simula t io n [ kWh ], \"sold\" : E ner gy t ha t has bee n sold duri n g t he simula t io n [ kWh ], \"spent\" : Amou nt o f mo ne y t ha t has bee n spe nt i n tra des duri n g t he simula t io n [ \u20ac ] , \"earned\" : Amou nt o f mo ne y t ha t has bee n ear ne d i n tra des duri n g t he simula t io n [ \u20ac ], \"total_energy\" : e ner gy bough t - e ner gy sold [ kWh ], \"total_cost\" : mo ne y spe nt i n tra des - mo ne y ear ne d i n tra des [ \u20ac ], \"market_fee\" : Mo ne y spe nt i n t he \"Parent area\" as grid fees [ \u20ac ] , \"type\" : Type o f age nt . Ca n ei t her be a marke t or t he na me o f t he asse t s trate gy }, }, Shown below are the results of the previous example. The first set of results is from the highest market, in this case the Grid market : In the Grid market, House 1 has bought 1 kWh from the DSO and spent 0.375\u20ac in this trade. House 1 also pays the 0.075\u20ac grid fee that the Grid market is charging. The total cost of 1 kWh of energy is 0.375 + 0.075 = 0.45\u20ac One level down the hierarchy, the House 1 market is displayed in the figure below: The House 1 market has no information on the other markets\u2019 grid fees, so only considers its own fees in the bills table. Therefore, the Load spends 0.45\u20ac (0.0375+0.075) for 1 kWh of energy coming outside of House 1, with no grid fee added since House 1 has no fees. Finally, the bills of each energy asset is shown : The Load has bought 1 kWh of energy for 0.45\u20ac. Since 0.075\u20ac was paid as fees to the Grid market, the DSO received the remaining 0.375\u20ac for 1 kWh.","title":"Energy Bill"},{"location":"events/","text":"The user has the ability to modify the modelling setup while the simulated network is running. These modifications are termed events . To create an event the user can either go to the Modelling page and make a change while the simulation is running or pause the simulation beforehand (by clicking pause on the Results page ), resuming once changes are implemented. Possible events are : Add or delete markets and energy assets Change parameters of energy assets (with the exception of their names and the Market Maker ) Change market configuration settings (except names) Events in Simulations run using the User Interface \u00b6 Once an event is set, the user can track it on the timeline displayed at the top of the simulation. If the user clicks on the event on the Modelling page, the grid setup at that specific time is viewed. If the user clicks on an event in the Results page, the results of the specific markets and energy assets are viewed. whenever a market or energy asset was added whenever a market or energy asset parameter was modified whenever a market or energy asset was removed whenever multiple events have been executed at the same time Events in Simulations run using the Backend \u00b6 In a backend simulation, events need to be defined by the user in the setup files before the start of the simulation, and they are associated with a specific point in time (or duration), at which the event is triggered. An event has to be associated with a market by using the event_list constructor parameter for that market. There are four different event types, described in further detail below: Add/Remove Market Events Connect/Disconnect Market Events Strategy Events Configuration Events Add/Remove Market Events \u00b6 This event is associated with a market, and dictates that this market (and its submarkets and assets) will be added or removed from the grid at a specific point in time. There are two ways to configure this operation, either via individual events ( EnableMarketEvent and DisableMarketEvent ) or by disabling this market for a time interval ( DisableIntervalMarketEvent ). EnableMarketEvent / DisableMarketEvent commands each accept one argument, which is the hour at which this event is triggered (hourly resolution is supported in the current implementation), and this area will be enabled/disabled at this specific point in time no matter its current state. DisableIntervalMarketEvent accepts two arguments, denoting the start hour and the end hour at which the Market is disabled. The term disabled market means that the relevant markets and submarkets are not performing any trading, and are hence inactive in the simulation for the time that the market is disabled. Once enabled, the relevant market and its submarkets will start to operate. Examples for these events are available on the Grid Singularity GitHub: EnableMarketEvent: isolated_enable_event.py DisableMarketEvent: isolated_disable_event.py DisableIntervalMarketEvent: disable_interval_event.py Connect/Disconnect Market Events \u00b6 These events are similar to the enable/disable event; both have a similar API and both are used for removing a market from the grid. The difference is that the Connect/Disconnect events are decoupling the relevant submarkets and assets from the main grid. When the event is enabled, there will be two independent grids trading energy internally, but not with each other. This is contrary to enable/disable events, where the subtree is not performing any trades. This can simulate grids that are abruptly decoupled from the main grid, but manage to self-sustain their assets by continuing to trade energy even after they are disconnected from the main grid. You can find examples for these events on Grid Singularity GitHub: ConnectMarketEvent: isolated_connect_event.py DisconnectMarketEvent: isolated_disconnect_event.py DisconnectIntervalMarketEvent: disconnect_interval_event.py Strategy Events \u00b6 These events are used to change an asset\u2019s trading strategy during the simulation runtime. These are distinct events with no interval event provided. Load StrategyEvent: load_event.py PV StrategyEvent: pv_event.py Storage StrategyEvent: storage_event.py Configuration Events \u00b6 These events are used to change the market configuration (including submarkets and assets) during runtime. A useful application for this event is to set different weather conditions for a subset of the grid. Configuration events are distinct and no interval event is provided. There are currently two configuration events: Cloud Coverage Event: cloud_coverage_event.py PV User Profile Event : userprofile_pv_event.py","title":"Events (adding assets, communities, etc.)"},{"location":"events/#events-in-simulations-run-using-the-user-interface","text":"Once an event is set, the user can track it on the timeline displayed at the top of the simulation. If the user clicks on the event on the Modelling page, the grid setup at that specific time is viewed. If the user clicks on an event in the Results page, the results of the specific markets and energy assets are viewed. whenever a market or energy asset was added whenever a market or energy asset parameter was modified whenever a market or energy asset was removed whenever multiple events have been executed at the same time","title":"Events in Simulations run using the User Interface"},{"location":"events/#events-in-simulations-run-using-the-backend","text":"In a backend simulation, events need to be defined by the user in the setup files before the start of the simulation, and they are associated with a specific point in time (or duration), at which the event is triggered. An event has to be associated with a market by using the event_list constructor parameter for that market. There are four different event types, described in further detail below: Add/Remove Market Events Connect/Disconnect Market Events Strategy Events Configuration Events","title":"Events in Simulations run using the Backend"},{"location":"events/#addremove-market-events","text":"This event is associated with a market, and dictates that this market (and its submarkets and assets) will be added or removed from the grid at a specific point in time. There are two ways to configure this operation, either via individual events ( EnableMarketEvent and DisableMarketEvent ) or by disabling this market for a time interval ( DisableIntervalMarketEvent ). EnableMarketEvent / DisableMarketEvent commands each accept one argument, which is the hour at which this event is triggered (hourly resolution is supported in the current implementation), and this area will be enabled/disabled at this specific point in time no matter its current state. DisableIntervalMarketEvent accepts two arguments, denoting the start hour and the end hour at which the Market is disabled. The term disabled market means that the relevant markets and submarkets are not performing any trading, and are hence inactive in the simulation for the time that the market is disabled. Once enabled, the relevant market and its submarkets will start to operate. Examples for these events are available on the Grid Singularity GitHub: EnableMarketEvent: isolated_enable_event.py DisableMarketEvent: isolated_disable_event.py DisableIntervalMarketEvent: disable_interval_event.py","title":"Add/Remove Market Events"},{"location":"events/#connectdisconnect-market-events","text":"These events are similar to the enable/disable event; both have a similar API and both are used for removing a market from the grid. The difference is that the Connect/Disconnect events are decoupling the relevant submarkets and assets from the main grid. When the event is enabled, there will be two independent grids trading energy internally, but not with each other. This is contrary to enable/disable events, where the subtree is not performing any trades. This can simulate grids that are abruptly decoupled from the main grid, but manage to self-sustain their assets by continuing to trade energy even after they are disconnected from the main grid. You can find examples for these events on Grid Singularity GitHub: ConnectMarketEvent: isolated_connect_event.py DisconnectMarketEvent: isolated_disconnect_event.py DisconnectIntervalMarketEvent: disconnect_interval_event.py","title":"Connect/Disconnect Market Events"},{"location":"events/#strategy-events","text":"These events are used to change an asset\u2019s trading strategy during the simulation runtime. These are distinct events with no interval event provided. Load StrategyEvent: load_event.py PV StrategyEvent: pv_event.py Storage StrategyEvent: storage_event.py","title":"Strategy Events"},{"location":"events/#configuration-events","text":"These events are used to change the market configuration (including submarkets and assets) during runtime. A useful application for this event is to set different weather conditions for a subset of the grid. Configuration events are distinct and no interval event is provided. There are currently two configuration events: Cloud Coverage Event: cloud_coverage_event.py PV User Profile Event : userprofile_pv_event.py","title":"Configuration Events"},{"location":"faq-odyssey/","text":"This is a frequently asked questions (faq) specifically designed for the hackathon Odyssey 2020, in which we are producing 2 of the challenges. Stream 1: Trading Bots, KPIs, API \u00b6 What is the D3A ? \u00b6 The D3A is an open source software that enables users to model, simulate, optimise, download, and deploy energy exchanges. The D3A is designed to build \u201cdigital twin\u201d representations of physical energy systems and energy markets. It aims to build open energy exchanges, extending access for new energy players, a class which is growing due to increased investments in distributed energy resources and smart devices. By creating energy exchanges from bottom to top, smart, local, and flexible devices as well as distributed renewable generation can be monetised for a faster transition to 100% renewable energy. How are D3A market organised ? \u00b6 The electricity grid is organized into a hierarchy of energy marketplaces. Markets are organized according to grid voltage levels. Energy assets buy and sell into a House Market. Houses buy and sell into Community Markets. Communities buy and sell into a Grid Market. Each energy asset consumes, produces, or stores energy and trades in its local energy market first. If unsuccessful, the bid or offer is propagated to a higher market in the hierarchy. Energy assets, Houses, and Communities might optimise their bids and offers for a specific metric , such as minimising energy bill or maximising self-sufficiency. What is the Goal of Energy Singularity Challenge Stream 1? \u00b6 Stream 1 of the Energy Singularity challenge aims to optimize the trading strategies of individual devices with the goal of optimising key performance indicators (KPIs) such as a household\u2019s energy bill and a community\u2019s self-sufficiency. Teams will design and manage trading strategies of individual assets within houses or communities through an API. Each team will manage the assets of one or many homes in a community, depending on the challenge round. They will be judged on KPIs such as energy bill or energy self-sufficiency, but also on their approach and viability of their agent\u2019s \u2018deployability\u2019. Grid operators can adjust grid tariffs and transmission capacities in real-time, and utilities can compete in the market, offering energy from power plants at a competitive rate (these roles will be performed by challenge partners). What are energy assets and how are they represented? \u00b6 There are five types of energy assets modeled. Four are home energy assets. Loads have a variable energy demand (kWh) that must be purchased within each market slot PVs have variable energy generation that can be sold within each market slot Batteries can buy or sell energy, within a min and max state of charge Flexible Loads can buy flexibly by storing energy to use later, but must cover their base load over time The fifth is controlled by an agent representing a utility: Power Plants produce energy at a market maker rate (e.g. 30 cents per kWh) and act as \u2018infinite\u2019 producers Energy required to be purchased (Loads), energy available to be sold (PVs), and state of charge and available rate of charge / discharge (Batteries and Flexible Loads) will be provided through the API each market slot. What market mechanisms will be used in the Hackathon ? \u00b6 Without a peer to peer energy market, devices that consume energy would always buy energy at the market rate of 30 cents per kWh from the utility. PVs would sell excess energy to the utility at a feed-in tariff rate, such as 10 cents / kWh. In a peer to peer market, a PV would be able to sell energy to a nearby load instead of selling it to the grid. For example, the PV may offer to sell its excess energy at 25 cents / kWh to the load, 15 cents higher than the feed-in tariff. The load would likely be willing to buy this energy, as the cost is 5 cents lower than the 30 cent market rate from the utility, a benefit for both the PV and load. The exact value of the rate which the PV would sell to the load is optimally a function of energy supply and demand and is likely to decrease during times when there is more solar production than required load. Agents will try to predict this optimal price and arbitrage the energy market with their trading strategies. Markets are broken into 15 minute slots. Within each slot, an energy asset is able to post bids or offers for energy. These bids or offers are matched based on the market type. The two sided market Pay-as-Bid market type will be used for the hackathon, where bids are matched with the highest price offer where bid price >= offer price. If all remaining bid prices are less than all offer prices, the energy on bid / offer remains unmatched. Any energy not bought or sold at the end of the market slot vs. energy requirements of the assets will be penalised. Each market slot is broken into many ticks. When a bid or offer is posted, it is first attempted to be matched in its local energy market. If it remains unmatched at the end of one tick, it is propagated to a higher market. Bids or offers that match are immediately cleared in all markets, and bids and offers that are canceled are immediately canceled in all markets. The duration simulated for each round will be 1 week and each market slot will be 15 minutes of simulated time. Simulations will be accelerated and each market slot will only take a few seconds in \u201creal life\u201d. A walk-through of one market slot is depicted below. For more information on the market and its component, please visit these wiki pages : Overview Pay-as-Bid Inter-Area Agent Market slot and ticks What is a trading strategy and how do I optimise it ? \u00b6 Each energy asset is represented by a digital twin agent. The agent makes decisions to buy or sell energy at specific prices based on the energy requirements of the device. For example, a solar panel that produces 0.15 kWh of energy may request to SELL 0.15 kWh at 26 cents / kWh. Loads must buy a certain amount of energy. PVs must sell the amount of energy they produce. Batteries may buy or sell energy within a min and max state of charge. Each team will manage multiple energy assets. The goal is to optimize the trading strategy for a specific metric (that can either be the energy bills or the self-sufficiency of an area) by defining the price [\u20ac/kWh] and the volume [kWh] of your bids/offers. If you are controlling storage there is also the factor of time that comes into consideration (when to buy or sell) when optimizing, as illustrated in the figure below. Furthermore, since the market is continuous, you are also able to update your bids/offers during the market slot in order to increase your chance of being matched. What data is available to train my trading bot ? \u00b6 Data can be gathered in two ways, by: Gathering and locally storing the information passed to the agent through the API during simulations Processing the data outputs of simulations (exported to the d3a-simulation folder after each simulation) The information passed through the API is what will be available to be used in collaborative simulations such as at the hackathon. It is recommended your agents be trained on this data. Data includes past market data (min, max, avg, and median prices), amount of energy traded, trading events, and power curves. Exact data structures are available in the API documentation . What are penalties and how are they avoided? \u00b6 Penalties are incurred if the power curve of a device is not exactly met. The penalty for any energy withstanding is currently set to the market maker rate + 10%, but is subject to change. For example if a load is required to buy 1 kWh but only buys 0.8 kWh, the remaining 0.2 kWh will be penalised at the market maker rate + 10%. The same is true if a PV generates 1 kWh but only sells 0.8 kWh. This is to penalise unaccounted for power flow that could be detrimental to the physical grid. What is a Grid Fee ? \u00b6 A grid fee is a percentage of trade price or a constant value that is paid to the market for using the electrical grid. Simulation and API Setup \u00b6 How do I create a simulation and train and test my trading bot ? \u00b6 You will train your agent locally on the backend code, and will interact with the frontend at d3a.io during the hackathon. Review this document describing how to install and interact with simulations via the API , which discusses connecting to the backend and to d3a.io. To run simulations on our frontend at d3a.io, follow the steps on our wiki to create and run simulations on d3a.io . Technical information \u00b6 Please note that this information is subject to change as the challenge details are refined. How many days are in each simulation ? \u00b6 It is likely that each simulation will represent 7 real time days. How much time does a market slot take ? \u00b6 Each market slot represents 15 simulation time minutes which is 5-10 real time seconds. The exact simulation slowdown factor will be shared when decided upon. How many ticks are in a market slot ? \u00b6 In each market slot there will be 60-90 ticks. The on_tick(self, tick_info) function will be triggered every incremental 10% of the market slot, e.g. on tick 6, 12, 18, etc. if there are 60 ticks. This means you\u2019ll easily be able to make bid and offer decisions / updates 9 times per slot. How many API calls can I make per market slot ? \u00b6 Each device may have up to 5 active bids and 5 active offers at any point in time. There will be a realistic limit on the number of API calls, such as 1000 per slot, which will not limit your agents and is only intended to limit the probability of a DDOS attack. The exact number is to be determined and will be shared. \u00b6 How many accounts can register for one device ? \u00b6 Multiple accounts can apply for a device but only one will be selected by the simulation\u2019s grid operator, registered to a device and can send API calls. Do I have to run a single strategy for all my devices ? \u00b6 A single script could be used to manage all devices, but it is not obligatory. You can easily run multiple scripts with various strategies on your computer via multiple terminals. Defining Success \u00b6 What criteria will teams be judged on? \u00b6 Winners will not be decided purely on how well their trading algorithm performs relative to other teams. Teams will be judged on a combination of: Algorithm Success : the success of their TradingBot against defined metrics such as energy bill and community self-sufficiency, the goal being specified each challenge round Algorithm Approach : the explanation / documentation of why their algorithm is performing the way it does, and what that means for the devices and communities it represents Challenge Questions : answers or approaches to the challenge questions as defined below. Not all questions must be attempted, especially if you have very well thought out answers to a subset of the questions What are the challenge questions? \u00b6 Requirements for Intelligent Agents in the Real World - What information must be provided to intelligent agents who are trying to optimise the performance of energy devices they represent in the real world? What are some potential issues, such as privacy concerns or hardware limits? What should the flow of information look like? Calculate the Return on Investment of installing an energy asset - Given simulation outcomes, how could the return on investment of energy assets be determined? The intent would be to answer the question, \u201cshould I buy a battery or a solar panel, and what would be the benefit?\u201d. Community Index Design - Design a KPI that could be used to determine the effectiveness index of the way a community is interacting with the energy grid, taking into account energy bill, self-sufficiency, self-consumption, active devices, and other inputs. This index could then be used to judge communities or as an optimisation metric for trading algorithms.","title":"Faq odyssey"},{"location":"faq-odyssey/#stream-1-trading-bots-kpis-api","text":"","title":"Stream 1: Trading Bots, KPIs, API"},{"location":"faq-odyssey/#what-is-the-d3a","text":"The D3A is an open source software that enables users to model, simulate, optimise, download, and deploy energy exchanges. The D3A is designed to build \u201cdigital twin\u201d representations of physical energy systems and energy markets. It aims to build open energy exchanges, extending access for new energy players, a class which is growing due to increased investments in distributed energy resources and smart devices. By creating energy exchanges from bottom to top, smart, local, and flexible devices as well as distributed renewable generation can be monetised for a faster transition to 100% renewable energy.","title":"What is the D3A ?"},{"location":"faq-odyssey/#how-are-d3a-market-organised","text":"The electricity grid is organized into a hierarchy of energy marketplaces. Markets are organized according to grid voltage levels. Energy assets buy and sell into a House Market. Houses buy and sell into Community Markets. Communities buy and sell into a Grid Market. Each energy asset consumes, produces, or stores energy and trades in its local energy market first. If unsuccessful, the bid or offer is propagated to a higher market in the hierarchy. Energy assets, Houses, and Communities might optimise their bids and offers for a specific metric , such as minimising energy bill or maximising self-sufficiency.","title":"How are D3A market organised ?"},{"location":"faq-odyssey/#what-is-the-goal-of-energy-singularity-challenge-stream-1","text":"Stream 1 of the Energy Singularity challenge aims to optimize the trading strategies of individual devices with the goal of optimising key performance indicators (KPIs) such as a household\u2019s energy bill and a community\u2019s self-sufficiency. Teams will design and manage trading strategies of individual assets within houses or communities through an API. Each team will manage the assets of one or many homes in a community, depending on the challenge round. They will be judged on KPIs such as energy bill or energy self-sufficiency, but also on their approach and viability of their agent\u2019s \u2018deployability\u2019. Grid operators can adjust grid tariffs and transmission capacities in real-time, and utilities can compete in the market, offering energy from power plants at a competitive rate (these roles will be performed by challenge partners).","title":"What is the Goal of Energy Singularity Challenge Stream 1?"},{"location":"faq-odyssey/#what-are-energy-assets-and-how-are-they-represented","text":"There are five types of energy assets modeled. Four are home energy assets. Loads have a variable energy demand (kWh) that must be purchased within each market slot PVs have variable energy generation that can be sold within each market slot Batteries can buy or sell energy, within a min and max state of charge Flexible Loads can buy flexibly by storing energy to use later, but must cover their base load over time The fifth is controlled by an agent representing a utility: Power Plants produce energy at a market maker rate (e.g. 30 cents per kWh) and act as \u2018infinite\u2019 producers Energy required to be purchased (Loads), energy available to be sold (PVs), and state of charge and available rate of charge / discharge (Batteries and Flexible Loads) will be provided through the API each market slot.","title":"What are energy assets and how are they represented?"},{"location":"faq-odyssey/#what-market-mechanisms-will-be-used-in-the-hackathon","text":"Without a peer to peer energy market, devices that consume energy would always buy energy at the market rate of 30 cents per kWh from the utility. PVs would sell excess energy to the utility at a feed-in tariff rate, such as 10 cents / kWh. In a peer to peer market, a PV would be able to sell energy to a nearby load instead of selling it to the grid. For example, the PV may offer to sell its excess energy at 25 cents / kWh to the load, 15 cents higher than the feed-in tariff. The load would likely be willing to buy this energy, as the cost is 5 cents lower than the 30 cent market rate from the utility, a benefit for both the PV and load. The exact value of the rate which the PV would sell to the load is optimally a function of energy supply and demand and is likely to decrease during times when there is more solar production than required load. Agents will try to predict this optimal price and arbitrage the energy market with their trading strategies. Markets are broken into 15 minute slots. Within each slot, an energy asset is able to post bids or offers for energy. These bids or offers are matched based on the market type. The two sided market Pay-as-Bid market type will be used for the hackathon, where bids are matched with the highest price offer where bid price >= offer price. If all remaining bid prices are less than all offer prices, the energy on bid / offer remains unmatched. Any energy not bought or sold at the end of the market slot vs. energy requirements of the assets will be penalised. Each market slot is broken into many ticks. When a bid or offer is posted, it is first attempted to be matched in its local energy market. If it remains unmatched at the end of one tick, it is propagated to a higher market. Bids or offers that match are immediately cleared in all markets, and bids and offers that are canceled are immediately canceled in all markets. The duration simulated for each round will be 1 week and each market slot will be 15 minutes of simulated time. Simulations will be accelerated and each market slot will only take a few seconds in \u201creal life\u201d. A walk-through of one market slot is depicted below. For more information on the market and its component, please visit these wiki pages : Overview Pay-as-Bid Inter-Area Agent Market slot and ticks","title":"What market mechanisms will be used in the Hackathon ?"},{"location":"faq-odyssey/#what-is-a-trading-strategy-and-how-do-i-optimise-it","text":"Each energy asset is represented by a digital twin agent. The agent makes decisions to buy or sell energy at specific prices based on the energy requirements of the device. For example, a solar panel that produces 0.15 kWh of energy may request to SELL 0.15 kWh at 26 cents / kWh. Loads must buy a certain amount of energy. PVs must sell the amount of energy they produce. Batteries may buy or sell energy within a min and max state of charge. Each team will manage multiple energy assets. The goal is to optimize the trading strategy for a specific metric (that can either be the energy bills or the self-sufficiency of an area) by defining the price [\u20ac/kWh] and the volume [kWh] of your bids/offers. If you are controlling storage there is also the factor of time that comes into consideration (when to buy or sell) when optimizing, as illustrated in the figure below. Furthermore, since the market is continuous, you are also able to update your bids/offers during the market slot in order to increase your chance of being matched.","title":"What is a trading strategy and how do I optimise it ?"},{"location":"faq-odyssey/#what-data-is-available-to-train-my-trading-bot","text":"Data can be gathered in two ways, by: Gathering and locally storing the information passed to the agent through the API during simulations Processing the data outputs of simulations (exported to the d3a-simulation folder after each simulation) The information passed through the API is what will be available to be used in collaborative simulations such as at the hackathon. It is recommended your agents be trained on this data. Data includes past market data (min, max, avg, and median prices), amount of energy traded, trading events, and power curves. Exact data structures are available in the API documentation .","title":"What data is available to train my trading bot ?"},{"location":"faq-odyssey/#what-are-penalties-and-how-are-they-avoided","text":"Penalties are incurred if the power curve of a device is not exactly met. The penalty for any energy withstanding is currently set to the market maker rate + 10%, but is subject to change. For example if a load is required to buy 1 kWh but only buys 0.8 kWh, the remaining 0.2 kWh will be penalised at the market maker rate + 10%. The same is true if a PV generates 1 kWh but only sells 0.8 kWh. This is to penalise unaccounted for power flow that could be detrimental to the physical grid.","title":"What are penalties and how are they avoided?"},{"location":"faq-odyssey/#what-is-a-grid-fee","text":"A grid fee is a percentage of trade price or a constant value that is paid to the market for using the electrical grid.","title":"What is a Grid Fee ?"},{"location":"faq-odyssey/#simulation-and-api-setup","text":"","title":"Simulation and API Setup"},{"location":"faq-odyssey/#how-do-i-create-a-simulation-and-train-and-test-my-trading-bot","text":"You will train your agent locally on the backend code, and will interact with the frontend at d3a.io during the hackathon. Review this document describing how to install and interact with simulations via the API , which discusses connecting to the backend and to d3a.io. To run simulations on our frontend at d3a.io, follow the steps on our wiki to create and run simulations on d3a.io .","title":"How do I create a simulation and train and test my trading bot ?"},{"location":"faq-odyssey/#technical-information","text":"Please note that this information is subject to change as the challenge details are refined.","title":"Technical information"},{"location":"faq-odyssey/#how-many-days-are-in-each-simulation","text":"It is likely that each simulation will represent 7 real time days.","title":"How many days are in each simulation ?"},{"location":"faq-odyssey/#how-much-time-does-a-market-slot-take","text":"Each market slot represents 15 simulation time minutes which is 5-10 real time seconds. The exact simulation slowdown factor will be shared when decided upon.","title":"How much time does a market slot take ?"},{"location":"faq-odyssey/#how-many-ticks-are-in-a-market-slot","text":"In each market slot there will be 60-90 ticks. The on_tick(self, tick_info) function will be triggered every incremental 10% of the market slot, e.g. on tick 6, 12, 18, etc. if there are 60 ticks. This means you\u2019ll easily be able to make bid and offer decisions / updates 9 times per slot.","title":"How many ticks are in a market slot ?"},{"location":"faq-odyssey/#how-many-api-calls-can-i-make-per-market-slot","text":"","title":"How many API calls can I make per market slot ?"},{"location":"faq-odyssey/#each-device-may-have-up-to-5-active-bids-and-5-active-offers-at-any-point-in-time-there-will-be-a-realistic-limit-on-the-number-of-api-calls-such-as-1000-per-slot-which-will-not-limit-your-agents-and-is-only-intended-to-limit-the-probability-of-a-ddos-attack-the-exact-number-is-to-be-determined-and-will-be-shared","text":"","title":"Each device may have up to 5 active bids and 5 active offers at any point in time. There will be a realistic limit on the number of API calls, such as 1000 per slot, which will not limit your agents and is only intended to limit the probability of a DDOS attack. The exact number is to be determined and will be shared."},{"location":"faq-odyssey/#how-many-accounts-can-register-for-one-device","text":"Multiple accounts can apply for a device but only one will be selected by the simulation\u2019s grid operator, registered to a device and can send API calls.","title":"How many accounts can register for one device ?"},{"location":"faq-odyssey/#do-i-have-to-run-a-single-strategy-for-all-my-devices","text":"A single script could be used to manage all devices, but it is not obligatory. You can easily run multiple scripts with various strategies on your computer via multiple terminals.","title":"Do I have to run a single strategy for all my devices ?"},{"location":"faq-odyssey/#defining-success","text":"","title":"Defining Success"},{"location":"faq-odyssey/#what-criteria-will-teams-be-judged-on","text":"Winners will not be decided purely on how well their trading algorithm performs relative to other teams. Teams will be judged on a combination of: Algorithm Success : the success of their TradingBot against defined metrics such as energy bill and community self-sufficiency, the goal being specified each challenge round Algorithm Approach : the explanation / documentation of why their algorithm is performing the way it does, and what that means for the devices and communities it represents Challenge Questions : answers or approaches to the challenge questions as defined below. Not all questions must be attempted, especially if you have very well thought out answers to a subset of the questions","title":"What criteria will teams be judged on?"},{"location":"faq-odyssey/#what-are-the-challenge-questions","text":"Requirements for Intelligent Agents in the Real World - What information must be provided to intelligent agents who are trying to optimise the performance of energy devices they represent in the real world? What are some potential issues, such as privacy concerns or hardware limits? What should the flow of information look like? Calculate the Return on Investment of installing an energy asset - Given simulation outcomes, how could the return on investment of energy assets be determined? The intent would be to answer the question, \u201cshould I buy a battery or a solar panel, and what would be the benefit?\u201d. Community Index Design - Design a KPI that could be used to determine the effectiveness index of the way a community is interacting with the energy grid, taking into account energy bill, self-sufficiency, self-consumption, active devices, and other inputs. This index could then be used to judge communities or as an optimisation metric for trading algorithms.","title":"What are the challenge questions?"},{"location":"faq/","text":"This list of frequently asked questions (faq) is updated gradually, by adding the questions that come up on our Slack community chat (gsycommunity.slack.com). Our gitter has been replaced with our Slack community. D3A Functionality \u00b6 What is the D3A ? \u00b6 The D3A is an energy exchange engine. It is an open source software, enabling users to model, simulate, optimise, download, and deploy their own energy exchanges. The D3A is designed to build \u201cdigital twin\u201d representations of physical energy systems and energy markets. It aims to build open energy exchanges, extending access for new energy players, a class which is growing due to increased investments in distributed energy resources and smart devices. By creating energy exchanges from bottom to top, smart, local, and flexible devices as well as distributed renewable generation can be monetised for a faster transition to 100% renewable energy. The D3A simulation engine is currently available in two formats - the open source backend code , and the user friendly frontend User Interface (UI) . What are the possible use cases to simulate with the D3A ? \u00b6 The D3A is an energy exchange engine capable of simulating (and after further development facilitating) power flows and energy transactions in local marketplaces. The D3A showcases and harnesses the potential of transactive grids, renewable energy sources (RES) and peer to peer (P2P) energy trading for all stakeholders in the energy transition and can have multiple applications, including the following use cases. Community as a Service . Creates a local energy market within the grid-tied community and allows all energy assets (e.g. residential rooftop solar) equal access to market alongside traditional energy providers. This enables prosumers to participate actively in the energy market by trading locally before buying from or selling to the grid provider. Energy Access . Creates a local energy market within an islanded microgrid energy community . This allows for a more optimal microgrid configuration. To see an example of use case of \u201cCommunity as a Service\u201d with the D3A engine, please read our Medium article and watch our presentation from Event Horizon 2019 here . Both the \u201cCommunity as a Service\u201d and \u201cEnergy Access\u201d use cases are available as public projects at d3a.io . Do the D3A frontend and the backend have the same functionalities ? \u00b6 The backend code offers the full functionality of the active version of the D3A. The frontend User Interface (UI) offers a user friendly interface to the majority of features found in the backend. New features are typically developed in the backend first and are made available in the UI after internal testing for usability and accuracy. Frontend / User Interface at d3a.io \u00b6 How do I setup a simulation in the frontend ? \u00b6 To start using the D3A you need to register your account. You will then receive an email with a link to confirm your account. Once done you will be able to connect to d3a.io with your account. You can design your own project by clicking on \u201cnew project\u201d and then create a new simulation in it. The first step in setting up a simulation is to define the simulation settings. You can set the simulation duration, the solar profile type, the market type, and other relevant parameters. In the D3A you can choose one of the 3 market types available : single-sided pay as offer, two-sided pay as bid and two-sided pay as clear (for more information on the simulation settings please follow this link ). The next step is to design your grid. Once you arrive in the grid setup, the first thing that you will have to do is to define the market maker. Its goal is to represent a static or fluctuating base market price which will serve as a reference point for the selected device strategies. After creating this market maker, you can start building the digital twin of your grid. The D3A works by creating area markets. In each of these areas you can put devices or other grid areas. The devices can be loads, PV, storage, etc. The setup is intended to represent the physical architecture of the real energy market (country, region, neighbourhood, house, etc.). Importantly, each area contains a spot market where trades can occur. Each device places a bid/offer in their home market. When bids/offers are not matched in their own area, they are forwarded to the upper market in the upper area and so on. After your grid setup is complete, you can run your simulation. When it is finished you can view multiple scrollable plots and tables on the results page (for more on how to use these visuals, please see this link ) and you can also download the results file on your computer. For a step-by-step explanation on how to setup your simulation, please watch our tutorial . You can also see a video explaining the new release features implemented on the frontend here . If you have any other problems, please visit our documentation wiki page for the frontend and the backend D3A versions. Are there any limitations concerning the size of the simulation ? \u00b6 For smoother simulations and smaller queue, we have set some boundaries. First, the simulations are limited in their duration. You can currently set the duration from 1 to 7 days. Furthermore, the number of agents allowed per simulation is limited. Each device and area is considered as an agent and you can define up to 250 of these. Backend Codebase \u00b6 How do I setup a simulation in the backend ? \u00b6 There is no need to login to set up a simulation in the backend. You just need to follow the steps bellow : Download the code from our GitHub Repository . Please follow the technical instructions here to correctly install the D3A on your computer. To design a grid setup, please create a python file and follow our tips on how to setup file and global settings. You can also review our setup examples located at d3a/src/d3a/setup/ . To run a setup file you need to place it in the directory d3a/src/d3a/setup/ , or change the path yourself in the ConstSettings.py file. To launch the simulation in the command line interface, follow our technical instructions . Why do my results keep changing when I rerun the same setup ? \u00b6 This is caused by the random seed number. This number controls the randomness of the market, the bids, offers and the trades. If you have not defined this number, at each simulation a new random seed number will be generated and therefore you will keep observing different results (for example the trades between the areas and the storage SOC can vary). To set the random seed number you have to add this in the simulation launch command line interface --seed TEXT. By doing so, the randomness of the simulation will be frozen and your results won\u2019t change anymore. I am creating a long simulation (week/month/year) and would like to establish my spot market in the day ahead. Is this possible or is it frozen/strictly at 15 minutes ahead ? \u00b6 No, for now you cannot establish your spot market in the day ahead, but you can choose the number of tradable market slots into the future. This will allow your devices to trade in multiple future spot markets. To enable this functionality, you have to add to your simulation a launch command -m number_of_tradable_markets. The size of the market slot is configurable. You can change the market slot length of 15 minutes to be any integer between 2 minutes and 60 minutes. I am using the energy storage system (ESS) to represent a compressed air storage (with an electric-to-electric efficiency of 50%). How can I implement the efficiency in the ESS component ? \u00b6 For the time being, the storage component has a 100% electric-to-electric efficiency by default. Changing this characteristic is not possible at the moment but it will be possible in the near future. Users are welcome to add additional features to our open source code base on GitHub. I have created a setup with 2 identical areas. I would like to know how the d3a works if one area is prioritised over the other during clearing. Does it change when I change the random seed number ? \u00b6 If two areas are completely identical i.e post the same offer/bid, the market will randomly choose one of them. You can control this randomness by changing the random seed number in the launch CLI by adding --seed TEXT. I would like to study a structure with multiple microgrids exchanging energy based on a two sided market pay as clear. Furthermore, I would like that the exchanges inside microgrids (between houses) be based on a two sided market pay as bid. Can I setup such a structure with multiple market types inside one simulation ? \u00b6 No, for now that is not possible. You can only have one market type per simulation. In my simulations results, sometimes an area/device is both a seller and a buyer at the same time. Why does this happen ? \u00b6 Sometimes areas can be both a seller and a buyer at the same time. This is explained by the open market. It happens that loads in the area are not fast enough to place bids to buy their own generation. This also happens because of the device\u2019s strategy. If other loads (outside of the area) have the same buying rate as the load inside the area (and there are no grid fees), they can possibly \u201csteal\u201d the offers. To avoid this, you have to change the strategies and/or add grid fees in your simulation. This will help to prioritise self consumption inside each area. I am creating a simulation with one load and one generation and I am using the two sided market pay as clear. Sometimes, when my generation is lower than my demand, there are no trades at all. What is the reason for that ? \u00b6 The two sided market pay as clear is cleared if at least one bid is satisfied. For example in your case, since your only bid is not entirely satisfied, the market will not clear and therefore there won\u2019t be any trades. Can I configure all types of grid topography from meshed to radial under the same voltage level ? \u00b6 The D3A is designed for radial and hierarchical grid structures. Other topography types might be possible as long as they do not contain \"cycles\" (essentially closed loops in the grid structure). What you cannot currently simulate are loop networks, like rings. If I have a use case that has both residential consumers at 240V and industrial customers at 415V or higher, how can I set this up ? \u00b6 For now, voltage level is irrelevant, meaning that the D3A only simulate the amounts of energy transferred between each node (this will become important once we implement imbalances, differences between consumption and generation, which impact the frequency and the voltage of the grid). You can now simulate a grid that contains both residential and industrial consumers ignoring voltage limitations by taking for granted that the step-up transformers and transmission lines power rating will not be violated (since D3A does not check this for now). This will change once the power flows feature is implemented. By adding this new functionality, the electrical properties of the grid will be represented and used in the simulations. We recommend that each level of the D3A is tied to a specific grid voltage, so that each voltage level has its own market. How are the grid fees applied ? How do I set them up ? \u00b6 The grid fees represent the cost of the grid, taxes and other fees that are paid to another entity in exchange for using the grid. You can look at this page to see how you can set this up. When you define grid fees, it is applied inside of the specific area. These fees will be applied on the offers and bids, by raising or lowering their prices. Consequently, when an offer is published, its selling price will be the one defined by the seller plus the relevant grid fees. For trades to occur, the bid price minus the expected grid fees should be higher than the selling price plus the expected grid fees (for the two sided markets). Use of Blockchain \u00b6 Does D3A use blockchain technology ? \u00b6 The D3A has been designed so that it does not require blockchain technology but that it can benefit from this technology to provide enhanced functionality. Namely, if D3A-enabled deployment of energy markets is implemented via blockchain smart contracts there is full transparency of transactions, placing full trust in fair collaboration of energy actors rather than one actor having a market advantage. What are the current technological limitations for D3A\u2019s blockchain implementation and possible solutions ? \u00b6 The main limitation relates to scale or transactions throughput per second. We have tested the D3A on the ganache\u2019s private blockchain and it works only with increased simulation time as the processing is slower than when using the Python interpreter. The Energy Web Chain , designed especially for energy sector, is more efficient and less costly (in terms of transaction fees) than any other available public platform and hence would be the current blockchain of choice. As one single blockchain may never be able to handle the number and size of transactions of a large electrical grid, one solution to the problem lies in the interoperability of blockchains, with each responsible for one grid/area. This solution is proposed by the Polkadot Network , which will be launched and tested in 2020. In this scenario, the Energy Web Chain 2.0 could act as the relay chain for parachains for specific domains i.e. grid areas. Considering the hierarchical nature of the D3A market structure, do you look for special features on the blockchain for D3A to work more efficiently ? \u00b6 As D3A is hierarchical in design, there is a need of hierarchies of blockchain that specifically handle their own local grid/area. The Polkadot Network is therefore well suited for future D3A implementation. Grid Singularity\u2019s Approach \u00b6 Why is the D3A open source ? \u00b6 We believe that disruptive innovation that will lead us to new solutions to bring about the energy transition can not be achieved with private projects but rather with an open source community where everyone can contribute value, opportunities and challenges. The GPLv.3 license protects our code in a way that anyone who wishes to pursue proprietary commercialisation of the software would need to apply for a license, while open source applications continue to be free. What is the link between Grid Singularity and Energy Web Foundation ? \u00b6 Grid Singularity, an energy technology startup, and the Rocky Mountain Institute, a nonprofit clean technology organisation, jointly founded the Energy Web Foundation (EWF) in January 2017. EWF is a nonprofit foundation gathering an ecosystem of over 100 energy corporates and startups with a shared, public blockchain platform, the Energy Web Chain. While Grid Singularity has significantly contributed to EWF development and the launch of the Energy Web Chain, its role today is supervisory and advisory, with two Grid Singularity representatives serving on the EWF\u2019s Foundation Council. The Energy Web Chain is the blockchain of choice for D3A\u2019s future blockchain implementation. What are the future development plans ? \u00b6 We have partnered with innovative energy companies to facilitate further D3A development in the framework of the Odyssey 2020 Energy Singularity Track led by Grid Singularity. We will also work on some specific market simulation studies with partners to demonstrate the value of local energy markets. Following Odyssey Hackathon in June, we plan to deploy the D3A engine on a Testnet by the end of 2020. If I have questions regarding the D3A use, how can I contact you ? \u00b6 Please first review our wiki page documentation on the UI and the backend code. The best way to engage with us is via the D3A community/ecosystem channel on Slack . For any additional comments/feedback you can also send us an email at d3a@gridsingularity.com .","title":"Faq"},{"location":"faq/#d3a-functionality","text":"","title":"D3A Functionality"},{"location":"faq/#what-is-the-d3a","text":"The D3A is an energy exchange engine. It is an open source software, enabling users to model, simulate, optimise, download, and deploy their own energy exchanges. The D3A is designed to build \u201cdigital twin\u201d representations of physical energy systems and energy markets. It aims to build open energy exchanges, extending access for new energy players, a class which is growing due to increased investments in distributed energy resources and smart devices. By creating energy exchanges from bottom to top, smart, local, and flexible devices as well as distributed renewable generation can be monetised for a faster transition to 100% renewable energy. The D3A simulation engine is currently available in two formats - the open source backend code , and the user friendly frontend User Interface (UI) .","title":"What is the D3A ?"},{"location":"faq/#what-are-the-possible-use-cases-to-simulate-with-the-d3a","text":"The D3A is an energy exchange engine capable of simulating (and after further development facilitating) power flows and energy transactions in local marketplaces. The D3A showcases and harnesses the potential of transactive grids, renewable energy sources (RES) and peer to peer (P2P) energy trading for all stakeholders in the energy transition and can have multiple applications, including the following use cases. Community as a Service . Creates a local energy market within the grid-tied community and allows all energy assets (e.g. residential rooftop solar) equal access to market alongside traditional energy providers. This enables prosumers to participate actively in the energy market by trading locally before buying from or selling to the grid provider. Energy Access . Creates a local energy market within an islanded microgrid energy community . This allows for a more optimal microgrid configuration. To see an example of use case of \u201cCommunity as a Service\u201d with the D3A engine, please read our Medium article and watch our presentation from Event Horizon 2019 here . Both the \u201cCommunity as a Service\u201d and \u201cEnergy Access\u201d use cases are available as public projects at d3a.io .","title":"What are the possible use cases to simulate with the D3A ?"},{"location":"faq/#do-the-d3a-frontend-and-the-backend-have-the-same-functionalities","text":"The backend code offers the full functionality of the active version of the D3A. The frontend User Interface (UI) offers a user friendly interface to the majority of features found in the backend. New features are typically developed in the backend first and are made available in the UI after internal testing for usability and accuracy.","title":"Do the D3A frontend and the backend have the same functionalities ?"},{"location":"faq/#frontend-user-interface-at-d3aio","text":"","title":"Frontend / User Interface at d3a.io"},{"location":"faq/#how-do-i-setup-a-simulation-in-the-frontend","text":"To start using the D3A you need to register your account. You will then receive an email with a link to confirm your account. Once done you will be able to connect to d3a.io with your account. You can design your own project by clicking on \u201cnew project\u201d and then create a new simulation in it. The first step in setting up a simulation is to define the simulation settings. You can set the simulation duration, the solar profile type, the market type, and other relevant parameters. In the D3A you can choose one of the 3 market types available : single-sided pay as offer, two-sided pay as bid and two-sided pay as clear (for more information on the simulation settings please follow this link ). The next step is to design your grid. Once you arrive in the grid setup, the first thing that you will have to do is to define the market maker. Its goal is to represent a static or fluctuating base market price which will serve as a reference point for the selected device strategies. After creating this market maker, you can start building the digital twin of your grid. The D3A works by creating area markets. In each of these areas you can put devices or other grid areas. The devices can be loads, PV, storage, etc. The setup is intended to represent the physical architecture of the real energy market (country, region, neighbourhood, house, etc.). Importantly, each area contains a spot market where trades can occur. Each device places a bid/offer in their home market. When bids/offers are not matched in their own area, they are forwarded to the upper market in the upper area and so on. After your grid setup is complete, you can run your simulation. When it is finished you can view multiple scrollable plots and tables on the results page (for more on how to use these visuals, please see this link ) and you can also download the results file on your computer. For a step-by-step explanation on how to setup your simulation, please watch our tutorial . You can also see a video explaining the new release features implemented on the frontend here . If you have any other problems, please visit our documentation wiki page for the frontend and the backend D3A versions.","title":"How do I setup a simulation in the frontend ?"},{"location":"faq/#are-there-any-limitations-concerning-the-size-of-the-simulation","text":"For smoother simulations and smaller queue, we have set some boundaries. First, the simulations are limited in their duration. You can currently set the duration from 1 to 7 days. Furthermore, the number of agents allowed per simulation is limited. Each device and area is considered as an agent and you can define up to 250 of these.","title":"Are there any limitations concerning the size of the simulation ?"},{"location":"faq/#backend-codebase","text":"","title":"Backend Codebase"},{"location":"faq/#how-do-i-setup-a-simulation-in-the-backend","text":"There is no need to login to set up a simulation in the backend. You just need to follow the steps bellow : Download the code from our GitHub Repository . Please follow the technical instructions here to correctly install the D3A on your computer. To design a grid setup, please create a python file and follow our tips on how to setup file and global settings. You can also review our setup examples located at d3a/src/d3a/setup/ . To run a setup file you need to place it in the directory d3a/src/d3a/setup/ , or change the path yourself in the ConstSettings.py file. To launch the simulation in the command line interface, follow our technical instructions .","title":"How do I setup a simulation in the backend ?"},{"location":"faq/#why-do-my-results-keep-changing-when-i-rerun-the-same-setup","text":"This is caused by the random seed number. This number controls the randomness of the market, the bids, offers and the trades. If you have not defined this number, at each simulation a new random seed number will be generated and therefore you will keep observing different results (for example the trades between the areas and the storage SOC can vary). To set the random seed number you have to add this in the simulation launch command line interface --seed TEXT. By doing so, the randomness of the simulation will be frozen and your results won\u2019t change anymore.","title":"Why do my results keep changing when I rerun the same setup ?"},{"location":"faq/#i-am-creating-a-long-simulation-weekmonthyear-and-would-like-to-establish-my-spot-market-in-the-day-ahead-is-this-possible-or-is-it-frozenstrictly-at-15-minutes-ahead","text":"No, for now you cannot establish your spot market in the day ahead, but you can choose the number of tradable market slots into the future. This will allow your devices to trade in multiple future spot markets. To enable this functionality, you have to add to your simulation a launch command -m number_of_tradable_markets. The size of the market slot is configurable. You can change the market slot length of 15 minutes to be any integer between 2 minutes and 60 minutes.","title":"I am creating a long simulation (week/month/year) and would like to establish my spot market in the day ahead. Is this possible or is it frozen/strictly at 15 minutes ahead ?"},{"location":"faq/#i-am-using-the-energy-storage-system-ess-to-represent-a-compressed-air-storage-with-an-electric-to-electric-efficiency-of-50-how-can-i-implement-the-efficiency-in-the-ess-component","text":"For the time being, the storage component has a 100% electric-to-electric efficiency by default. Changing this characteristic is not possible at the moment but it will be possible in the near future. Users are welcome to add additional features to our open source code base on GitHub.","title":"I am using the energy storage system (ESS) to represent a compressed air storage (with an electric-to-electric efficiency of 50%). How can I implement the efficiency in the ESS component ?"},{"location":"faq/#i-have-created-a-setup-with-2-identical-areas-i-would-like-to-know-how-the-d3a-works-if-one-area-is-prioritised-over-the-other-during-clearing-does-it-change-when-i-change-the-random-seed-number","text":"If two areas are completely identical i.e post the same offer/bid, the market will randomly choose one of them. You can control this randomness by changing the random seed number in the launch CLI by adding --seed TEXT.","title":"I have created a setup with 2 identical areas. I would like to know how the d3a works if one area is prioritised over the other during clearing. Does it change when I change the random seed number ?"},{"location":"faq/#i-would-like-to-study-a-structure-with-multiple-microgrids-exchanging-energy-based-on-a-two-sided-market-pay-as-clear-furthermore-i-would-like-that-the-exchanges-inside-microgrids-between-houses-be-based-on-a-two-sided-market-pay-as-bid-can-i-setup-such-a-structure-with-multiple-market-types-inside-one-simulation","text":"No, for now that is not possible. You can only have one market type per simulation.","title":"I would like to study a structure with multiple microgrids exchanging energy based on a two sided market pay as clear. Furthermore, I would like that the exchanges inside microgrids (between houses) be based on a two sided market pay as bid. Can I setup such a structure with multiple market types inside one simulation ?"},{"location":"faq/#in-my-simulations-results-sometimes-an-areadevice-is-both-a-seller-and-a-buyer-at-the-same-time-why-does-this-happen","text":"Sometimes areas can be both a seller and a buyer at the same time. This is explained by the open market. It happens that loads in the area are not fast enough to place bids to buy their own generation. This also happens because of the device\u2019s strategy. If other loads (outside of the area) have the same buying rate as the load inside the area (and there are no grid fees), they can possibly \u201csteal\u201d the offers. To avoid this, you have to change the strategies and/or add grid fees in your simulation. This will help to prioritise self consumption inside each area.","title":"In my simulations results, sometimes an area/device is both a seller and a buyer at the same time. Why does this happen ?"},{"location":"faq/#i-am-creating-a-simulation-with-one-load-and-one-generation-and-i-am-using-the-two-sided-market-pay-as-clear-sometimes-when-my-generation-is-lower-than-my-demand-there-are-no-trades-at-all-what-is-the-reason-for-that","text":"The two sided market pay as clear is cleared if at least one bid is satisfied. For example in your case, since your only bid is not entirely satisfied, the market will not clear and therefore there won\u2019t be any trades.","title":"I am creating a simulation with one load and one generation and I am using the two sided market pay as clear. Sometimes, when my generation is lower than my demand, there are no trades at all. What is the reason for that ?"},{"location":"faq/#can-i-configure-all-types-of-grid-topography-from-meshed-to-radial-under-the-same-voltage-level","text":"The D3A is designed for radial and hierarchical grid structures. Other topography types might be possible as long as they do not contain \"cycles\" (essentially closed loops in the grid structure). What you cannot currently simulate are loop networks, like rings.","title":"Can I configure all types of grid topography from meshed to radial under the same voltage level ?"},{"location":"faq/#if-i-have-a-use-case-that-has-both-residential-consumers-at-240v-and-industrial-customers-at-415v-or-higher-how-can-i-set-this-up","text":"For now, voltage level is irrelevant, meaning that the D3A only simulate the amounts of energy transferred between each node (this will become important once we implement imbalances, differences between consumption and generation, which impact the frequency and the voltage of the grid). You can now simulate a grid that contains both residential and industrial consumers ignoring voltage limitations by taking for granted that the step-up transformers and transmission lines power rating will not be violated (since D3A does not check this for now). This will change once the power flows feature is implemented. By adding this new functionality, the electrical properties of the grid will be represented and used in the simulations. We recommend that each level of the D3A is tied to a specific grid voltage, so that each voltage level has its own market.","title":"If I have a use case that has both residential consumers at 240V and industrial customers at 415V or higher, how can I set this up ?"},{"location":"faq/#how-are-the-grid-fees-applied-how-do-i-set-them-up","text":"The grid fees represent the cost of the grid, taxes and other fees that are paid to another entity in exchange for using the grid. You can look at this page to see how you can set this up. When you define grid fees, it is applied inside of the specific area. These fees will be applied on the offers and bids, by raising or lowering their prices. Consequently, when an offer is published, its selling price will be the one defined by the seller plus the relevant grid fees. For trades to occur, the bid price minus the expected grid fees should be higher than the selling price plus the expected grid fees (for the two sided markets).","title":"How are the grid fees applied ? How do I set them up ?"},{"location":"faq/#use-of-blockchain","text":"","title":"Use of Blockchain"},{"location":"faq/#does-d3a-use-blockchain-technology","text":"The D3A has been designed so that it does not require blockchain technology but that it can benefit from this technology to provide enhanced functionality. Namely, if D3A-enabled deployment of energy markets is implemented via blockchain smart contracts there is full transparency of transactions, placing full trust in fair collaboration of energy actors rather than one actor having a market advantage.","title":"Does D3A use blockchain technology ?"},{"location":"faq/#what-are-the-current-technological-limitations-for-d3as-blockchain-implementation-and-possible-solutions","text":"The main limitation relates to scale or transactions throughput per second. We have tested the D3A on the ganache\u2019s private blockchain and it works only with increased simulation time as the processing is slower than when using the Python interpreter. The Energy Web Chain , designed especially for energy sector, is more efficient and less costly (in terms of transaction fees) than any other available public platform and hence would be the current blockchain of choice. As one single blockchain may never be able to handle the number and size of transactions of a large electrical grid, one solution to the problem lies in the interoperability of blockchains, with each responsible for one grid/area. This solution is proposed by the Polkadot Network , which will be launched and tested in 2020. In this scenario, the Energy Web Chain 2.0 could act as the relay chain for parachains for specific domains i.e. grid areas.","title":"What are the current technological limitations for D3A\u2019s blockchain implementation and possible solutions ?"},{"location":"faq/#considering-the-hierarchical-nature-of-the-d3a-market-structure-do-you-look-for-special-features-on-the-blockchain-for-d3a-to-work-more-efficiently","text":"As D3A is hierarchical in design, there is a need of hierarchies of blockchain that specifically handle their own local grid/area. The Polkadot Network is therefore well suited for future D3A implementation.","title":"Considering the hierarchical nature of the D3A market structure, do you look for special features on the blockchain for D3A to work more efficiently ?"},{"location":"faq/#grid-singularitys-approach","text":"","title":"Grid Singularity\u2019s Approach"},{"location":"faq/#why-is-the-d3a-open-source","text":"We believe that disruptive innovation that will lead us to new solutions to bring about the energy transition can not be achieved with private projects but rather with an open source community where everyone can contribute value, opportunities and challenges. The GPLv.3 license protects our code in a way that anyone who wishes to pursue proprietary commercialisation of the software would need to apply for a license, while open source applications continue to be free.","title":"Why is the D3A open source ?"},{"location":"faq/#what-is-the-link-between-grid-singularity-and-energy-web-foundation","text":"Grid Singularity, an energy technology startup, and the Rocky Mountain Institute, a nonprofit clean technology organisation, jointly founded the Energy Web Foundation (EWF) in January 2017. EWF is a nonprofit foundation gathering an ecosystem of over 100 energy corporates and startups with a shared, public blockchain platform, the Energy Web Chain. While Grid Singularity has significantly contributed to EWF development and the launch of the Energy Web Chain, its role today is supervisory and advisory, with two Grid Singularity representatives serving on the EWF\u2019s Foundation Council. The Energy Web Chain is the blockchain of choice for D3A\u2019s future blockchain implementation.","title":"What is the link between Grid Singularity and Energy Web Foundation ?"},{"location":"faq/#what-are-the-future-development-plans","text":"We have partnered with innovative energy companies to facilitate further D3A development in the framework of the Odyssey 2020 Energy Singularity Track led by Grid Singularity. We will also work on some specific market simulation studies with partners to demonstrate the value of local energy markets. Following Odyssey Hackathon in June, we plan to deploy the D3A engine on a Testnet by the end of 2020.","title":"What are the future development plans ?"},{"location":"faq/#if-i-have-questions-regarding-the-d3a-use-how-can-i-contact-you","text":"Please first review our wiki page documentation on the UI and the backend code. The best way to engage with us is via the D3A community/ecosystem channel on Slack . For any additional comments/feedback you can also send us an email at d3a@gridsingularity.com .","title":"If I have questions regarding the D3A use, how can I contact you ?"},{"location":"general-settings/","text":"Grid Singularity exchange engine can be used to simulate, collaborate and optimize grid-aware local energy markets (LEMs). The simulation tool is freely available through our User Interface (UI) at d3a.io and our backend codebase is open source under GNU general public license . This section will focus on a step-by-step guide to create and simulate LEMs using our software, starting with an explanation and guide for the UI, followed by a more technical tutorial to reproduce in the backend. User-Interface Simulation Configuration \u00b6 When creating a new simulation, simulation collaboration or a simulation in the Canary Test Network, the user needs to define the following general settings: Simulation name : Please provide a unique name. Description : Description of the simulation (optional but encouraged to clarify the intent of the simulation). Project : The user can select a project folder where the simulation is saved. Start date : Simulation start date (please make sure that the date-stamp of any uploaded data coincides with the defined start and end date). End date : Simulation end date. The user can simulate up to 7 days of LEM trading. Solar profile : Sets a template production curve for all photovoltaics (PVs) without custom production curves. Select one the following possible configurations: Sunny (generation profile with 250W panel) Cloudy (generation profile with 250W panel) Partially Cloudy (generation profile with 250W panel) Gaussian (the user can define the panel power output) Upload a profile (a custom default PV production curve can be uploaded as described in Upload File Formats ) Spot market type : The user can select one of three market types: One-sided pay-as-offer , Two-sided pay-as-bid and Two-sided pay-as-clear . Number of spot markets : Number of future spot markets where the energy assets and agents can trade. Duration of market slot : Duration of each spot market,between 2 and 60 minutes. Default is set to 15 minutes. Tick duration : Amount of time between two increments of each market slot when trades are cleared or agent trading rates are updated. Default duration is 15 simulated seconds, yielding 60 ticks per market slot. Grid Fees : The user can select one of two types: Constant grid fee or Percentage grid fee The interface for selecting general settings is shown below: Once the general settings of the simulation are defined, the user can move to the modelling page and set up the grid architecture by adding Markets and Energy Assets. Each market or energy asset is considered as 1 node . At the moment, up to 1000 nodes can be configured. Markets contain a spot market where all connected energy assets, submarkets and parent markets trade energy. Markets can potentially house multiple submarkets of different market types, and this feature will be available in the future version of our software. After adding the first market the user has to select a Market Maker rate. Subsequently, the user can model the simulation by configuring multiple submarkets and energy assets in a hierarchical electrical grid. Once the modelling is completed, the user goes to the Results page to initiate the simulation and view results. Backend Simulation Configuration \u00b6 In the backend, the simulation process is slightly different. There is no need to login to set up a simulation. The user first needs to download the code from our Github Repository (Installation Instructions for Linux , Mac and Windows ). In the setup-file (in Python programming language), general and trading strategy settings can be defined. Examples can be found in the relevant Grid Singularity GitHub folder. This is the most basic skeleton for a setup-file: from d3a.models.area import Area def get_setup ( config ): area = Area ( 'Grid' , []) return area The user can add more nested submarkets recursively by adding more instances of Area to the second parameter (list) of the Area class. If the strategy parameter is set in the Area class, the area is converted to a leaf node, e.g. a load. The following grid architecture is given: Grid House 1 H1 General Load H1 Storage 1 H1 Storage 2 House 2 H2 General Load Bold instances in the outline above are markets ( Area component). For each of these markets, an inter-area-agent is created in the background to execute offer/bid forwarding and matching. In the following, the corresponding setup-file is shown. from d3a.models.area import Area from d3a.models.strategy.storage import StorageStrategy from d3a.models.strategy.load_hours import LoadHoursStrategy from d3a.models.strategy.pv import PVStrategy def get_setup ( config ): area = Area ( 'Grid' , [ Area ( 'House 1' , [ Area ( 'H1 General Load' , strategy = LoadHoursStrategy ( avg_power_W = 200 , hrs_per_day = 6 , hrs_of_day = list ( range ( 12 , 18 )), final_buying_rate = 35 ) ), Area ( 'H1 Storage1' , strategy = StorageStrategy ( initial_soc = 50 ) ), Area ( 'H1 Storage2' , strategy = StorageStrategy ( initial_soc = 50 ) ), ], grid_fee_pct = 0 , grid_fee_const = 0 , ), Area ( 'House 2' , [ Area ( 'H2 General Load' , strategy = LoadHoursStrategy ( avg_power_W = 200 , hrs_per_day = 4 , hrs_of_day = list ( range ( 12 , 16 )), final_buying_rate = 35 ) ), Area ( 'H2 PV' , strategy = PVStrategy ( panel_count = 4 , initial_selling_rate = 30 , final_selling_rate = 5 ) ), ], grid_fee_pct = 0 , grid_fee_const = 0 , ), ], config = config ) return area Additionally the user has the possibility to change the default general settings in two different ways: Setup file (best option) d3a-setting.json setup-file (best option): \u00b6 For a description of each grid component please see the Modelling section. The user can overwrite the configuration settings by changing variables of the ConstSettings class in the setup-file. This class defines the default values for various parameters (general simulation settings, market settings and energy asset configuration). For instance, the user can define multiple configuration parameters in the get_setup function by overwriting the ConstSettings default values. For example, the following parameters can be set : Market_type (if equal to 1: One-Sided Pay-as-Offer , if equal to 2 : Two-Sided Pay-as-Bid , if equal to 3 : Two-Sided Pay-as-Clear ) Grid_fee_type (if equal to 1: Constant grid fee , if equal to 2 : Percentage grid fee ) Here is an example to setup a simulation with the Two-Sided Pay-as-Bid market type, constant grid fee and default min (0cts/kWh) and max to (35cts/kWh) energy rate for all loads : from d3a_interface.constants_limits import ConstSettings def get_setup ( config ): ConstSettings . IAASettings . MARKET_TYPE = 2 ConstSettings . LoadSettings . MIN_ENERGY_RATE = 0 ConstSettings . LoadSettings . MAX_ENERGY_RATE = 35 ConstSettings . IAASettings . GRID_FEE_TYPE = 1 d3a-settings.json \u00b6 These general settings can also be parsed via a settings file in JSON format, which contains all constants in the advanced_settings branch. An example can be found here: src/d3a/setup/d3a-settings.json The settings JSON file can be parsed via the --settings-file keyword Setting General Configuration Parameters \u00b6 The following parameters are part of Simulation Config and are initialised before updating any ConstSettings : sim_duration slot_length tick_length market_count cloud_coverage* market_maker_rate* grid_fee_pct* grid_fee_const* pv_user_profile* max_panel_power_W In order to update some of these parameters (starred in list above), please use update_config_parameters method to update the general configuration parameters in the setup file: def get_setup ( config ): config . update_config_parameters ( grid_fee_pct = 5 , grid_fee_const = 35 , cloud_coverage = 2 , pv_user_profile = \"<path>/<profile_name>\" , market_maker_rate = 30 ) area = Area ( 'Grid' , [ Area ( 'General Load' , strategy = LoadHoursStrategy ( avg_power_W = 200 , hrs_per_day = 4 , hrs_of_day = list ( range ( 12 , 16 )), final_buying_rate = 35 ) ), Area ( 'PV' , strategy = PVStrategy ( 4 , 80 ) ), ], config = config ) return area Simulation launch \u00b6 Once the entire grid architecture is modelled, including energy assets, the user can launch the trading simulation by running a command line including desired setup features: -d, --duration: simulated duration of simulation [default: 1d] -t, --tick-length: simulated duration of a tick [default: 1s] -s, --slot-length: simulated duration of a market slot [default: 15m] -c, --cloud-coverage: Cloud coverage, 0 for sunny, 1 for partial coverage, 2 for clouds. [default: 0] -m, --market-count: Number of tradable market slots [default: 1] --slot-length-realtime: Desired duration of slot in realtime [default: 0s] Example simulation call: d3a -l ERROR run --duration=1d --tick-length=1s --slot-length=15m --cloud-coverage=0 --market-count=5 --setup default_2a Getting help in the command line: d3a --help returns: Usage: d3a [OPTIONS] COMMAND [ARGS]... Options: -l, --log-level [CRITICAL|FATAL|ERROR|WARN|WARNING|INFO|DEBUG|NOTSET|TRACE] Log level [default: INFO] --help Show this message and exit. Commands: run* resume d3a run --help returns: Usage: d3a run [OPTIONS] Options: -d, --duration INTERVAL Duration of simulation [default: 1d] -t, --tick-length INTERVAL Length of a tick [default: 1s] -s, --slot-length INTERVAL Length of a market slot [default: 15m] --slot-length-realtime INTERVAL Desired duration of slot in realtime [default: 0s] -c, --cloud-coverage INTEGER Cloud coverage, 0 for sunny, 1 for partial coverage, 2 for clouds. [default: 0] -m, --market-count INTEGER Number of tradable market slots into the future [default: 1] --setup TEXT Simulation setup module use. Available modules: [1000_houses, market_events.cloud_coverage_event, market_events.disable_interval_event, market_events.disconnect_interval_event, market_events.isolated_connect_event, market_events.isolated_disable_event, market_events.isolated_disconnect_event, market_events.isolated_enable_event, market_events.load_event, market_events.pv_event, market_events.storage_event, balancing_market.default_2a, balancing_market.one_load_one_pv, balancing_market.one_load_one_storage, balancing_market.one_storage_one_pv, balancing_market.test_asset_registry, balancing_market.two_sided_one_load_one_pv, config_parameter_test, default_2, default_2a, default_2b, default_3, default_3_pv_only, default_3a, default_3b, default_4, default_5, default_addcurve, default_addcurve2, default_csv, graphs_testing, jira.d3asim_1024, jira.d3asim_1139, jira.d3asim_638_custom_load, jira.d3asim_639_custom_storage, jira.d3asim_640_custom_pv, jira.d3asim_778, jira.d3asim_780, jira.d3asim_869, jira.d3asim_871, jira.d3asim_895, jira.d3asim_895_pr1, jira.d3asim_895_pr2, jira.d3asim_895_pr3, jira.d3asim_962, jira.default_2off_d3asim_1475, jira.default_595, jira.default_611, jira.default_613, jira.default_623, jira.default_645, jira.default_737, jira.test_strategy_custom_load, jira.test_strategy_custom_pv, jira.test_strategy_custom_storage, json_arg, json_file, non_compounded_grid_fees, redis_communication_default_2a, sam_config, sam_config_const_load, sam_config_small, strategy_tests.commercial_producer_market_maker_rate, strategy_tests.ess_capacity_based_sell_offer, strategy_tests.ess_sell_offer_decrease_based_on_risk_or_rate, strategy_tests.finite_power_plant, strategy_tests.finite_power_plant_profile, strategy_tests.home_cp_ess_load, strategy_tests.home_hybrid_pv_ess_load, strategy_tests.infinite_bus, strategy_tests.predefined_pv_test, strategy_tests.pv_const_price_decrease, strategy_tests.pv_final_selling_rate, strategy_tests.pv_initial_pv_rate_option, strategy_tests.pv_max_panel_output, strategy_tests.pv_max_panel_power_global, strategy_tests.pv_risk_based_price_decrease, strategy_tests.storage_buys_and_offers, strategy_tests.storage_strategy_break_even_hourly, strategy_tests.user_profile_load_csv, strategy_tests.user_profile_load_csv_multiday, strategy_tests.user_profile_load_dict, strategy_tests.user_profile_pv_csv, strategy_tests.user_profile_pv_dict, strategy_tests.user_profile_wind_csv, strategy_tests.user_rate_profile_load_dict, tobalaba.one_producer_load, two_sided_market.default_2a, two_sided_market.infinite_bus, two_sided_market.offer_reposted_at_old_offer_rate, two_sided_market.one_cep_one_load, two_sided_market.one_load_5_pv_partial, two_sided_market.one_load_one_storage, two_sided_market.one_pv_one_load, two_sided_market.one_pv_one_storage, two_sided_market.one_storage_5_pv_partial, two_sided_market.user_min_rate_profile_load_dict, two_sided_market.with_balancing_market, two_sided_pay_as_clear.default_2a, two_sided_pay_as_clear.test_clearing_energy] -g, --settings-file TEXT Settings file path --seed TEXT Manually specify random seed --paused Start simulation in paused state [default: False] --pause-at TEXT Automatically pause at a certain time. Accepted Input formats: (YYYY-MM-DD, HH:mm) [default: disabled] --repl / --no-repl Start REPL after simulation run. [default: False] --no-export Skip export of simulation data --export-path TEXT Specify a path for the csv export files (default: ~/d3a-simulation) --enable-bc Run simulation on Blockchain --compare-alt-pricing Compare alternative pricing schemes --start-date DATE Start date of the Simulation (YYYY-MM-DD) [default: 2019-09-27] --help Show this message and exit.","title":"General Configuration Settings"},{"location":"general-settings/#user-interface-simulation-configuration","text":"When creating a new simulation, simulation collaboration or a simulation in the Canary Test Network, the user needs to define the following general settings: Simulation name : Please provide a unique name. Description : Description of the simulation (optional but encouraged to clarify the intent of the simulation). Project : The user can select a project folder where the simulation is saved. Start date : Simulation start date (please make sure that the date-stamp of any uploaded data coincides with the defined start and end date). End date : Simulation end date. The user can simulate up to 7 days of LEM trading. Solar profile : Sets a template production curve for all photovoltaics (PVs) without custom production curves. Select one the following possible configurations: Sunny (generation profile with 250W panel) Cloudy (generation profile with 250W panel) Partially Cloudy (generation profile with 250W panel) Gaussian (the user can define the panel power output) Upload a profile (a custom default PV production curve can be uploaded as described in Upload File Formats ) Spot market type : The user can select one of three market types: One-sided pay-as-offer , Two-sided pay-as-bid and Two-sided pay-as-clear . Number of spot markets : Number of future spot markets where the energy assets and agents can trade. Duration of market slot : Duration of each spot market,between 2 and 60 minutes. Default is set to 15 minutes. Tick duration : Amount of time between two increments of each market slot when trades are cleared or agent trading rates are updated. Default duration is 15 simulated seconds, yielding 60 ticks per market slot. Grid Fees : The user can select one of two types: Constant grid fee or Percentage grid fee The interface for selecting general settings is shown below: Once the general settings of the simulation are defined, the user can move to the modelling page and set up the grid architecture by adding Markets and Energy Assets. Each market or energy asset is considered as 1 node . At the moment, up to 1000 nodes can be configured. Markets contain a spot market where all connected energy assets, submarkets and parent markets trade energy. Markets can potentially house multiple submarkets of different market types, and this feature will be available in the future version of our software. After adding the first market the user has to select a Market Maker rate. Subsequently, the user can model the simulation by configuring multiple submarkets and energy assets in a hierarchical electrical grid. Once the modelling is completed, the user goes to the Results page to initiate the simulation and view results.","title":"User-Interface Simulation Configuration"},{"location":"general-settings/#backend-simulation-configuration","text":"In the backend, the simulation process is slightly different. There is no need to login to set up a simulation. The user first needs to download the code from our Github Repository (Installation Instructions for Linux , Mac and Windows ). In the setup-file (in Python programming language), general and trading strategy settings can be defined. Examples can be found in the relevant Grid Singularity GitHub folder. This is the most basic skeleton for a setup-file: from d3a.models.area import Area def get_setup ( config ): area = Area ( 'Grid' , []) return area The user can add more nested submarkets recursively by adding more instances of Area to the second parameter (list) of the Area class. If the strategy parameter is set in the Area class, the area is converted to a leaf node, e.g. a load. The following grid architecture is given: Grid House 1 H1 General Load H1 Storage 1 H1 Storage 2 House 2 H2 General Load Bold instances in the outline above are markets ( Area component). For each of these markets, an inter-area-agent is created in the background to execute offer/bid forwarding and matching. In the following, the corresponding setup-file is shown. from d3a.models.area import Area from d3a.models.strategy.storage import StorageStrategy from d3a.models.strategy.load_hours import LoadHoursStrategy from d3a.models.strategy.pv import PVStrategy def get_setup ( config ): area = Area ( 'Grid' , [ Area ( 'House 1' , [ Area ( 'H1 General Load' , strategy = LoadHoursStrategy ( avg_power_W = 200 , hrs_per_day = 6 , hrs_of_day = list ( range ( 12 , 18 )), final_buying_rate = 35 ) ), Area ( 'H1 Storage1' , strategy = StorageStrategy ( initial_soc = 50 ) ), Area ( 'H1 Storage2' , strategy = StorageStrategy ( initial_soc = 50 ) ), ], grid_fee_pct = 0 , grid_fee_const = 0 , ), Area ( 'House 2' , [ Area ( 'H2 General Load' , strategy = LoadHoursStrategy ( avg_power_W = 200 , hrs_per_day = 4 , hrs_of_day = list ( range ( 12 , 16 )), final_buying_rate = 35 ) ), Area ( 'H2 PV' , strategy = PVStrategy ( panel_count = 4 , initial_selling_rate = 30 , final_selling_rate = 5 ) ), ], grid_fee_pct = 0 , grid_fee_const = 0 , ), ], config = config ) return area Additionally the user has the possibility to change the default general settings in two different ways: Setup file (best option) d3a-setting.json","title":"Backend Simulation Configuration"},{"location":"general-settings/#setup-file-best-option","text":"For a description of each grid component please see the Modelling section. The user can overwrite the configuration settings by changing variables of the ConstSettings class in the setup-file. This class defines the default values for various parameters (general simulation settings, market settings and energy asset configuration). For instance, the user can define multiple configuration parameters in the get_setup function by overwriting the ConstSettings default values. For example, the following parameters can be set : Market_type (if equal to 1: One-Sided Pay-as-Offer , if equal to 2 : Two-Sided Pay-as-Bid , if equal to 3 : Two-Sided Pay-as-Clear ) Grid_fee_type (if equal to 1: Constant grid fee , if equal to 2 : Percentage grid fee ) Here is an example to setup a simulation with the Two-Sided Pay-as-Bid market type, constant grid fee and default min (0cts/kWh) and max to (35cts/kWh) energy rate for all loads : from d3a_interface.constants_limits import ConstSettings def get_setup ( config ): ConstSettings . IAASettings . MARKET_TYPE = 2 ConstSettings . LoadSettings . MIN_ENERGY_RATE = 0 ConstSettings . LoadSettings . MAX_ENERGY_RATE = 35 ConstSettings . IAASettings . GRID_FEE_TYPE = 1","title":"setup-file (best option):"},{"location":"general-settings/#d3a-settingsjson","text":"These general settings can also be parsed via a settings file in JSON format, which contains all constants in the advanced_settings branch. An example can be found here: src/d3a/setup/d3a-settings.json The settings JSON file can be parsed via the --settings-file keyword","title":"d3a-settings.json"},{"location":"general-settings/#setting-general-configuration-parameters","text":"The following parameters are part of Simulation Config and are initialised before updating any ConstSettings : sim_duration slot_length tick_length market_count cloud_coverage* market_maker_rate* grid_fee_pct* grid_fee_const* pv_user_profile* max_panel_power_W In order to update some of these parameters (starred in list above), please use update_config_parameters method to update the general configuration parameters in the setup file: def get_setup ( config ): config . update_config_parameters ( grid_fee_pct = 5 , grid_fee_const = 35 , cloud_coverage = 2 , pv_user_profile = \"<path>/<profile_name>\" , market_maker_rate = 30 ) area = Area ( 'Grid' , [ Area ( 'General Load' , strategy = LoadHoursStrategy ( avg_power_W = 200 , hrs_per_day = 4 , hrs_of_day = list ( range ( 12 , 16 )), final_buying_rate = 35 ) ), Area ( 'PV' , strategy = PVStrategy ( 4 , 80 ) ), ], config = config ) return area","title":"Setting General Configuration Parameters"},{"location":"general-settings/#simulation-launch","text":"Once the entire grid architecture is modelled, including energy assets, the user can launch the trading simulation by running a command line including desired setup features: -d, --duration: simulated duration of simulation [default: 1d] -t, --tick-length: simulated duration of a tick [default: 1s] -s, --slot-length: simulated duration of a market slot [default: 15m] -c, --cloud-coverage: Cloud coverage, 0 for sunny, 1 for partial coverage, 2 for clouds. [default: 0] -m, --market-count: Number of tradable market slots [default: 1] --slot-length-realtime: Desired duration of slot in realtime [default: 0s] Example simulation call: d3a -l ERROR run --duration=1d --tick-length=1s --slot-length=15m --cloud-coverage=0 --market-count=5 --setup default_2a Getting help in the command line: d3a --help returns: Usage: d3a [OPTIONS] COMMAND [ARGS]... Options: -l, --log-level [CRITICAL|FATAL|ERROR|WARN|WARNING|INFO|DEBUG|NOTSET|TRACE] Log level [default: INFO] --help Show this message and exit. Commands: run* resume d3a run --help returns: Usage: d3a run [OPTIONS] Options: -d, --duration INTERVAL Duration of simulation [default: 1d] -t, --tick-length INTERVAL Length of a tick [default: 1s] -s, --slot-length INTERVAL Length of a market slot [default: 15m] --slot-length-realtime INTERVAL Desired duration of slot in realtime [default: 0s] -c, --cloud-coverage INTEGER Cloud coverage, 0 for sunny, 1 for partial coverage, 2 for clouds. [default: 0] -m, --market-count INTEGER Number of tradable market slots into the future [default: 1] --setup TEXT Simulation setup module use. Available modules: [1000_houses, market_events.cloud_coverage_event, market_events.disable_interval_event, market_events.disconnect_interval_event, market_events.isolated_connect_event, market_events.isolated_disable_event, market_events.isolated_disconnect_event, market_events.isolated_enable_event, market_events.load_event, market_events.pv_event, market_events.storage_event, balancing_market.default_2a, balancing_market.one_load_one_pv, balancing_market.one_load_one_storage, balancing_market.one_storage_one_pv, balancing_market.test_asset_registry, balancing_market.two_sided_one_load_one_pv, config_parameter_test, default_2, default_2a, default_2b, default_3, default_3_pv_only, default_3a, default_3b, default_4, default_5, default_addcurve, default_addcurve2, default_csv, graphs_testing, jira.d3asim_1024, jira.d3asim_1139, jira.d3asim_638_custom_load, jira.d3asim_639_custom_storage, jira.d3asim_640_custom_pv, jira.d3asim_778, jira.d3asim_780, jira.d3asim_869, jira.d3asim_871, jira.d3asim_895, jira.d3asim_895_pr1, jira.d3asim_895_pr2, jira.d3asim_895_pr3, jira.d3asim_962, jira.default_2off_d3asim_1475, jira.default_595, jira.default_611, jira.default_613, jira.default_623, jira.default_645, jira.default_737, jira.test_strategy_custom_load, jira.test_strategy_custom_pv, jira.test_strategy_custom_storage, json_arg, json_file, non_compounded_grid_fees, redis_communication_default_2a, sam_config, sam_config_const_load, sam_config_small, strategy_tests.commercial_producer_market_maker_rate, strategy_tests.ess_capacity_based_sell_offer, strategy_tests.ess_sell_offer_decrease_based_on_risk_or_rate, strategy_tests.finite_power_plant, strategy_tests.finite_power_plant_profile, strategy_tests.home_cp_ess_load, strategy_tests.home_hybrid_pv_ess_load, strategy_tests.infinite_bus, strategy_tests.predefined_pv_test, strategy_tests.pv_const_price_decrease, strategy_tests.pv_final_selling_rate, strategy_tests.pv_initial_pv_rate_option, strategy_tests.pv_max_panel_output, strategy_tests.pv_max_panel_power_global, strategy_tests.pv_risk_based_price_decrease, strategy_tests.storage_buys_and_offers, strategy_tests.storage_strategy_break_even_hourly, strategy_tests.user_profile_load_csv, strategy_tests.user_profile_load_csv_multiday, strategy_tests.user_profile_load_dict, strategy_tests.user_profile_pv_csv, strategy_tests.user_profile_pv_dict, strategy_tests.user_profile_wind_csv, strategy_tests.user_rate_profile_load_dict, tobalaba.one_producer_load, two_sided_market.default_2a, two_sided_market.infinite_bus, two_sided_market.offer_reposted_at_old_offer_rate, two_sided_market.one_cep_one_load, two_sided_market.one_load_5_pv_partial, two_sided_market.one_load_one_storage, two_sided_market.one_pv_one_load, two_sided_market.one_pv_one_storage, two_sided_market.one_storage_5_pv_partial, two_sided_market.user_min_rate_profile_load_dict, two_sided_market.with_balancing_market, two_sided_pay_as_clear.default_2a, two_sided_pay_as_clear.test_clearing_energy] -g, --settings-file TEXT Settings file path --seed TEXT Manually specify random seed --paused Start simulation in paused state [default: False] --pause-at TEXT Automatically pause at a certain time. Accepted Input formats: (YYYY-MM-DD, HH:mm) [default: disabled] --repl / --no-repl Start REPL after simulation run. [default: False] --no-export Skip export of simulation data --export-path TEXT Specify a path for the csv export files (default: ~/d3a-simulation) --enable-bc Run simulation on Blockchain --compare-alt-pricing Compare alternative pricing schemes --start-date DATE Start date of the Simulation (YYYY-MM-DD) [default: 2019-09-27] --help Show this message and exit.","title":"Simulation launch"},{"location":"grid-fees/","text":"Grid operators (Distribution and Transmission System Operators - DSOs and TSOs - or Independent System Operators - ISOs in the USA) are tasked to monitor and manage the electrical grid. It is their responsibility to ensure a connection for end-users on the distribution network along with energy transport security. Grid operators use grid fees to cover the cost of managing their grid infrastructure. Lately, due to the heightened pace of innovation, increased demand and investment in distributed energy resources (DERs), grid operators face many challenges, such as lines and transformers congestion at specific times of the day. One solution is to use grid fees as a tool to actively manage grid congestion by increasing and reducing the fee during the day, week or year. Increasing the fee at peak transmission and reducing the price during off-peak periods makes it financially attractive for end-users to use flexible energy assets (e.g. batteries, EVs, heat-pumps) to provide demand response services and reduce reliance on the grid. Grid Singularity offers an environment to simulate, test and optimize grid fee incentives for local energy markets (LEMs) At the moment grid fee can be set as : Market Fee : This is a fee that is added to each trade that is cleared. The buyer of energy is responsible for paying all the grid fees: bid\u2019s price >= offer\u2019s price + grid fee . Constant grid fee : constant value in cents/kWh that is added to each trade Percentage grid fee : percentage value determined by the clearing price that is added to each trade The following article explains how flexible grid fees may be implemented towards peak reduction. For a video tutorial on how to set grid fees in the Grid Singularity exchange engine , please follow this link .","title":"Grid Fee Objectives"},{"location":"grid-operator-api/","text":"The Grid Singularity API client allows you to create agents that can dynamically change the grid fee in different markets. The agent can request and receive information through the Grid Operator API, feed that information into a tariff model, and change grid fees on a live simulated exchange. The Grid Operator API is designed for grid operators (notably Distribution System Operators or DSOs) to manage different markets on specific grid levels. The structure is designed so that multiple markets can be managed from a single agent. Notably this allows the agent to aggregate information to integrate a more efficient grid management. Market Information \u00b6 The Grid Operator API receives information concerning the markets that it manages. Different metrics are shared through the API : Minimum, median, average and maximum trade price [\u20ac/kWh] Total energy volume traded [kWh] Self sufficiency [%] Import / Export [kWh] Current market fee [cents/kWh] Next market fee [cents/kWh] Market fee revenue [cents] Interaction with the running exchange \u00b6 As explained above the Grid Operator API function is triggered at the end of each market slot. Here is one example: At the end of the 12:45 market slot, the Grid Operator API function on_market_cycle is triggered. The Grid Operator agent receives a dictionary with information from the last market slot (12:45-13:00). Based on these inputs, the agent script sets a new grid fee for the markets it manages. The grid fees sent between 13:00 and 13:15 will be applied for the 13:15 market slot API command \u00b6 The Grid Operator API can function once at the end of each market slot. When the current market slot ends, the client will get notified via an event. It is possible to capture this event and perform operations when it occurs by overriding the functionality of the on_market_cycle method e.g. def on_market_cycle(self, market_info): The Grid Operator API can send batch commands, grouping different commands, for different markets. Three different commands are available : market stats \u00b6 This command is used to request information from different markets for the last market slot. A batch_command dictionary structure is used and the response is stored in a variable : batch_commands [ area_uuid ] . append ({ \"type\" : \"market_stats\" , \"data\" : { \"market_slots\" : market_slot }}) self . market_stats = self . batch_command ( batch_commands_stats ) dso market stats \u00b6 This command is used to request information from different markets for the last market slot, more specific to grid operators (e.g. import and export of the market). A batch_command dictionary structure is used and the response is stored in a variable: batch_commands_stats [ area_uuid ] . append ({ \"type\" : \"dso_market_stats\" , \"data\" : { \"market_slots\" : market_slot }}) self . dso_stats = self . batch_command ( batch_commands_stats )[ \"responses\" ] grid fee \u00b6 This command is used to send the new grid fee for a specific market. The grid fee needs to be sent as an integer and the unit is cents/kWh. A batch_command dictionary structure is used: batch_commands [ area_uuid ] . append ({ \"type\" : \"grid_fees\" , \"data\" : { \"fee_const\" : self . next_fee }}) self . batch_command ( batch_commands ) For a video tutorial on the Grid Operator API, please follow this link and a template Grid Operator API script here .","title":"Grid Operator API"},{"location":"grid-operator-api/#market-information","text":"The Grid Operator API receives information concerning the markets that it manages. Different metrics are shared through the API : Minimum, median, average and maximum trade price [\u20ac/kWh] Total energy volume traded [kWh] Self sufficiency [%] Import / Export [kWh] Current market fee [cents/kWh] Next market fee [cents/kWh] Market fee revenue [cents]","title":"Market Information"},{"location":"grid-operator-api/#interaction-with-the-running-exchange","text":"As explained above the Grid Operator API function is triggered at the end of each market slot. Here is one example: At the end of the 12:45 market slot, the Grid Operator API function on_market_cycle is triggered. The Grid Operator agent receives a dictionary with information from the last market slot (12:45-13:00). Based on these inputs, the agent script sets a new grid fee for the markets it manages. The grid fees sent between 13:00 and 13:15 will be applied for the 13:15 market slot","title":"Interaction with the running exchange"},{"location":"grid-operator-api/#api-command","text":"The Grid Operator API can function once at the end of each market slot. When the current market slot ends, the client will get notified via an event. It is possible to capture this event and perform operations when it occurs by overriding the functionality of the on_market_cycle method e.g. def on_market_cycle(self, market_info): The Grid Operator API can send batch commands, grouping different commands, for different markets. Three different commands are available :","title":"API command"},{"location":"grid-operator-api/#market-stats","text":"This command is used to request information from different markets for the last market slot. A batch_command dictionary structure is used and the response is stored in a variable : batch_commands [ area_uuid ] . append ({ \"type\" : \"market_stats\" , \"data\" : { \"market_slots\" : market_slot }}) self . market_stats = self . batch_command ( batch_commands_stats )","title":"market stats"},{"location":"grid-operator-api/#dso-market-stats","text":"This command is used to request information from different markets for the last market slot, more specific to grid operators (e.g. import and export of the market). A batch_command dictionary structure is used and the response is stored in a variable: batch_commands_stats [ area_uuid ] . append ({ \"type\" : \"dso_market_stats\" , \"data\" : { \"market_slots\" : market_slot }}) self . dso_stats = self . batch_command ( batch_commands_stats )[ \"responses\" ]","title":"dso market stats"},{"location":"grid-operator-api/#grid-fee","text":"This command is used to send the new grid fee for a specific market. The grid fee needs to be sent as an integer and the unit is cents/kWh. A batch_command dictionary structure is used: batch_commands [ area_uuid ] . append ({ \"type\" : \"grid_fees\" , \"data\" : { \"fee_const\" : self . next_fee }}) self . batch_command ( batch_commands ) For a video tutorial on the Grid Operator API, please follow this link and a template Grid Operator API script here .","title":"grid fee"},{"location":"inter-area-agent/","text":"The Inter-Area Agent (IAA) plays a crucial role in the communication architecture of Grid Singularity\u2019s exchange engine (D3A), allowing different markets in the hierarchy to interact and trade with each other. IAA is created for each market (households/buildings, streets, etc. that do not have preset trading strategies) and mainly deals with forwarding bids and offers markets of different hierarchy levels. The following illustration shows a sample grid setup and the role of the IAA in the market hierarchy during one time slot: The IAA is responsible for modelling hierarchical market operations, as follows: Forwarding bids and offers from a lower hierarchy (market) to an upper hierarchy. Reacting to bids, offers and trades reported by IAAs in connected markets, in order to propagate the event for an offer/bid that has been forwarded from this IAA. Triggering the matching of bids and offers for the two-sided market. To prioritize local trades, IAAs forward bids and offers to higher/lower markets with a two-tick delay.","title":"Bids/Offers Process and Hierarchical Market Structure"},{"location":"ios-installation-instructions/","text":"Step 1: Installation prerequisites: \u00b6 make sure the command line compiler tools are installed: \u00b6 xcode-select --install (Select Install in the window that opens) Step 2: Install homebrew \u00b6 /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" Step 3: Install other required libraries: \u00b6 brew install automake libtool pkg-config libffi gmp openssl readline xz Step 4: Install pyenv: \u00b6 brew install pyenv echo -e 'if command -v pyenv 1>/dev/null 2>&1; then\\n eval \"$(pyenv init -)\"\\nfi' >> ~/.bash_profile Step 5: Close and re-open the terminal \u00b6 Step 6: Install python 3.6 and set as default: \u00b6 pyenv install 3.6.3 pyenv global 3.6.3 Step 7: Install virtualenvwrapper: \u00b6 pip install virtualenvwrapper echo -e 'export WORKON_HOME=~/Envs\\nsource ~/.pyenv/versions/3.6.3/bin/virtualenvwrapper.sh' >> ~/.bash_profile Step 8: Setup paths for compiling python libraries: \u00b6 echo -e 'BREW_PREFIX=\"$(brew --prefix openssl)\"\\nexport CFLAGS=\"-I${BREW_PREFIX}/include\"\\nexport LDFLAGS=\"-L${BREW_PREFIX}/lib\"' >> ~/.bash_profile Step 9: Close and re-open the terminal \u00b6 Step 10: Clone Grid Singularity D3A repository (do this inside the directory where you want the project to be): \u00b6 git clone \"https://github.com/gridsingularity/d3a.git\" cd d3a Step 11: Create and initialize d3a virtualenv \u00b6 brew install npm npm install --global ganache-cli mkvirtualenv d3a pip install pendulum pip-tools pip install -e . You now should have a working d3a setup. For help in the terminal ani to test your installation, run d3a run -\u2013help .","title":"Mac Installation Instructions"},{"location":"ios-installation-instructions/#step-1-installation-prerequisites","text":"","title":"Step 1: Installation prerequisites:"},{"location":"ios-installation-instructions/#make-sure-the-command-line-compiler-tools-are-installed","text":"xcode-select --install (Select Install in the window that opens)","title":"make sure the command line compiler tools are installed:"},{"location":"ios-installation-instructions/#step-2-install-homebrew","text":"/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"","title":"Step 2: Install homebrew"},{"location":"ios-installation-instructions/#step-3-install-other-required-libraries","text":"brew install automake libtool pkg-config libffi gmp openssl readline xz","title":"Step 3: Install other required libraries:"},{"location":"ios-installation-instructions/#step-4-install-pyenv","text":"brew install pyenv echo -e 'if command -v pyenv 1>/dev/null 2>&1; then\\n eval \"$(pyenv init -)\"\\nfi' >> ~/.bash_profile","title":"Step 4: Install pyenv:"},{"location":"ios-installation-instructions/#step-5-close-and-re-open-the-terminal","text":"","title":"Step 5: Close and re-open the terminal"},{"location":"ios-installation-instructions/#step-6-install-python-36-and-set-as-default","text":"pyenv install 3.6.3 pyenv global 3.6.3","title":"Step 6: Install python 3.6 and set as default:"},{"location":"ios-installation-instructions/#step-7-install-virtualenvwrapper","text":"pip install virtualenvwrapper echo -e 'export WORKON_HOME=~/Envs\\nsource ~/.pyenv/versions/3.6.3/bin/virtualenvwrapper.sh' >> ~/.bash_profile","title":"Step 7: Install virtualenvwrapper:"},{"location":"ios-installation-instructions/#step-8-setup-paths-for-compiling-python-libraries","text":"echo -e 'BREW_PREFIX=\"$(brew --prefix openssl)\"\\nexport CFLAGS=\"-I${BREW_PREFIX}/include\"\\nexport LDFLAGS=\"-L${BREW_PREFIX}/lib\"' >> ~/.bash_profile","title":"Step 8: Setup paths for compiling python libraries:"},{"location":"ios-installation-instructions/#step-9-close-and-re-open-the-terminal","text":"","title":"Step 9: Close and re-open the terminal"},{"location":"ios-installation-instructions/#step-10-clone-grid-singularity-d3a-repository-do-this-inside-the-directory-where-you-want-the-project-to-be","text":"git clone \"https://github.com/gridsingularity/d3a.git\" cd d3a","title":"Step 10: Clone Grid Singularity D3A repository (do this inside the directory where you want the project to be):"},{"location":"ios-installation-instructions/#step-11-create-and-initialize-d3a-virtualenv","text":"brew install npm npm install --global ganache-cli mkvirtualenv d3a pip install pendulum pip-tools pip install -e . You now should have a working d3a setup. For help in the terminal ani to test your installation, run d3a run -\u2013help .","title":"Step 11: Create and initialize d3a virtualenv"},{"location":"library/","text":"Libraries contain preconfigured energy assets, markets, and even small grids that can be reused in different simulations (e.g. loads, PVs, houses and even entire communities). The list of libraries is paginated. You can either click through the pages by pressing the Prev or Next button in the bottom right corner or use the search field in the top right corner to filter the list by the library names. The following buttons and labels can be seen in the Library page: Denotes public libraries (other users can see the Library and the uploaded profiles): & (in the search bar) Quicklook labels for showing type and number of assets and the number of markets in the library: With this button the user can edit library content or view public libraries: With this button the user can rename, duplicate or delete an existing library (only user\u2019s own library may be deleted): The user can also create a new library (button redirects to Grid setup ):","title":"Asset and Data Library"},{"location":"licensing/","text":"Grid Singularity\u2019s software is available under an open source GNU General Public License . We believe that disruptive innovation yields new solutions to bring about the energy transition and can only be achieved by an open source community. The GPLv.3 license protects our code in a way that anyone who wishes to pursue proprietary commercialisation of the software would need to apply for a license, while open source applications supporting sustainable development continue to be free.","title":"Licensing and Open Source Ethos"},{"location":"linux-installation-instructions/","text":"Installing Grid Singularity energy exchange (D3A) on Linux Ubuntu 18.04: \u00b6 Step 1: In case you have not already installed git, python3.6 and pip (otherwise please go directly to step 2): \u00b6 sudo apt-get update sudo apt-get install git-core software-properties-common -y sudo add-apt-repository ppa:deadsnakes/ppa sudo apt-get update sudo apt-get install python3.6 -y sudo apt-get install git-core -y sudo apt-get install python3-pip -y Step 2: Install virtualenv and create a python virtual environment \u00b6 pip3 install virtualenv mkdir envs cd envs virtualenv -p /usr/bin/python3.6 d3a How to activate the environment: \u00b6 source d3a/bin/activate How to deactivate the environment: \u00b6 deactivate Step 3: Please add the following lines to your .bashrc and reopen the shell: \u00b6 export LC_ALL=C.UTF-8 export LANG=C.UTF-8 Step 4: Clone the Grid Singularity D3A repository to a directory of your choice: \u00b6 git clone https://github.com/gridsingularity/d3a.git Step 5: Install the Grid Singularity energy exchange (D3A): \u00b6 Activate your virtual environment and go into the d3a repository \u00b6 source d3a/bin/activate Install pip-tools \u00b6 pip3 install pendulum pip-tools Install dependencies \u00b6 pip install -e. Now, if you run d3a run -\u2013help , the help of d3a should be shown. Installing Grid Singularity energy exchange (D3A) on Linux Ubuntu 20.04: \u00b6 Please follow the installation instructions for Ubuntu 18.04 If case you encounter the following error error: command 'x86_64-linux-gnu-gcc' failed with exit status 1 please install the following package: sudo apt-get install build-essential python3.6-dev -y","title":"Linux Installation Instructions"},{"location":"linux-installation-instructions/#installing-grid-singularity-energy-exchange-d3a-on-linux-ubuntu-1804","text":"","title":"Installing Grid Singularity energy exchange (D3A) on Linux Ubuntu 18.04:"},{"location":"linux-installation-instructions/#step-1-in-case-you-have-not-already-installed-git-python36-and-pip-otherwise-please-go-directly-to-step-2","text":"sudo apt-get update sudo apt-get install git-core software-properties-common -y sudo add-apt-repository ppa:deadsnakes/ppa sudo apt-get update sudo apt-get install python3.6 -y sudo apt-get install git-core -y sudo apt-get install python3-pip -y","title":"Step 1: In case you have not already installed git, python3.6 and pip (otherwise please go directly to step 2):"},{"location":"linux-installation-instructions/#step-2-install-virtualenv-and-create-a-python-virtual-environment","text":"pip3 install virtualenv mkdir envs cd envs virtualenv -p /usr/bin/python3.6 d3a","title":"Step 2: Install virtualenv and create a python virtual environment"},{"location":"linux-installation-instructions/#how-to-activate-the-environment","text":"source d3a/bin/activate","title":"How to activate the environment:"},{"location":"linux-installation-instructions/#how-to-deactivate-the-environment","text":"deactivate","title":"How to deactivate the environment:"},{"location":"linux-installation-instructions/#step-3-please-add-the-following-lines-to-your-bashrc-and-reopen-the-shell","text":"export LC_ALL=C.UTF-8 export LANG=C.UTF-8","title":"Step 3: Please add the following lines to your .bashrc and reopen the shell:"},{"location":"linux-installation-instructions/#step-4-clone-the-grid-singularity-d3a-repository-to-a-directory-of-your-choice","text":"git clone https://github.com/gridsingularity/d3a.git","title":"Step 4: Clone the Grid Singularity D3A repository to a directory of your choice:"},{"location":"linux-installation-instructions/#step-5-install-the-grid-singularity-energy-exchange-d3a","text":"","title":"Step 5: Install the Grid Singularity energy exchange (D3A):"},{"location":"linux-installation-instructions/#activate-your-virtual-environment-and-go-into-the-d3a-repository","text":"source d3a/bin/activate","title":"Activate your virtual environment and go into the d3a repository"},{"location":"linux-installation-instructions/#install-pip-tools","text":"pip3 install pendulum pip-tools","title":"Install pip-tools"},{"location":"linux-installation-instructions/#install-dependencies","text":"pip install -e. Now, if you run d3a run -\u2013help , the help of d3a should be shown.","title":"Install dependencies"},{"location":"linux-installation-instructions/#installing-grid-singularity-energy-exchange-d3a-on-linux-ubuntu-2004","text":"Please follow the installation instructions for Ubuntu 18.04 If case you encounter the following error error: command 'x86_64-linux-gnu-gcc' failed with exit status 1 please install the following package: sudo apt-get install build-essential python3.6-dev -y","title":"Installing Grid Singularity energy exchange (D3A) on Linux Ubuntu 20.04:"},{"location":"map/","text":"In the User Interface , each energy asset and market can be pinned on a map with geographic coordinates in the form of a geotag, linked to a physical address . If a geotag is set at the market level, all submarkets and their assets are tied to these coordinates. In this example, Neuk\u00f6ln market includes all submarkets and assets under the same geotag (House 1, House 2, PV 4, Market and PV 5). If a market geo-tag type is set to location , the market can be pinned on the map and all of its submarkets and assets will inherit the same location: In this example, House 2\u2019s assets are assigned the same location as the House 2 submarket. Once the user has added locations via geotags for its markets and energy assets, the simulation will be shown on the Grid Singularity\u2019s public map, which will disclose the location of the simulation\u2019s highest market and the total number of markets and energy assets. For a video tutorial on the map feature, please follow this link .","title":"Map"},{"location":"markets/","text":"Market Types \u00b6 The main goal of an electricity market exchange is to balance the grid in terms of demand and supply. Since efficient storage of large quantities of energy is currently not economically feasible and electrical current varies within seconds, a market mechanism that efficiently accounts for the physical energy production and consumption is required. Generally, trading occurs in three types of markets with different time intervals: Spot market : short-term trades for immediate or near-term delivery. Energy transactions are divided into small time blocks (typically 15 minute slots) that can either be traded on the Day-ahead or in the Intraday market. Balancing market : imbalances that occur due to deviations between energy traded in the spot market and actual energy consumption and production are absorbed by balance responsible parties (BRP) that are reimbursed for their service with a fee based on the energy deviation. Futures market : trades for the longer term future consumption and production of energy are agreed in advance. This market is currently outside the scope of Grid Singularity energy exchange implementation. The current implementation of Grid Singularity software focuses on the spot and balancing markets. Balancing markets take place immediately after each spot market slot (if enabled). The duration of the markets can be configured. Currently, three spot market types are implemented: One-sided Pay-as-Offer Two-sided Pay-as-Bid Two-sided Pay-as-Clear Market Slots \u00b6 The energy spot market is broken into time slots, with the default set to 15 minutes of simulated time. For a one-day simulation, 96 market slots would occur with the default setting. Learn how to adjust market slot length here . Depending on the market type, bids and offers are either matched within or at the end of each slot. Bids and offers that remain unmatched at the end of a market slot are annulled, and assets may be penalised for any energy they physically produce or consume that is not transacted for. Market Ticks \u00b6 Each slot is further segmented into ticks. The default setting for a tick is 15 seconds of simulated time (simulated time is the time unit within a simulation as opposed to real-time which is the real-life time that the simulation takes; e.g. a simulation can simulate 7 days of trading in minutes or hours), and this configuration may be changed. The default 15 minute market slot is made up of 60 15-second ticks. In a pay-as-bid market, the market is cleared at the end of each tick. If an order is not matched, it is propagated to all adjacent markets by an Inter-Area Agent after two ticks. If an order is not matched at the end of two next ticks, it is further propagated to connected markets in the subsequent ticks following the same logic.","title":"Market Types: Spot, Balancing, and Futures"},{"location":"markets/#market-types","text":"The main goal of an electricity market exchange is to balance the grid in terms of demand and supply. Since efficient storage of large quantities of energy is currently not economically feasible and electrical current varies within seconds, a market mechanism that efficiently accounts for the physical energy production and consumption is required. Generally, trading occurs in three types of markets with different time intervals: Spot market : short-term trades for immediate or near-term delivery. Energy transactions are divided into small time blocks (typically 15 minute slots) that can either be traded on the Day-ahead or in the Intraday market. Balancing market : imbalances that occur due to deviations between energy traded in the spot market and actual energy consumption and production are absorbed by balance responsible parties (BRP) that are reimbursed for their service with a fee based on the energy deviation. Futures market : trades for the longer term future consumption and production of energy are agreed in advance. This market is currently outside the scope of Grid Singularity energy exchange implementation. The current implementation of Grid Singularity software focuses on the spot and balancing markets. Balancing markets take place immediately after each spot market slot (if enabled). The duration of the markets can be configured. Currently, three spot market types are implemented: One-sided Pay-as-Offer Two-sided Pay-as-Bid Two-sided Pay-as-Clear","title":"Market Types"},{"location":"markets/#market-slots","text":"The energy spot market is broken into time slots, with the default set to 15 minutes of simulated time. For a one-day simulation, 96 market slots would occur with the default setting. Learn how to adjust market slot length here . Depending on the market type, bids and offers are either matched within or at the end of each slot. Bids and offers that remain unmatched at the end of a market slot are annulled, and assets may be penalised for any energy they physically produce or consume that is not transacted for.","title":"Market Slots"},{"location":"markets/#market-ticks","text":"Each slot is further segmented into ticks. The default setting for a tick is 15 seconds of simulated time (simulated time is the time unit within a simulation as opposed to real-time which is the real-life time that the simulation takes; e.g. a simulation can simulate 7 days of trading in minutes or hours), and this configuration may be changed. The default 15 minute market slot is made up of 60 15-second ticks. In a pay-as-bid market, the market is cleared at the end of each tick. If an order is not matched, it is propagated to all adjacent markets by an Inter-Area Agent after two ticks. If an order is not matched at the end of two next ticks, it is further propagated to connected markets in the subsequent ticks following the same logic.","title":"Market Ticks"},{"location":"model-load/","text":"The load is an energy asset that consumes energy over time. It is possible to use a single load to represent an entire consuming building, as well as to configure multiple loads to represent different assets within a building (e.g. washing machine, air-conditioner, etc.). User Interface Configuration \u00b6 The following parameters can be configured: Load name : Must be unique Load profile : The user can choose between two options: User upload profile (a load profile can be uploaded when compliant with Upload File Formats) User configure profile (the user provides the load average power) Average power : average consuming power of the load in Watts. Hours per day : The number of hours the load operates per day. Hours of day : The time range in which the load operates. Initial buying rate : Initial energy buying rate at the beginning of each market slot in cents/kWh. Final buying rate : Final energy buying rate at the end of each market slot in cents/kWh. It can either be a user-defined value or equal to the Market Maker + Grid Fee. Rate increase : Explicit rate increase increment per update interval in cents/kWh Fit to limits : Derive bidding behavior from a linear fitted curve of a buying rate between initial_buying_rate and final_buying_rate within the bidding interval. If activated, energy rate_increase = (final_buying_rate - initial_buying_rate) / max(int((slot_length / update_interval) -1), 1) Update interval : The frequency at which the rate is updated. The Load configuration interface is shown below: Backend Configuration \u00b6 To implement the load in a backend simulation, two options are available : User configure Profile Market ( 'Load' , strategy = LoadHoursStrategy ( avg_power_W = 200 , hrs_per_day = 6 , hrs_of_day = list ( range ( 12 , 18 )), initial_buying_rate = 0 , final_buying_rate = 35 )) User upload Profile user_profile_path = os . path . join ( d3a_path , \"assets/load.csv\" ) Market ( 'Load' , strategy = LoadProfileStrategy ( daily_load_profile = user_profile_path , initial_buying_rate = 0 , final_buying_rate = 35 )) Addendum: hrs_of_day and hrs_per_day \u00b6 hrs_of_day defines the allowed time-window in which the load has to consume for a time defined by hrs_per_day. For example, a user can input 5 hrs_per_day and give a wider range for hrs_of_day like (2,18). The Load will try to consume as fast as possible during this time if there is any offered energy to purchase within the limits of initial_buying_rate and final_buying_rate set parameters. If there is sufficient energy at affordable rates, the load will consume in the first 5 hours, i.e. from 02:00 until 07:00, with no energy demand unmatched. In case energy prices are too high during the time-interval from 04:00 to 16:00, the load will consume from 02:00 until 04:00, turn off, and consume from 16:00 until 18:00, resulting in one hour of energy demand unmatched. For information on changes in buying and selling rates, please see: Trading strategies","title":"Load"},{"location":"model-load/#user-interface-configuration","text":"The following parameters can be configured: Load name : Must be unique Load profile : The user can choose between two options: User upload profile (a load profile can be uploaded when compliant with Upload File Formats) User configure profile (the user provides the load average power) Average power : average consuming power of the load in Watts. Hours per day : The number of hours the load operates per day. Hours of day : The time range in which the load operates. Initial buying rate : Initial energy buying rate at the beginning of each market slot in cents/kWh. Final buying rate : Final energy buying rate at the end of each market slot in cents/kWh. It can either be a user-defined value or equal to the Market Maker + Grid Fee. Rate increase : Explicit rate increase increment per update interval in cents/kWh Fit to limits : Derive bidding behavior from a linear fitted curve of a buying rate between initial_buying_rate and final_buying_rate within the bidding interval. If activated, energy rate_increase = (final_buying_rate - initial_buying_rate) / max(int((slot_length / update_interval) -1), 1) Update interval : The frequency at which the rate is updated. The Load configuration interface is shown below:","title":"User Interface Configuration"},{"location":"model-load/#backend-configuration","text":"To implement the load in a backend simulation, two options are available : User configure Profile Market ( 'Load' , strategy = LoadHoursStrategy ( avg_power_W = 200 , hrs_per_day = 6 , hrs_of_day = list ( range ( 12 , 18 )), initial_buying_rate = 0 , final_buying_rate = 35 )) User upload Profile user_profile_path = os . path . join ( d3a_path , \"assets/load.csv\" ) Market ( 'Load' , strategy = LoadProfileStrategy ( daily_load_profile = user_profile_path , initial_buying_rate = 0 , final_buying_rate = 35 ))","title":"Backend Configuration"},{"location":"model-load/#addendum-hrs_of_day-and-hrs_per_day","text":"hrs_of_day defines the allowed time-window in which the load has to consume for a time defined by hrs_per_day. For example, a user can input 5 hrs_per_day and give a wider range for hrs_of_day like (2,18). The Load will try to consume as fast as possible during this time if there is any offered energy to purchase within the limits of initial_buying_rate and final_buying_rate set parameters. If there is sufficient energy at affordable rates, the load will consume in the first 5 hours, i.e. from 02:00 until 07:00, with no energy demand unmatched. In case energy prices are too high during the time-interval from 04:00 to 16:00, the load will consume from 02:00 until 04:00, turn off, and consume from 16:00 until 18:00, resulting in one hour of energy demand unmatched. For information on changes in buying and selling rates, please see: Trading strategies","title":"Addendum: hrs_of_day and hrs_per_day"},{"location":"model-market-maker/","text":"The Market Maker mimics the behaviour of a typical energy utility and is used as a price reference point. Only one Market Maker can be set per simulation. The Market Maker can be configured to sell an infinite amount of energy as well as to buy an infinite amount of energy to simulate a Feed-in Tariff. User Interface Configuration \u00b6 The following parameters can be set: Name : The name of the Market Maker. Mode : The user has two options: Infinite power plant: In this mode, it has the ability to meet the infinite energy demand of consumers at the highest rate possible in that grid. Infinite bus: In this mode, the Market Maker has not only the ability to meet the infinite energy demand of the consumer but can also absorb the infinite generation surplus of prosumers/producers at the lowest rate possible in that grid. Role : The user has two options: Grid connected : In this mode, the Market Maker is connected to the grid and thus can fulfil the energy demand of any consumer and absorb surplus generation (if infinite bus mode selected) Islanded : In this mode, the Market Maker would only be used as a reference point for the highest possible energy_rate in that grid. Selling rate type : The user can either select User Input to define a fixed selling rate or upload their custom selling rate profile. Selling rate : The fixed rate the Market Maker will enforce, if User Input is chosen for the selling rate type. Buying rate type (infinite bus only) : The user can either select User Input to define a fixed buying rate or upload their custom buying rate profile. Buying rate (infinite bus only) : The fixed rate the Market Maker will enforce, if User Input is chosen for the buying rate type. The Market Maker configuration interface is shown below: Backend Configuration \u00b6 To implement a market maker in a backend simulation, two methods are available : infinite power plant : Market ( 'Market Maker' , strategy = MarketMakerStrategy ( energy_rate = selling_rate , grid_connected = True )) infinite bus : Market ( 'Market Maker' , strategy = InfiniteBusStrategy ( energy_buy_rate = 22 , energy_sell_rate = 22 ))","title":"Market Maker and Infinite Bus"},{"location":"model-market-maker/#user-interface-configuration","text":"The following parameters can be set: Name : The name of the Market Maker. Mode : The user has two options: Infinite power plant: In this mode, it has the ability to meet the infinite energy demand of consumers at the highest rate possible in that grid. Infinite bus: In this mode, the Market Maker has not only the ability to meet the infinite energy demand of the consumer but can also absorb the infinite generation surplus of prosumers/producers at the lowest rate possible in that grid. Role : The user has two options: Grid connected : In this mode, the Market Maker is connected to the grid and thus can fulfil the energy demand of any consumer and absorb surplus generation (if infinite bus mode selected) Islanded : In this mode, the Market Maker would only be used as a reference point for the highest possible energy_rate in that grid. Selling rate type : The user can either select User Input to define a fixed selling rate or upload their custom selling rate profile. Selling rate : The fixed rate the Market Maker will enforce, if User Input is chosen for the selling rate type. Buying rate type (infinite bus only) : The user can either select User Input to define a fixed buying rate or upload their custom buying rate profile. Buying rate (infinite bus only) : The fixed rate the Market Maker will enforce, if User Input is chosen for the buying rate type. The Market Maker configuration interface is shown below:","title":"User Interface Configuration"},{"location":"model-market-maker/#backend-configuration","text":"To implement a market maker in a backend simulation, two methods are available : infinite power plant : Market ( 'Market Maker' , strategy = MarketMakerStrategy ( energy_rate = selling_rate , grid_connected = True )) infinite bus : Market ( 'Market Maker' , strategy = InfiniteBusStrategy ( energy_buy_rate = 22 , energy_sell_rate = 22 ))","title":"Backend Configuration"},{"location":"model-markets/","text":"Markets contain submarkets and energy assets. Energy assets can post bids and offers in their market. Markets are interconnected by inter-area agents in a hierarchical network, which pass bids and offers between markets until they are matched, following a select market clearing mechanism . User Interface configuration \u00b6 The following market parameters can be set: Name : Must be unique Grid fee : If set to yes and with a non-None value, a fee will be applied to each trade that passes through or is cleared in this market. The grid fee is either constant , expressed in cents/kWh, or variable , expressed as a share of total price in percentage terms (%) depending on the parameters set in the simulation general settings . Transformers capacity : Import and export limits of the transformer in kVA. In the current implementation these limits are purely visual indicators and do not limit actual import/export of the market. Baseline import/export : Allows the user to compare the current simulation imports/exports to a baseline, set in kWh. These values are used in the calculation of the Peak Percentage KPI . The simulation configuration interface is shown below: Backend configuration \u00b6 These parameters can be set in the backend in the Area / Market class : Area ( 'Market' , [ ... \"some assets here\" ], grid_fee_constant = 2 , throughput = ThroughputParameters ( import_capacity_kVA = 2.0 , export_capacity_kVA = 2.0 , baseline_peak_energy_import_kWh = 0.4 , baseline_peak_energy_export_kWh = 0.4 ))","title":"Market Settings"},{"location":"model-markets/#user-interface-configuration","text":"The following market parameters can be set: Name : Must be unique Grid fee : If set to yes and with a non-None value, a fee will be applied to each trade that passes through or is cleared in this market. The grid fee is either constant , expressed in cents/kWh, or variable , expressed as a share of total price in percentage terms (%) depending on the parameters set in the simulation general settings . Transformers capacity : Import and export limits of the transformer in kVA. In the current implementation these limits are purely visual indicators and do not limit actual import/export of the market. Baseline import/export : Allows the user to compare the current simulation imports/exports to a baseline, set in kWh. These values are used in the calculation of the Peak Percentage KPI . The simulation configuration interface is shown below:","title":"User Interface configuration"},{"location":"model-markets/#backend-configuration","text":"These parameters can be set in the backend in the Area / Market class : Area ( 'Market' , [ ... \"some assets here\" ], grid_fee_constant = 2 , throughput = ThroughputParameters ( import_capacity_kVA = 2.0 , export_capacity_kVA = 2.0 , baseline_peak_energy_import_kWh = 0.4 , baseline_peak_energy_export_kWh = 0.4 ))","title":"Backend configuration"},{"location":"model-power-plant/","text":"A finite power plant is an energy supplier that offers a configurable amount of power per time slot at a set rate. User Interface Configuration \u00b6 The following parameters can be configured: Name : Must be unique. Energy rate : Selling price of the power plant in cents/kWh. Maximum available power : Maximum power that the power plant can supply in kW (in the backend this parameter can also be set based on an uploaded profile). The configuration interface is shown below: Backend Configuration \u00b6 To implement the power plant in a backend simulation one option is available: Finite Power Plant profile_kW = { 0 : 0.1 , 8 : 0.15 , 12 : 0.2 , 19 : 0.15 , 22 : 0.1 } Market ( \"Power Plant', strategy=FinitePowerPlant(energy_rate=31.3, max_available_power_kW=profile_kW))","title":"Power Plant"},{"location":"model-power-plant/#user-interface-configuration","text":"The following parameters can be configured: Name : Must be unique. Energy rate : Selling price of the power plant in cents/kWh. Maximum available power : Maximum power that the power plant can supply in kW (in the backend this parameter can also be set based on an uploaded profile). The configuration interface is shown below:","title":"User Interface Configuration"},{"location":"model-power-plant/#backend-configuration","text":"To implement the power plant in a backend simulation one option is available: Finite Power Plant profile_kW = { 0 : 0.1 , 8 : 0.15 , 12 : 0.2 , 19 : 0.15 , 22 : 0.1 } Market ( \"Power Plant', strategy=FinitePowerPlant(energy_rate=31.3, max_available_power_kW=profile_kW))","title":"Backend Configuration"},{"location":"model-pv/","text":"A photovoltaic (PV) is an energy asset that converts solar irradiation into electricity. In our software, each PV component can represent a single panel, array of panels or an entire PV park. User Interface Configuration \u00b6 The following parameters can be configured: Name : Must be unique Panel count : Number of PV panels, each with a power of 250W. Solar Profile : The user can choose among multiple template solar profiles (sunny, partially cloudy or cloudy). The usery can also create a custom Gaussian curve or upload their own generation profile. Initial selling rate : Initial (and maximum) energy rate that the PV offers at the beginning of each market slot in cents/kWh. Final selling rate : Final energy rate that the PV offers at the end of each market slot in cents/kWh. Rate decrease : Explicit rate decrease increment in cents/kWh. Fit to limits : Derive bidding behavior from a linear fitted curve of a selling rate ranging from initial_selling_rate to final_selling_rate within the bidding interval. If activated, energy_rate_decrease_per_update = (initial_selling_rate - final_selling_rate) / max(int((slot_length / update_interval) -1), 1) Update interval : The frequency at which the rate is updated. The PV configuration interface is shown in the figure below: Backend Configuration \u00b6 There are two options to implement a PV in a backend: Solar Profile (for template generation profile) Market ( 'H2 PV' , strategy = PVStrategy ( panel_count = 4 , initial_selling_rate = 30 , final_selling_rate = 5 , fit_to_limit = True , update_interval = duration ( minutes = 5 ))) User Profile (for uploaded generation profile) user_profile_path = os . path . join ( d3a_path , \"assets/Solar_Curve_W_sunny.csv\" ) Market ( 'H1 PV' , strategy = PVUserProfileStrategy ( power_profile = user_profile_path , panel_count = ))","title":"PV"},{"location":"model-pv/#user-interface-configuration","text":"The following parameters can be configured: Name : Must be unique Panel count : Number of PV panels, each with a power of 250W. Solar Profile : The user can choose among multiple template solar profiles (sunny, partially cloudy or cloudy). The usery can also create a custom Gaussian curve or upload their own generation profile. Initial selling rate : Initial (and maximum) energy rate that the PV offers at the beginning of each market slot in cents/kWh. Final selling rate : Final energy rate that the PV offers at the end of each market slot in cents/kWh. Rate decrease : Explicit rate decrease increment in cents/kWh. Fit to limits : Derive bidding behavior from a linear fitted curve of a selling rate ranging from initial_selling_rate to final_selling_rate within the bidding interval. If activated, energy_rate_decrease_per_update = (initial_selling_rate - final_selling_rate) / max(int((slot_length / update_interval) -1), 1) Update interval : The frequency at which the rate is updated. The PV configuration interface is shown in the figure below:","title":"User Interface Configuration"},{"location":"model-pv/#backend-configuration","text":"There are two options to implement a PV in a backend: Solar Profile (for template generation profile) Market ( 'H2 PV' , strategy = PVStrategy ( panel_count = 4 , initial_selling_rate = 30 , final_selling_rate = 5 , fit_to_limit = True , update_interval = duration ( minutes = 5 ))) User Profile (for uploaded generation profile) user_profile_path = os . path . join ( d3a_path , \"assets/Solar_Curve_W_sunny.csv\" ) Market ( 'H1 PV' , strategy = PVUserProfileStrategy ( power_profile = user_profile_path , panel_count = ))","title":"Backend Configuration"},{"location":"model-storage/","text":"The storage simulates energy assets capable of storing or discharging energy (e.g. Lithium batteries, compressed air energy storage). User Interface Configuration \u00b6 The following parameters can be configured: Name : Must be unique Battery capacity : Total energy capacity. Initial capacity : Can be set in two ways: Initial State of Charge - SOC (in %) Initial Energy (in kWh) Minimum SOC : Minimum energy to leave in the storage. Max power rating for battery : Power limit for each market slot for sold and bought energy. Initial selling rate : Initial energy rate for selling energy at the beginning of each market slot in cents/kWh. Final selling rate : Final energy rate for selling energy at the end of each market slot in cents/kWh. Rate decrease : Explicit rate decrease increment in cents/kWh. Initial buying rate : Initial energy rate for buying energy at the beginning of each market slot in cents/kWh. Final buying rate : Final energy rate for buying energy at the end of each market slot in cents/kWh. Rate increase : Explicit rate increase increment in cents/kWh. Fit to limits : Derive bidding behavior from a linear fitted curve of a buying rate between initial_buying_rate and final_buying_rate and a selling rate between initial_selling_rate and final_selling_rate within the bidding interval. If activated: energy_rate_increase = (final_buying_rate - initial_buying_rate) / max(int((slot_length / update_interval) -1), 1) energy_rate_decrease_per_update = (initial_selling_rate - final_selling_rate) / max(int((slot_length / update_interval) -1), 1) Update interval : The frequency at which the rate is updated. Capacity based method : The storage can trade energy based on a capacity dependent sell price (see addendum). Note: For the time being, the storage component has a 100% electric-to-electric efficiency by default. Changing this characteristic is not possible at the moment but it will be possible in the near future. Users are welcome to add additional features to our open source code base on GitHub. The storage configuration interface is shown below: Backend Configuration \u00b6 To implement the storage in a backend simulation one option is available: Energy Storage System Market ( 'Storage' , strategy = StorageStrategy ( initial_soc = 50 , energy_rate_decrease_per_update = 3 , battery_capacity_kWh = 1.2 , max_abs_battery_power_kW = 5 , final_buying_rate = 16.99 , final_selling_rate = 17.01 ))) Addendum: Storage Capacity Based Method \u00b6 This method was created to sell energy at lower prices during high state of charge - SOC (when the battery has more energy stored) and at higher prices during low SOC (when the battery can afford to sell its stored energy for less). If the cap_price_strategy is True , the offer price for the storage is calculated according to: offer_rate = initial_selling_rate - ((initial_selling_rate - final_selling_rate)\\*soc/100) As an example, considering an initial_selling_rate of 30 cents/kWh and a final_selling_rate of 20 cents/kWh, a storage with an SOC of 1% would sell its energy at 29.9 cents/kWh, and a battery at 100% SOC would sell its energy at 20 cents/kWh. Storage Behaviour in Local Energy Markets \u00b6 In general all bids and offers follow the physical constraint of the set max_abs_battery_power_kW value. The accumulated energy per market slot cannot exceed this power value times the length of the market slot. Energy sold and bought cancel each other out, meaning that if 2kWh are both sold and bought in the same market slot, the relative power remains 0kW. For the buying rate increase and selling rate decrease behaviour, please see the Trading Strategies page . Buying Energy in One-Sided Market : \u00b6 On each tick, the storage scans the connected market for affordable offers* if there is storage space to be filled (if the current SOC is lower than 100%). Once an offer is found, it is either fully or partially accepted, depending on the demand. The storage always seeks 100% SOC when buying energy. = affordable offers are offers that have a price lower or equal to the current acceptable energy rate. The acceptable energy rate changes during a market slot depending on the initial_buying_rate , final_buying_rate , energy_rate_decrease_per_update and update_interval setting. Buying Energy in Two-Sided Market : \u00b6 On each tick, the storage either places a bid for the quantity of energy it needs to reach 100% SOC or updates the price of an existing bid in the market where the bid rate depends on the initial_buying_rate , final_buying_rate , energy_rate_decrease_per_update and update_interval setting. Selling Energy \u00b6 At the beginning of each market slot, the storage places an offer for all the energy it has stored (not including the energy that is needed to keep the storage at least at min_allowed_soc). This offer is updated at each update_interval pursuant to the rate decrease settings. This mechanism applies in both one and two-sided market types. Consequently, it is possible for the storage to have both an offer and a bid placed in the same market.","title":"Storage"},{"location":"model-storage/#user-interface-configuration","text":"The following parameters can be configured: Name : Must be unique Battery capacity : Total energy capacity. Initial capacity : Can be set in two ways: Initial State of Charge - SOC (in %) Initial Energy (in kWh) Minimum SOC : Minimum energy to leave in the storage. Max power rating for battery : Power limit for each market slot for sold and bought energy. Initial selling rate : Initial energy rate for selling energy at the beginning of each market slot in cents/kWh. Final selling rate : Final energy rate for selling energy at the end of each market slot in cents/kWh. Rate decrease : Explicit rate decrease increment in cents/kWh. Initial buying rate : Initial energy rate for buying energy at the beginning of each market slot in cents/kWh. Final buying rate : Final energy rate for buying energy at the end of each market slot in cents/kWh. Rate increase : Explicit rate increase increment in cents/kWh. Fit to limits : Derive bidding behavior from a linear fitted curve of a buying rate between initial_buying_rate and final_buying_rate and a selling rate between initial_selling_rate and final_selling_rate within the bidding interval. If activated: energy_rate_increase = (final_buying_rate - initial_buying_rate) / max(int((slot_length / update_interval) -1), 1) energy_rate_decrease_per_update = (initial_selling_rate - final_selling_rate) / max(int((slot_length / update_interval) -1), 1) Update interval : The frequency at which the rate is updated. Capacity based method : The storage can trade energy based on a capacity dependent sell price (see addendum). Note: For the time being, the storage component has a 100% electric-to-electric efficiency by default. Changing this characteristic is not possible at the moment but it will be possible in the near future. Users are welcome to add additional features to our open source code base on GitHub. The storage configuration interface is shown below:","title":"User Interface Configuration"},{"location":"model-storage/#backend-configuration","text":"To implement the storage in a backend simulation one option is available: Energy Storage System Market ( 'Storage' , strategy = StorageStrategy ( initial_soc = 50 , energy_rate_decrease_per_update = 3 , battery_capacity_kWh = 1.2 , max_abs_battery_power_kW = 5 , final_buying_rate = 16.99 , final_selling_rate = 17.01 )))","title":"Backend Configuration"},{"location":"model-storage/#addendum-storage-capacity-based-method","text":"This method was created to sell energy at lower prices during high state of charge - SOC (when the battery has more energy stored) and at higher prices during low SOC (when the battery can afford to sell its stored energy for less). If the cap_price_strategy is True , the offer price for the storage is calculated according to: offer_rate = initial_selling_rate - ((initial_selling_rate - final_selling_rate)\\*soc/100) As an example, considering an initial_selling_rate of 30 cents/kWh and a final_selling_rate of 20 cents/kWh, a storage with an SOC of 1% would sell its energy at 29.9 cents/kWh, and a battery at 100% SOC would sell its energy at 20 cents/kWh.","title":"Addendum: Storage Capacity Based Method"},{"location":"model-storage/#storage-behaviour-in-local-energy-markets","text":"In general all bids and offers follow the physical constraint of the set max_abs_battery_power_kW value. The accumulated energy per market slot cannot exceed this power value times the length of the market slot. Energy sold and bought cancel each other out, meaning that if 2kWh are both sold and bought in the same market slot, the relative power remains 0kW. For the buying rate increase and selling rate decrease behaviour, please see the Trading Strategies page .","title":"Storage Behaviour in Local Energy Markets"},{"location":"model-storage/#buying-energy-in-one-sided-market","text":"On each tick, the storage scans the connected market for affordable offers* if there is storage space to be filled (if the current SOC is lower than 100%). Once an offer is found, it is either fully or partially accepted, depending on the demand. The storage always seeks 100% SOC when buying energy. = affordable offers are offers that have a price lower or equal to the current acceptable energy rate. The acceptable energy rate changes during a market slot depending on the initial_buying_rate , final_buying_rate , energy_rate_decrease_per_update and update_interval setting.","title":"Buying Energy in One-Sided Market:"},{"location":"model-storage/#buying-energy-in-two-sided-market","text":"On each tick, the storage either places a bid for the quantity of energy it needs to reach 100% SOC or updates the price of an existing bid in the market where the bid rate depends on the initial_buying_rate , final_buying_rate , energy_rate_decrease_per_update and update_interval setting.","title":"Buying Energy in Two-Sided Market:"},{"location":"model-storage/#selling-energy","text":"At the beginning of each market slot, the storage places an offer for all the energy it has stored (not including the energy that is needed to keep the storage at least at min_allowed_soc). This offer is updated at each update_interval pursuant to the rate decrease settings. This mechanism applies in both one and two-sided market types. Consequently, it is possible for the storage to have both an offer and a bid placed in the same market.","title":"Selling Energy"},{"location":"one-sided-pay-as-offer/","text":"In the One-Sided Pay-as-Offer market, agents representing energy producers, including prosumers ( sellers ) post offers in the market with an energy price determined by the assets' trading strategy . Agents representing consumers ( buyers ) can see the offers available in their local market, filter affordable offers and then select the most favorable offer. The energy rate on which the seller and buyer settle is the price of the offer (pay-as-offer). Consequently, the trade rate may differ for trades settled in the same slot. The auction is continuous , meaning that once an offer is posted, it can be accepted right away, even before the end of each market slot .","title":"One-Sided Pay-as-Offer Market"},{"location":"peak-percentage/","text":"The energy peak imports/exports is the maximum value of the aggregate imports/exports of each asset inside a market. The user has the possibility to set a baseline_peak_energy_import_kWh and a baseline_peak_energy_export_kWh that they may have gotten from another simulation in order to calculate the energy peak percentage, a tool used to measure how much the peak imports or exports have changed between a defined baseline and the current simulation. The user may be interested in the Energy Peak Percentage value to assess the impact of applied grid fees or different energy storage strategies on the peak imports and exports of a market. The Energy Peak Percentage can be calculated as follows : Import_peak_percentage = import_peak_energy_kWh / import_baseline_peak_energy_kWh * 100 Export_peak_percentage = export_peak_energy_kWh / export_baseline_peak_energy_kWh * 100 If the energy peak percentage is below 100% , the peak was reduced vs. the baseline. The energy peak was increased if the energy peak percentage value is above 100% .","title":"Peak Percentage"},{"location":"percentage-fees/","text":"The percentage grid fee is a market based fee, defined as a ratio (%) of the clearing price that is added to each trade that is cleared, as shown in the figure below. The price of a bid or offer changes as it is propagated into different markets to account for market fees. This way, a trading agent posting an offer will never receive less than offered and an agent making a bid will never pay more than bid. Example Calculation in One-Sided Pay-as-Offer Market \u00b6 In the One-Sided Pay-as-Offer market, there are no bids, only offers. The offers are propagated throughout the markets in the hierarchy. The grid fees are taken into account when an offer is forwarded to the higher market, by the higher market itself. Therefore the agent is not responsible for adapting the offer price to include the grid fees. The grid fees' unit is a ratio of the original offer price, therefore the formula to calculate the new offer price when placing an offer to a market is the following: offer_price_after_fees = offer_price + original_offer_price * grid_fee_ratio If the offer is not purchased after two ticks, it is moved into the next market, where the price is increased by that market\u2019s grid fee. In the provided example, the PV offer of 0.10\u20ac is first placed in the House 2 Market where it gains zero fees. Then it propagates into the Neighborhood 2 Market, gaining the market\u2019s fee of 5% of the original offer price 0.10*0.05+0.10=0.105\u20ac . If unmatched, it propagates into the Grid Market, with an additional 10% fee of the original offer is applied: 0.10*0.10+0.105=0.115\u20ac . Continuing into the Neighborhood 1 Market, the offer gains another fee of 5% of the original price 0.10*0.05+0.115=0.12\u20ac . Continuing into the House 1 Market, the offer gains zero additional fees as there is no fee in that market. The Load buys the offer in the House 1 Market at the Clearing Price of 0.12\u20ac. Starting with the initial offer price, the total fees are calculated 0.10*(1+0.05+0.10+0.05)=0.02 to yield the Trade Price of 0.12\u20ac. The Load pays the Trade Price of 0.12\u20ac, which includes 0.10\u20ac revenue for the PV, 0.005\u20ac fees for the Neighborhood Market 1, 0.01\u20ac fees for the Grid Market, and 0.005\u20ac fees for the Neighborhood Market 2. Since the market type is pay-as-offer, the offer rates are used as Clearing Rates. The trade price is then calculated by multiplying the clearing rate with the energy volume. For each market trade, the market grid fee is calculated based on the original offer rate and it is subtracted from the trade_price, in order to calculate the trade price after fees (and thus the revenue for the seller). The following formula is used: market_fees = grid_fee_ratio * original_rate * energy_portion trade_price_after_fees = energy * trade_rate - market_fees trade_price = energy * trade_rate Example Calculation in Two-Sided Pay-as-Bid Market \u00b6 In the Two-Sided Pay-as-Bid market, both bids and offers are propagated through the markets in the hierarchy. If a bid or offer is not purchased after two ticks , it propagates into the next market. In order to prevent double accounting of a market's grid fee when a bid and an offer are matched in that market, market fees are added to offers when they enter that market (target market) and subtracted from bids when they leave that market and enter another (source market). The formula for propagating the offers is the same as for the one-sided market: offer_price_after_fees = offer_price + original_offer_price * grid_fee_ratio The IAA subtracts the fees from the bid before propagating it to a higher market. The formula for an area to update the bid to include grid fees is the following: bid_price_after_fees = bid_price - original_bid_price * grid_fee_ratio In the case of the Two-Sided Pay-as-Bid market, the offer has moved into the Grid Market by the same mechanism as for the One-Sided Pay-as-Offer market. The bid of 0.30\u20ac follows a similar mechanism and is placed into the House 1 Market where there are zero fees. If the bid is not purchased after two ticks, it is moved into the Neighborhood 1 Market. As explained above, only the fees from the source market are added, which are zero in this case. Hence the bid remains at 0.30\u20ac. Next, the bid is moved to the Grid Market, and incurs the fees of the source market, the Neighborhood 1 Market of 5% to 0.30-0.30*0.05=0.285\u20ac . In the example above, the bid and offer are matched in the Grid Market. When the offer entered the Grid Market, its price was immediately updated to account for the Grid Market's fees 0.10*0.10+0.105=0.115\u20ac . The bid, however, did not add the 10% fee as only the fees from the source markets are added. In the case that the bid was not matched in the Grid Market and moved into the Neighborhood 2 Market, the 10% fee from the Grid Market would be added to the bid. In this case, the bid would become 0.285-0.30*0.10=0.255\u20ac . In the Grid Market, the Load bid is listed as 0.285\u20ac and the PV offer is listed as 0.115\u20ac. As the bid rate is greater than the offer rate, a trade can be scheduled. The trade clears at the bid rate, resulting in a Clearing Price of 0.285\u20ac. The algorithm to calculate the final grid fees for each trade is decentralised, allowing the markets to act more independently without having to share information regarding their fees with other markets. In order to calculate the fee correctly based on the original price, the algorithm needs to be able to calculate the supply side and demand side fee. It is easily calculated using the most recent forwarded rate and the original bid or offer rate: demand_side_fee = 1 - (forwarded_bid_rate / original_bid_rate) supply_side_fee = (forwarded_offer_rate / original_offer_rate) - 1 The provided example has the following values: supply_side_fee=(0.115/0.1)-1=0.15 demand_side_fee=1-(0.285/0.3)=0.05 After calculating the supply and the demand side fee, the trade revenue can be determined. Note the original_trade_rate is the amount that the original buyer (in our case the Load) will need to pay, and therefore the original bid price in a Pay-as-Bid market. The formula is the following: total_fee_ratio = supply_side_fee + demand_side_fee revenue = original_trade_rate / (1 + total_fee_ratio) In the provided example, revenue = 0.30/(1+0.15+0.05)=0.25 The grid fees are then calculated based on the revenue and the individual market fees: fees = revenue * grid_fee_ratio For the Grid Market in the provided example, the fees are 0.25*0.1=0.025 , and for each Neighborhood market, the fees are 0.25*0.05=0.0125 . Finally, the trade rate is adapted according to include the supply side grid fee, in order to include the fees of the current market: trade_rate = revenue * (1 + supply_side_fee) trade_price = energy * trade_rate In the provided example, the trade price for each market is: Grid Market = 0.25 * (1 + 0.15) = 0.2875 Neighborhood 2 Market = 0.25 * (1 + 0.05) = 0.2625 Neighborhood 1 Market = 0.25 * (1 + 0.2) = 0.3 House 1 Market = 0.25 * (1 + 0.2) = 0.3 House 2 Market = 0.25 * (1 + 0) = 0.25 The Load pays the Trade Price of 0.30\u20ac, which includes 0.25\u20ac revenue for the PV, 0.0125\u20ac fees for the Neighborhood Market 1, 0.025\u20ac fees for the Grid Market, and 0.0125\u20ac fees for the Neighborhood Market 2. Example Calculation in Two-Sided Pay-as-Clear Market \u00b6 This market clearing type is currently in development. We welcome your suggestions on its design!","title":"Percentage Grid Fee Calculation"},{"location":"percentage-fees/#example-calculation-in-one-sided-pay-as-offer-market","text":"In the One-Sided Pay-as-Offer market, there are no bids, only offers. The offers are propagated throughout the markets in the hierarchy. The grid fees are taken into account when an offer is forwarded to the higher market, by the higher market itself. Therefore the agent is not responsible for adapting the offer price to include the grid fees. The grid fees' unit is a ratio of the original offer price, therefore the formula to calculate the new offer price when placing an offer to a market is the following: offer_price_after_fees = offer_price + original_offer_price * grid_fee_ratio If the offer is not purchased after two ticks, it is moved into the next market, where the price is increased by that market\u2019s grid fee. In the provided example, the PV offer of 0.10\u20ac is first placed in the House 2 Market where it gains zero fees. Then it propagates into the Neighborhood 2 Market, gaining the market\u2019s fee of 5% of the original offer price 0.10*0.05+0.10=0.105\u20ac . If unmatched, it propagates into the Grid Market, with an additional 10% fee of the original offer is applied: 0.10*0.10+0.105=0.115\u20ac . Continuing into the Neighborhood 1 Market, the offer gains another fee of 5% of the original price 0.10*0.05+0.115=0.12\u20ac . Continuing into the House 1 Market, the offer gains zero additional fees as there is no fee in that market. The Load buys the offer in the House 1 Market at the Clearing Price of 0.12\u20ac. Starting with the initial offer price, the total fees are calculated 0.10*(1+0.05+0.10+0.05)=0.02 to yield the Trade Price of 0.12\u20ac. The Load pays the Trade Price of 0.12\u20ac, which includes 0.10\u20ac revenue for the PV, 0.005\u20ac fees for the Neighborhood Market 1, 0.01\u20ac fees for the Grid Market, and 0.005\u20ac fees for the Neighborhood Market 2. Since the market type is pay-as-offer, the offer rates are used as Clearing Rates. The trade price is then calculated by multiplying the clearing rate with the energy volume. For each market trade, the market grid fee is calculated based on the original offer rate and it is subtracted from the trade_price, in order to calculate the trade price after fees (and thus the revenue for the seller). The following formula is used: market_fees = grid_fee_ratio * original_rate * energy_portion trade_price_after_fees = energy * trade_rate - market_fees trade_price = energy * trade_rate","title":"Example Calculation in One-Sided Pay-as-Offer Market"},{"location":"percentage-fees/#example-calculation-in-two-sided-pay-as-bid-market","text":"In the Two-Sided Pay-as-Bid market, both bids and offers are propagated through the markets in the hierarchy. If a bid or offer is not purchased after two ticks , it propagates into the next market. In order to prevent double accounting of a market's grid fee when a bid and an offer are matched in that market, market fees are added to offers when they enter that market (target market) and subtracted from bids when they leave that market and enter another (source market). The formula for propagating the offers is the same as for the one-sided market: offer_price_after_fees = offer_price + original_offer_price * grid_fee_ratio The IAA subtracts the fees from the bid before propagating it to a higher market. The formula for an area to update the bid to include grid fees is the following: bid_price_after_fees = bid_price - original_bid_price * grid_fee_ratio In the case of the Two-Sided Pay-as-Bid market, the offer has moved into the Grid Market by the same mechanism as for the One-Sided Pay-as-Offer market. The bid of 0.30\u20ac follows a similar mechanism and is placed into the House 1 Market where there are zero fees. If the bid is not purchased after two ticks, it is moved into the Neighborhood 1 Market. As explained above, only the fees from the source market are added, which are zero in this case. Hence the bid remains at 0.30\u20ac. Next, the bid is moved to the Grid Market, and incurs the fees of the source market, the Neighborhood 1 Market of 5% to 0.30-0.30*0.05=0.285\u20ac . In the example above, the bid and offer are matched in the Grid Market. When the offer entered the Grid Market, its price was immediately updated to account for the Grid Market's fees 0.10*0.10+0.105=0.115\u20ac . The bid, however, did not add the 10% fee as only the fees from the source markets are added. In the case that the bid was not matched in the Grid Market and moved into the Neighborhood 2 Market, the 10% fee from the Grid Market would be added to the bid. In this case, the bid would become 0.285-0.30*0.10=0.255\u20ac . In the Grid Market, the Load bid is listed as 0.285\u20ac and the PV offer is listed as 0.115\u20ac. As the bid rate is greater than the offer rate, a trade can be scheduled. The trade clears at the bid rate, resulting in a Clearing Price of 0.285\u20ac. The algorithm to calculate the final grid fees for each trade is decentralised, allowing the markets to act more independently without having to share information regarding their fees with other markets. In order to calculate the fee correctly based on the original price, the algorithm needs to be able to calculate the supply side and demand side fee. It is easily calculated using the most recent forwarded rate and the original bid or offer rate: demand_side_fee = 1 - (forwarded_bid_rate / original_bid_rate) supply_side_fee = (forwarded_offer_rate / original_offer_rate) - 1 The provided example has the following values: supply_side_fee=(0.115/0.1)-1=0.15 demand_side_fee=1-(0.285/0.3)=0.05 After calculating the supply and the demand side fee, the trade revenue can be determined. Note the original_trade_rate is the amount that the original buyer (in our case the Load) will need to pay, and therefore the original bid price in a Pay-as-Bid market. The formula is the following: total_fee_ratio = supply_side_fee + demand_side_fee revenue = original_trade_rate / (1 + total_fee_ratio) In the provided example, revenue = 0.30/(1+0.15+0.05)=0.25 The grid fees are then calculated based on the revenue and the individual market fees: fees = revenue * grid_fee_ratio For the Grid Market in the provided example, the fees are 0.25*0.1=0.025 , and for each Neighborhood market, the fees are 0.25*0.05=0.0125 . Finally, the trade rate is adapted according to include the supply side grid fee, in order to include the fees of the current market: trade_rate = revenue * (1 + supply_side_fee) trade_price = energy * trade_rate In the provided example, the trade price for each market is: Grid Market = 0.25 * (1 + 0.15) = 0.2875 Neighborhood 2 Market = 0.25 * (1 + 0.05) = 0.2625 Neighborhood 1 Market = 0.25 * (1 + 0.2) = 0.3 House 1 Market = 0.25 * (1 + 0.2) = 0.3 House 2 Market = 0.25 * (1 + 0) = 0.25 The Load pays the Trade Price of 0.30\u20ac, which includes 0.25\u20ac revenue for the PV, 0.0125\u20ac fees for the Neighborhood Market 1, 0.025\u20ac fees for the Grid Market, and 0.0125\u20ac fees for the Neighborhood Market 2.","title":"Example Calculation in Two-Sided Pay-as-Bid Market"},{"location":"percentage-fees/#example-calculation-in-two-sided-pay-as-clear-market","text":"This market clearing type is currently in development. We welcome your suggestions on its design!","title":"Example Calculation in Two-Sided Pay-as-Clear Market"},{"location":"references/","text":"Grid Singularity Medium articles \u00b6 Grid Singularity. (September 23, 2019). An Energy Exchange Engine for Local Energy Marketplaces , https://gridsingularity.medium.com/an-energy-exchange-engine-for-local-energy-marketplaces-28d5be23705e Grid Singularity. (February 17, 2020). Stakeholders\u2019 Interest in Energy Market Design Innovation; Key Takeaways from the Odyssey Connect Energy Singularity Panel , https://gridsingularity.medium.com/stakeholders-interest-in-energy-market-design-innovation-key-takeaways-from-the-odyssey-connect-a6d18056ab34 Grid Singularity. (February 21, 2020). A Case for Flexibility Markets Enabled by Local Peer-to-Peer Exchanges , https://gridsingularity.medium.com/a-case-for-flexibility-markets-enabled-by-local-peer-to-peer-exchanges-43300b625cb5 Grid Singularity. (April 1, 2020). Energy Communities: a Game Changer for the European Electricity Grid , https://gridsingularity.medium.com/energy-communities-a-game-changer-for-the-european-electricity-grid-fd588a3063b0 Grid Singularity. (April 14, 2020). Deploying Local Electricity Markets to Optimise PV Integration; A Study of Three LEM Scenarios in Germany , https://gridsingularity.medium.com/deploying-local-electricity-markets-to-optimise-pv-integration-a-study-of-three-lem-scenarios-in-cf125b26f4dc Grid Singularity. (June 18, 2020). Analysis of Local Electricity Markets as a Platform to Modernise Consumer and Grid Interaction , https://gridsingularity.medium.com/analysis-of-local-electricity-markets-as-a-platform-to-modernise-consumer-and-grid-interaction-3fff63ef74e7 Grid Singularity. (August 27, 2020). Modelling study to assess the potential benefits of trading in and between local energy communities in Germany , https://gridsingularity.medium.com/modelling-study-to-assess-the-potential-benefits-of-trading-in-and-between-local-energy-d721395ddd4b Grid Singularity. (September 10, 2020). En Route to Energy Singularity Odyssey Momentum: Learnings from the 2020 Chaos Experiment , https://gridsingularity.medium.com/en-route-to-energy-singularity-odyssey-momentum-learnings-from-the-2020-chaos-experiment-8dc38ff26869 Grid Singularity. (November 25, 2020). Energy Singularity Challenge 2020: Social Energy Networks , https://gridsingularity.medium.com/energy-singularity-challenge-2020-social-energy-networks-157b390e5f39 Grid Singularity. (December 10, 2020). Energy Singularity Challenge 2020: Testing Novel Grid Fee Models and Intelligent Peer-to-Peer Trading Strategies , https://gridsingularity.medium.com/energy-singularity-challenge-2020-testing-novel-grid-fee-models-and-intelligent-peer-to-peer-6a0d715a9063 Books \u00b6 Ana Trbovich, Sarah Hambridge, Dirk van den Biggelaar, Ewald Hesse, Fereidoon Sioshansi, Chapter 13 - D3A energy exchange for a transactive grid, Editor(s): Fereidoon Sioshansi, Behind and Beyond the Meter, Academic Press, 2020, Pages 267-284, ISBN 9780128199510, https://doi.org/10.1016/B978-0-12-819951-0.00013-X . (http://www.sciencedirect.com/science/article/pii/B978012819951000013X) Scientific articles and studies \u00b6 BBEn, 100 prozent erneuerbar stiftung, Grid Singularity, Neue Kraft mit der Nachbarschaft , October 2020, https://www.buendnis-buergerenergie.de/fileadmin/nkmdn_Lokale_Strommaerkte.pdf Trbovich, Ana S. \u2018In Pursuit of Good Governance for the Energy Industry Blockchain\u2019. Journal of Energy Markets , May 2019, https://www.risk.net/node/6637136 . Danzi, P. Hambridge,S. Stefanovi\u0107, \u010c. Popovski,P. \u2018Blockchain-Based and Multi-Layered Electricity Imbalance Settlement Architecture\u2019. IEEE, December 27,2018. https://ieeexplore.ieee.org/abstract/document/8587577/references#references","title":"References"},{"location":"references/#grid-singularity-medium-articles","text":"Grid Singularity. (September 23, 2019). An Energy Exchange Engine for Local Energy Marketplaces , https://gridsingularity.medium.com/an-energy-exchange-engine-for-local-energy-marketplaces-28d5be23705e Grid Singularity. (February 17, 2020). Stakeholders\u2019 Interest in Energy Market Design Innovation; Key Takeaways from the Odyssey Connect Energy Singularity Panel , https://gridsingularity.medium.com/stakeholders-interest-in-energy-market-design-innovation-key-takeaways-from-the-odyssey-connect-a6d18056ab34 Grid Singularity. (February 21, 2020). A Case for Flexibility Markets Enabled by Local Peer-to-Peer Exchanges , https://gridsingularity.medium.com/a-case-for-flexibility-markets-enabled-by-local-peer-to-peer-exchanges-43300b625cb5 Grid Singularity. (April 1, 2020). Energy Communities: a Game Changer for the European Electricity Grid , https://gridsingularity.medium.com/energy-communities-a-game-changer-for-the-european-electricity-grid-fd588a3063b0 Grid Singularity. (April 14, 2020). Deploying Local Electricity Markets to Optimise PV Integration; A Study of Three LEM Scenarios in Germany , https://gridsingularity.medium.com/deploying-local-electricity-markets-to-optimise-pv-integration-a-study-of-three-lem-scenarios-in-cf125b26f4dc Grid Singularity. (June 18, 2020). Analysis of Local Electricity Markets as a Platform to Modernise Consumer and Grid Interaction , https://gridsingularity.medium.com/analysis-of-local-electricity-markets-as-a-platform-to-modernise-consumer-and-grid-interaction-3fff63ef74e7 Grid Singularity. (August 27, 2020). Modelling study to assess the potential benefits of trading in and between local energy communities in Germany , https://gridsingularity.medium.com/modelling-study-to-assess-the-potential-benefits-of-trading-in-and-between-local-energy-d721395ddd4b Grid Singularity. (September 10, 2020). En Route to Energy Singularity Odyssey Momentum: Learnings from the 2020 Chaos Experiment , https://gridsingularity.medium.com/en-route-to-energy-singularity-odyssey-momentum-learnings-from-the-2020-chaos-experiment-8dc38ff26869 Grid Singularity. (November 25, 2020). Energy Singularity Challenge 2020: Social Energy Networks , https://gridsingularity.medium.com/energy-singularity-challenge-2020-social-energy-networks-157b390e5f39 Grid Singularity. (December 10, 2020). Energy Singularity Challenge 2020: Testing Novel Grid Fee Models and Intelligent Peer-to-Peer Trading Strategies , https://gridsingularity.medium.com/energy-singularity-challenge-2020-testing-novel-grid-fee-models-and-intelligent-peer-to-peer-6a0d715a9063","title":"Grid Singularity Medium articles"},{"location":"references/#books","text":"Ana Trbovich, Sarah Hambridge, Dirk van den Biggelaar, Ewald Hesse, Fereidoon Sioshansi, Chapter 13 - D3A energy exchange for a transactive grid, Editor(s): Fereidoon Sioshansi, Behind and Beyond the Meter, Academic Press, 2020, Pages 267-284, ISBN 9780128199510, https://doi.org/10.1016/B978-0-12-819951-0.00013-X . (http://www.sciencedirect.com/science/article/pii/B978012819951000013X)","title":"Books"},{"location":"references/#scientific-articles-and-studies","text":"BBEn, 100 prozent erneuerbar stiftung, Grid Singularity, Neue Kraft mit der Nachbarschaft , October 2020, https://www.buendnis-buergerenergie.de/fileadmin/nkmdn_Lokale_Strommaerkte.pdf Trbovich, Ana S. \u2018In Pursuit of Good Governance for the Energy Industry Blockchain\u2019. Journal of Energy Markets , May 2019, https://www.risk.net/node/6637136 . Danzi, P. Hambridge,S. Stefanovi\u0107, \u010c. Popovski,P. \u2018Blockchain-Based and Multi-Layered Electricity Imbalance Settlement Architecture\u2019. IEEE, December 27,2018. https://ieeexplore.ieee.org/abstract/document/8587577/references#references","title":"Scientific articles and studies"},{"location":"releases/","text":"Version 0.10.0 \u00b6 The following features were implemented : Canary Networks : An admin user can create a Canary Network simulation, which duplicates a collaboration simulation and allows the admin to connect each energy asset in the grid to its live data stream in order to simulate trading on the asset's live metered data readings. The Canary Network runs in real-time , with incoming data collected during each 15 minute market slot. Researcher users can trade on behalf of energy assets using the registry to connect to the live data stream which broadcasts the energy required for each asset through the Asset API . Grid Operator users can change the grid fees and grid parameters of each grid market using the registry which connects them to their markets through the Grid Operator API . Therefore, the Canary Network realizes the digital twin model of an energy asset and enables Researcher users to trade in real-time on behalf of their assets as a proof of concept. Once a Canary Network is established, it continues to run and agents can trade over weeks and months of time, for long term study of energy asset data and agent and market behavior. Previous weeks of data and results are saved in the results page weekly history. Island or Grid-connect a Market Maker as an event: Users can now change the role and mode of the Market Maker as an event, allowing users to simulate blackouts by changing the Market Maker to an islanding role, or simulating other impacts resulting from a change in the Market Maker parameters, such as showing the effect of connecting an islanded Market Maker to the grid. Version 0.9.0 \u00b6 The following features were implemented : Market API , which allows grid operators and researchers to monitor metrics and set grid fees in the select local energy market simulation collaboration Easier registration for researchers and grid operators to manage multiple assets and use market API through the Registry page. Bids and offers are prioritised in their first market by setting a wait time of 2 ticks before allowing them to propagate to higher markets in the grid hierarchy. This wait time is set in the backend as the minimum bid or offer age parameter. Grid fees integrated in the Results page - Energy Pricing graph for each market Total grid fees reported in the Scoreboard page that demonstrates market performance metrics for each collaboration simulation. Net Energy calculation added to Results page - Energy Trade Profile graph in order to calculate the peak energy at a market node in the simulation. The current peak imports and exports were previously calculated based on the cumulative trades, but are now calculated from the net energy consumption, which can be a net import or export. Updated load final selling rate and PV initial buying rate in the template strategies now take the total grid fees into account in addition to the market maker (usually utility) rate. Users can now run three simulations and/or collaborations at once (previous limit was two) Version 0.8.0 \u00b6 The following features were implemented : Simulation Location Map. Users can geo-tag all energy resources and markets in their simulation to make a map view of the simulation and results. A summary of all simulations can be viewed in a global map, to see where Grid Singularity is running simulations all over the world! Version 0.7.0 \u00b6 The following features were implemented : Detailed energy trade profile graph . Zoom in to each 15 minute market slot to view the scheduled trades with 1 minute resolution. Grid Operator user can change grid parameters inside a collaboration and while it is running, like grid fees or the transformer capacity. Allow collaboration participants to register for events while the simulation is running. Allows users to simulate a growing community. Information Aggregator to compile and send average market measurements to assist data scientists in building smart strategies to trade through the API . Version 0.6.0 \u00b6 The following features were implemented : Bid and Offer matching graph Analyze all bids, offers, and trades in a market and see why they match based on their strategies. Simulation events Add, delete, or update areas or energy resources in a simulation while it is running. This allows users to grow their simulations in real-time and analyze the impacts of energy resources coming online and changes to grid parameters such as grid fees. Timeline to view events and zoom in View all events in a timeline and click on each event to view its relevant grid configuration and results. Zoom in to view results for a specific day. Pause or stop a simulation Pause a simulation to freeze it while adding an event. Stop a simulation pre-maturely in order to run another version sooner. Configure an infinite bus as part of the Market Maker Configure an Infinite Bus in order to add a feed-in-tariff to the simulation. Version 0.5.0 \u00b6 The following features were implemented : Constant based Grid Fees Self Sufficiency, Self Consumption , and Energy Peak Percentage KPIs Simulation runtime status indicator Increased node limit to 1000 nodes Collaborations Scoreboard Select visible charts on Results page Colors for Energy Bills Bought and Sold Version 0.4.0 \u00b6 The following features were implemented : Grid fees configuration User roles, including 'Collaborations' feature for multi user testing and Grid Singularity-hosted challenges API connection to energy devices allowing bids and offers to be submitted by external algorithms Version 0.3.0 \u00b6 The following features were implemented : Run simulations with up to 250 nodes Compare results of two simulations side by side New navigation side bar with Home, Projects, and Library easily accessible Version 0.2.0 \u00b6 The following features were implemented : Run simulations for one week Choose your market type: additional access to two-sided pay as bid and two-sided pay as clear market types New user friendly device strategies Configure your market maker Scrollable graphs on the results page optimized for longer simulations Download simulation results","title":"Releases Archive"},{"location":"releases/#version-0100","text":"The following features were implemented : Canary Networks : An admin user can create a Canary Network simulation, which duplicates a collaboration simulation and allows the admin to connect each energy asset in the grid to its live data stream in order to simulate trading on the asset's live metered data readings. The Canary Network runs in real-time , with incoming data collected during each 15 minute market slot. Researcher users can trade on behalf of energy assets using the registry to connect to the live data stream which broadcasts the energy required for each asset through the Asset API . Grid Operator users can change the grid fees and grid parameters of each grid market using the registry which connects them to their markets through the Grid Operator API . Therefore, the Canary Network realizes the digital twin model of an energy asset and enables Researcher users to trade in real-time on behalf of their assets as a proof of concept. Once a Canary Network is established, it continues to run and agents can trade over weeks and months of time, for long term study of energy asset data and agent and market behavior. Previous weeks of data and results are saved in the results page weekly history. Island or Grid-connect a Market Maker as an event: Users can now change the role and mode of the Market Maker as an event, allowing users to simulate blackouts by changing the Market Maker to an islanding role, or simulating other impacts resulting from a change in the Market Maker parameters, such as showing the effect of connecting an islanded Market Maker to the grid.","title":"Version 0.10.0"},{"location":"releases/#version-090","text":"The following features were implemented : Market API , which allows grid operators and researchers to monitor metrics and set grid fees in the select local energy market simulation collaboration Easier registration for researchers and grid operators to manage multiple assets and use market API through the Registry page. Bids and offers are prioritised in their first market by setting a wait time of 2 ticks before allowing them to propagate to higher markets in the grid hierarchy. This wait time is set in the backend as the minimum bid or offer age parameter. Grid fees integrated in the Results page - Energy Pricing graph for each market Total grid fees reported in the Scoreboard page that demonstrates market performance metrics for each collaboration simulation. Net Energy calculation added to Results page - Energy Trade Profile graph in order to calculate the peak energy at a market node in the simulation. The current peak imports and exports were previously calculated based on the cumulative trades, but are now calculated from the net energy consumption, which can be a net import or export. Updated load final selling rate and PV initial buying rate in the template strategies now take the total grid fees into account in addition to the market maker (usually utility) rate. Users can now run three simulations and/or collaborations at once (previous limit was two)","title":"Version 0.9.0"},{"location":"releases/#version-080","text":"The following features were implemented : Simulation Location Map. Users can geo-tag all energy resources and markets in their simulation to make a map view of the simulation and results. A summary of all simulations can be viewed in a global map, to see where Grid Singularity is running simulations all over the world!","title":"Version 0.8.0"},{"location":"releases/#version-070","text":"The following features were implemented : Detailed energy trade profile graph . Zoom in to each 15 minute market slot to view the scheduled trades with 1 minute resolution. Grid Operator user can change grid parameters inside a collaboration and while it is running, like grid fees or the transformer capacity. Allow collaboration participants to register for events while the simulation is running. Allows users to simulate a growing community. Information Aggregator to compile and send average market measurements to assist data scientists in building smart strategies to trade through the API .","title":"Version 0.7.0"},{"location":"releases/#version-060","text":"The following features were implemented : Bid and Offer matching graph Analyze all bids, offers, and trades in a market and see why they match based on their strategies. Simulation events Add, delete, or update areas or energy resources in a simulation while it is running. This allows users to grow their simulations in real-time and analyze the impacts of energy resources coming online and changes to grid parameters such as grid fees. Timeline to view events and zoom in View all events in a timeline and click on each event to view its relevant grid configuration and results. Zoom in to view results for a specific day. Pause or stop a simulation Pause a simulation to freeze it while adding an event. Stop a simulation pre-maturely in order to run another version sooner. Configure an infinite bus as part of the Market Maker Configure an Infinite Bus in order to add a feed-in-tariff to the simulation.","title":"Version 0.6.0"},{"location":"releases/#version-050","text":"The following features were implemented : Constant based Grid Fees Self Sufficiency, Self Consumption , and Energy Peak Percentage KPIs Simulation runtime status indicator Increased node limit to 1000 nodes Collaborations Scoreboard Select visible charts on Results page Colors for Energy Bills Bought and Sold","title":"Version 0.5.0"},{"location":"releases/#version-040","text":"The following features were implemented : Grid fees configuration User roles, including 'Collaborations' feature for multi user testing and Grid Singularity-hosted challenges API connection to energy devices allowing bids and offers to be submitted by external algorithms","title":"Version 0.4.0"},{"location":"releases/#version-030","text":"The following features were implemented : Run simulations with up to 250 nodes Compare results of two simulations side by side New navigation side bar with Home, Projects, and Library easily accessible","title":"Version 0.3.0"},{"location":"releases/#version-020","text":"The following features were implemented : Run simulations for one week Choose your market type: additional access to two-sided pay as bid and two-sided pay as clear market types New user friendly device strategies Configure your market maker Scrollable graphs on the results page optimized for longer simulations Download simulation results","title":"Version 0.2.0"},{"location":"results/","text":"User Interface Results \u00b6 Grid Singularity\u2019s UI (d3a.io) offers visual representations of simulation results. These are updated while the simulation is running and stored indefinitely until the user decides to delete or to rerun the simulation. The user is able to view Results for each area or asset in the grid configuration. Navigating the grid configuration in the UI \u00b6 As shown in the image above, the user can select a market or an energy asset from a drop down to view specific results for that market or an asset while on the Results page. In the figure above, the Community market is selected. The Results page then displays relevant plots and tables for the selected market or asset. There is also the possibility to select which charts / tables you want to view / hide, as shown in the image above. This section discusses the information available in each chart / table. Energy availability \u00b6 This plot shows whether each consuming energy asset (i.e. load) inside the selected market had access to the energy it needed for each market slot. On the x-axis, the time is given. If the participating asset agent was able to purchase the energy it required for that time slot, the block will be colored green . If not, it will be colored purple . The granularity of the plot is one hour , so if there was a trade interval within the hour in which the agent was not able to buy the demanded energy, the entire block will be colored purple. The user can hover the cursor over a purple block to view a list of the energy assets that were not able to buy energy in that time slot. Self-sufficiency and self-consumption \u00b6 These two pie charts display Self-Sufficiency and Self-Consumption level of the selected area. Please see this page for more information. When the user hovers the cursor over these plots, the following quantitative energy metrics are shown: Self-consumed energy [kWh] Total demanded energy [kWh] Total produced energy [kWh] Cumulative trading \u00b6 This plot shows the total cumulative trade volumes traded among market participants (agents representing assets or markets) in the selected market in the course of the simulation. Each market participant is displayed as a uniquely colored bar that represents the energy sold (shown as negative) or bought (shown as positive). In the example below, the energy sold by House 1 is colored purple, and the House 1 bar is positive, meaning that it bought some of the energy it produced for its own use (self-consumption). The rest of the energy it sold is shown as a thin purple layer appearing in the bars of the other market participants that acted as buyers. This color coding allows the user to visually track the energy trade flows in the selected market. External Trades represent the import/export from/to a higher level market by the Inter-area agent of the selected market, and hence the difference between energy traded amongst the selected market participants and the total accumulated trades. The external trades bar represents energy produced in this market, but sold to an outside market, as well as the energy bought from an external source and sold to a participant in this market. The energy bought externally is teal in this example and the bar is negative for external trades. The energy that was sold to other market participants is indicated by a positive teal colored bar. A negative external trades bar means that the participants within the select market purchased energy externally and a positive external trades bar means that participants sold energy to an external market. Energy bills and net energy \u00b6 In the Community market shown in the figure below, the participating agents are the inter-area agents of the houses that lie within that market. The energy bill table provides information on the cumulative trade volumes of all market participants and the costs associated with trades. For each market and energy asset, the energy bought and sold during the simulation is listed, along with a total net energy consumption. The Totals column can be considered as the net energy consumption and final bill for the listed agent, which may represent an energy asset or a market (e.g. a house). The Totals row represents the total of trades that are made by all participants inside the selected market. Energy trade profile \u00b6 The energy profile shows the supply and demand of trades made inside the selected market for each market slot of the simulation. The negative side of the y-axis represents the energy sold, and the positive y-axis shows the energy bought. The different colors represent the different market participants (energy assets and markets). As all buyers and sellers of each trade are accounted for in a select market, the supply and demand sides are exact mirrors of each other in terms of volume. If peak analysis is switched on, the internal trades are hidden and only the trades including external participants are displayed. This shows how much energy required the use of transmission lines outside of the selected market. On the peak analysis plot, two lines are shown: the current peak imports and the current peak exports , representing the maximum energy imported and exported for the selected market. Another feature of this graph is viewing the Net energy , shown below. When peak analysis is activated, only net external trades of each participant are displayed. The net displays the difference between the total import and export for each market slot, useful in understanding the impact to transmission capacity . Detailed energy trade profile \u00b6 This graph is a market slot level breakdown of the energy trade profile. With this graph, the user can select a specific market slot to see when each trade was cleared during that slot, with a resolution of 30 simulated seconds. The graph's length is the market slot length (15 minutes by default). The market slot can be selected with the drop down (days) and the slider (hours and minutes). Energy pricing \u00b6 In this plot, energy pricing is shown. Depending on market design and grid configuration, there could be different price settlements in the same market slot. In this case, a minimum , maximum , and average of the trade price is shown. If no trade occurred during a certain market interval, no lines are plotted. If grid fees are set in that market as a constant value, a fourth line is plotted to reflect its price. Bids, Offers, and Trades per Market Slot \u00b6 In this plot, each bid, offer and trade posted/cleared in the selected market is shown according to its posting/clearing times, allowing the user to analyse how specific offers/bids were or were not matched and validate or further investigate their trading strategy. The x-axis of this graph is the market slot length (15 minutes by default), and the y-axis shows the bid and offer price. Each market slot of the simulation can be selected and viewed with the drop down (days) and the slider (hours & minutes). Compare results \u00b6 The user has the possibility to compare the results of two separate simulations. The user can also duplicate the simulation setup, download results or delete the configuration by using the appropriate buttons shown below: Backend Results \u00b6 After running a simulation in the backend, the user can export simulation results. This functionality is enabled by default. If you want to disable the export of simulation results, use the --no-export flag for the simulation run. Another useful parameter is: --export-path , used to change the output path of the simulation results. The default path is $HOME/d3a-simulation/ . The simulation results include analytical information about the bids, offers and trades that took place in the course of the simulation. Information about energy characteristics of each asset and market are also included (eg. battery state of charge, energy traded/requested/deficit). A detailed description of these files is available on the data download page. In addition to text files, some graphs that display aggregated market information during the course of the simulation are also exposed. These can be found under the plot directory and are very similar to the ones available in the UI : unmatched_loads_*.html : Plots the volume of energy that loads have not been able to purchase (power outage) energy_profile_*.html : Similar plot to energy trade profile average_trade_price_*.html : Similar plot to energy pricing asset_profile_*.html : each energy asset within the simulation has its own plot showing its profile (consumption, generation, State of Charge), the actual energy traded and energy rates.","title":"Results Dashboard"},{"location":"results/#user-interface-results","text":"Grid Singularity\u2019s UI (d3a.io) offers visual representations of simulation results. These are updated while the simulation is running and stored indefinitely until the user decides to delete or to rerun the simulation. The user is able to view Results for each area or asset in the grid configuration.","title":"User Interface Results"},{"location":"results/#navigating-the-grid-configuration-in-the-ui","text":"As shown in the image above, the user can select a market or an energy asset from a drop down to view specific results for that market or an asset while on the Results page. In the figure above, the Community market is selected. The Results page then displays relevant plots and tables for the selected market or asset. There is also the possibility to select which charts / tables you want to view / hide, as shown in the image above. This section discusses the information available in each chart / table.","title":"Navigating the grid configuration in the UI"},{"location":"results/#energy-availability","text":"This plot shows whether each consuming energy asset (i.e. load) inside the selected market had access to the energy it needed for each market slot. On the x-axis, the time is given. If the participating asset agent was able to purchase the energy it required for that time slot, the block will be colored green . If not, it will be colored purple . The granularity of the plot is one hour , so if there was a trade interval within the hour in which the agent was not able to buy the demanded energy, the entire block will be colored purple. The user can hover the cursor over a purple block to view a list of the energy assets that were not able to buy energy in that time slot.","title":"Energy availability"},{"location":"results/#self-sufficiency-and-self-consumption","text":"These two pie charts display Self-Sufficiency and Self-Consumption level of the selected area. Please see this page for more information. When the user hovers the cursor over these plots, the following quantitative energy metrics are shown: Self-consumed energy [kWh] Total demanded energy [kWh] Total produced energy [kWh]","title":"Self-sufficiency and self-consumption"},{"location":"results/#cumulative-trading","text":"This plot shows the total cumulative trade volumes traded among market participants (agents representing assets or markets) in the selected market in the course of the simulation. Each market participant is displayed as a uniquely colored bar that represents the energy sold (shown as negative) or bought (shown as positive). In the example below, the energy sold by House 1 is colored purple, and the House 1 bar is positive, meaning that it bought some of the energy it produced for its own use (self-consumption). The rest of the energy it sold is shown as a thin purple layer appearing in the bars of the other market participants that acted as buyers. This color coding allows the user to visually track the energy trade flows in the selected market. External Trades represent the import/export from/to a higher level market by the Inter-area agent of the selected market, and hence the difference between energy traded amongst the selected market participants and the total accumulated trades. The external trades bar represents energy produced in this market, but sold to an outside market, as well as the energy bought from an external source and sold to a participant in this market. The energy bought externally is teal in this example and the bar is negative for external trades. The energy that was sold to other market participants is indicated by a positive teal colored bar. A negative external trades bar means that the participants within the select market purchased energy externally and a positive external trades bar means that participants sold energy to an external market.","title":"Cumulative trading"},{"location":"results/#energy-bills-and-net-energy","text":"In the Community market shown in the figure below, the participating agents are the inter-area agents of the houses that lie within that market. The energy bill table provides information on the cumulative trade volumes of all market participants and the costs associated with trades. For each market and energy asset, the energy bought and sold during the simulation is listed, along with a total net energy consumption. The Totals column can be considered as the net energy consumption and final bill for the listed agent, which may represent an energy asset or a market (e.g. a house). The Totals row represents the total of trades that are made by all participants inside the selected market.","title":"Energy bills and net energy"},{"location":"results/#energy-trade-profile","text":"The energy profile shows the supply and demand of trades made inside the selected market for each market slot of the simulation. The negative side of the y-axis represents the energy sold, and the positive y-axis shows the energy bought. The different colors represent the different market participants (energy assets and markets). As all buyers and sellers of each trade are accounted for in a select market, the supply and demand sides are exact mirrors of each other in terms of volume. If peak analysis is switched on, the internal trades are hidden and only the trades including external participants are displayed. This shows how much energy required the use of transmission lines outside of the selected market. On the peak analysis plot, two lines are shown: the current peak imports and the current peak exports , representing the maximum energy imported and exported for the selected market. Another feature of this graph is viewing the Net energy , shown below. When peak analysis is activated, only net external trades of each participant are displayed. The net displays the difference between the total import and export for each market slot, useful in understanding the impact to transmission capacity .","title":"Energy trade profile"},{"location":"results/#detailed-energy-trade-profile","text":"This graph is a market slot level breakdown of the energy trade profile. With this graph, the user can select a specific market slot to see when each trade was cleared during that slot, with a resolution of 30 simulated seconds. The graph's length is the market slot length (15 minutes by default). The market slot can be selected with the drop down (days) and the slider (hours and minutes).","title":"Detailed energy trade profile"},{"location":"results/#energy-pricing","text":"In this plot, energy pricing is shown. Depending on market design and grid configuration, there could be different price settlements in the same market slot. In this case, a minimum , maximum , and average of the trade price is shown. If no trade occurred during a certain market interval, no lines are plotted. If grid fees are set in that market as a constant value, a fourth line is plotted to reflect its price.","title":"Energy pricing"},{"location":"results/#bids-offers-and-trades-per-market-slot","text":"In this plot, each bid, offer and trade posted/cleared in the selected market is shown according to its posting/clearing times, allowing the user to analyse how specific offers/bids were or were not matched and validate or further investigate their trading strategy. The x-axis of this graph is the market slot length (15 minutes by default), and the y-axis shows the bid and offer price. Each market slot of the simulation can be selected and viewed with the drop down (days) and the slider (hours & minutes).","title":"Bids, Offers, and Trades per Market Slot"},{"location":"results/#compare-results","text":"The user has the possibility to compare the results of two separate simulations. The user can also duplicate the simulation setup, download results or delete the configuration by using the appropriate buttons shown below:","title":"Compare results"},{"location":"results/#backend-results","text":"After running a simulation in the backend, the user can export simulation results. This functionality is enabled by default. If you want to disable the export of simulation results, use the --no-export flag for the simulation run. Another useful parameter is: --export-path , used to change the output path of the simulation results. The default path is $HOME/d3a-simulation/ . The simulation results include analytical information about the bids, offers and trades that took place in the course of the simulation. Information about energy characteristics of each asset and market are also included (eg. battery state of charge, energy traded/requested/deficit). A detailed description of these files is available on the data download page. In addition to text files, some graphs that display aggregated market information during the course of the simulation are also exposed. These can be found under the plot directory and are very similar to the ones available in the UI : unmatched_loads_*.html : Plots the volume of energy that loads have not been able to purchase (power outage) energy_profile_*.html : Similar plot to energy trade profile average_trade_price_*.html : Similar plot to energy pricing asset_profile_*.html : each energy asset within the simulation has its own plot showing its profile (consumption, generation, State of Charge), the actual energy traded and energy rates.","title":"Backend Results"},{"location":"self-sufficiency-consumption/","text":"Self-sufficiency : % of energy needs covered by local generation Self-consumption : % of local energy generation consumed locally self_sufficiency(market) = self_consumed_energy / total_energy_demanded self_consumption(market) = self_consumed_energy / total_energy_produced The example provided in the figure below has the following grid architecture: total_house1_pv_production = 10kWh house1_pv \u2192 house1_load = 1kWh house1_pv \u2192 house1_storage = 5kWh house1_pv \u2192 house2_load = 4kWh house1_storage \u2192 house1_load = 2kWh house1_storage \u2192 house2_load = 3kWh house1_self_consumer_energy = ( house1_pv \u2192 house1_load ) + ( house1_pv \u2192 house1_storage \u2192 house1_load ) = 1 + 2 = 3kWh house1_total_energy_demanded (only includes the demanded energy from house1\u2019s load asset) = 3kWh In this example, self-sufficiency of the house 1 is self_sufficiency(house1) = house1_self_consumer_energy / house1_total_energy_demanded self_sufficiency(house1) = 3 / 3 = 1 \u2192 100% Self-consumption of the house 1 is self_consumption(house1) = house1_self_consumer_energy / house1_total_energy_produced self_consumption(house1) = 3 / 10 = 0.3 \u2192 30% In the Grid , the highest level of the hierarchy : self_sufficiency = 10 / 10 = 1 \u2192 100% self_consumption = 10 / 10 = 1 \u2192 100%","title":"Self-Sufficiency and Self-Consumption"},{"location":"technical-approach/","text":"Grid Singularity energy exchange engine (D3A) organizes the grid into hierarchical markets . For example, household assets are initially grouped into a household market, which are in turn grouped into higher-level markets such as neighborhoods, districts, or regions. Since the grid is already organized by different voltage levels, the hierarchies of markets in the D3A can reflect the different voltage levels of the grid. This allows grid fees to be accounted for in each market . This type of structure enables grid operators to source flexibility for targeted congestion management or frequency balancing . It also facilitates easy scaling by connecting diverse energy communities. Market participants such as energy assets are represented by agents , trading algorithms defined by user-set parameters, which act like traders . Energy prices are established by bids and offers and are issued by agents according to the trading strategies of market participants. Energy assets trade with each other and with other submarkets inside a parent market. In this way energy trading can be organized into groups or communities by registering assets in the relevant markets. These markets are then stacked in a market hierarchy to allow inter-market trading across the entire grid infrastructure, while prioritizing trade in the local markets. The utility is also represented by an agent, the Market Maker . Trading happens at the most cost-efficient level following a select market mechanism . This will typically be locally, but if an actor (e.g., a grid operator) has set certain parameters that place a better bid into the market due to a high need (e.g. for grid flexibility), inter-area trading agents can match it with offers from a lower or higher-level market. Grid operators may also levy flexible grid fees on local markets to help manage congestion. It is important to note that the D3A is not, itself, trading energy or providing balancing services. Rather, it is creating the exchange , registering assets, and providing the mechanism of agents to allow assets and markets to place bids and offers and trade directly with one another (i.e., peer-to-peer) in a fully decentralized manner, or, if there is insufficient local generation, from the utility. This decentralized structure removes limits to scaling. If the D3A is deployed to facilitate a local distributed energy exchange, the traditional roles of the grid operator, which manages the connection to the power grid, and the utility, as a provider of energy, would continue to be required to integrate the local energy market with the wider grid network. The primary difference is that a utility would no longer be the only market actor with which a household exchanges energy, but one of multiple. Grid Singularity\u2019s D3A is a highly innovative and effective grid modernization solution. First, it creates a resilient market by ensuring equal access, transparent pricing, and trading at optimal market levels (i.e., between assets and buildings or facility and grid). Second, it incentivizes and facilitates the integration of clean DERs onto the grid closer to load centers. Third, grid operators can use it to implement flexible grid tariffs to benefit from the local market flexibility to alleviate congestion. Fourth, the Grid Singularity API provides instantaneous granular data to the grid operator\u2013which historically has relied upon changes in detected load and alterations from the forecast\u2013enabling the operator to improve management, flexibility, and grid performance. Fifth, peer-to-peer trading is market-driven , not based upon predetermined pricing, which optimizes local consumption and thus the use of (cheaper) local renewables, increasing affordability, reducing reliance and overall/peak load on the grid, supporting efficient asset utilization, and reducing system losses. Sixth, it increases community self-sufficiency and energy savings , providing emergency power backup, and mitigating the need for new transmission infrastructure. Seventh, the software empowers customer engagement in energy markets by lowering barriers, creating cost incentives, and increasing choice (e.g., type of energy consumed or preferred trading partner). Finally, the peer-to-peer trading system incentivizes private investment in electric system infrastructure by increasing revenue from renewable DERs and providing decision-making tools. Grid Singularity fosters interoperability and open-source development, collaborating with other market actors that provide grid management and asset aggregation services. Our software is agnostic to regulation , with regulatory compliance such as balance reporting provided by implementation partners.","title":"Grid Singularity Technical Approach"},{"location":"two-sided-pay-as-bid/","text":"In the Two-Sided Pay-as-Bid market, buyers are able to place bids in the market, alongside the offers placed by sellers. Each market collects and matches bids and offers issued by trading agents, and dispatches bids and offers to other markets via the Inter-Area Agent (IAA). Bids and offers can also be annulled by the trading agent. The auction is continuous , meaning that once an offer or bid is posted, it can be matched right away, even before the end of the market slot. An Inter-Area Agent is created and operated by each market (area) . Its role is to forward offers and bids to the connected markets. The market constantly triggers the matching between bids and offers according to the matching algorithm as illustrated in the figure below.","title":"Two-Sided Pay-as-Bid Market"},{"location":"two-sided-pay-as-clear/","text":"In the Two-Sided Pay-as-Clear market, buyers are able to place bids in the market alongside the offers placed by sellers. The market collects and matches bids and offers issued by trading agents, and dispatches bids and offers to other markets via the Inter-Area Agent (IAA). Bids and offers can also be annulled by the trading agent. IAAs are created and operated by each market (area) to forward bids and offers to the connected markets. Currently, there is a merit-order-effect mechanism implemented for bid and offer matching where bids and offers are aggregated and cleared in a specified clearing interval. At the end of each interval, bids are arranged in a descending order, offers in an ascending order and the equilibrium quantity of energy and price is calculated. The clearing point (the quantity of energy that is accepted trade volume for a specific energy rate clearing price ) is determined by the point where the arranged bid curve for the buyers drops below the offer curve for the sellers. The highest bids are matched with the lowest offers. The matching rate is the clearing price (cents/kWh). The remaining bids and offers (right of the clearing point in the plot above) are not cleared at this clearing point and remain in the market for later matching.","title":"Two-Sided Pay-as-Clear Market"},{"location":"ui-initialisation/","text":"To start using the Grid Singularity Energy Exchange ), you need to register your account by selecting a user email and password. You will then receive an email with a link to confirm your account. You can design your own project by clicking on \u201cnew project\u201d and then create a new simulation. The first step in setting up a simulation is to define the simulation general and market settings, described in more detail below. The next step is to design your grid. Once you arrive in the grid setup, the first thing that you will have to do is to define the market maker. Subsequently, you can start building the digital twin of your grid including submarkets and relevant energy assets that can all be individually configured. The setup is intended to represent the physical architecture of the real energy market (country, region, neighbourhood, house, etc.). After your grid setup is complete, you can run your simulation. When it is finished you can view multiple scrollable plots and tables on the Results page. For a step-by-step explanation on how to set up your simulation, please watch our tutorial . You can also contact us at Note: For smoother simulations and smaller queues, we have set some boundaries. First, the simulations are limited in their duration. You can currently set the duration from 1 to 7 days . Furthermore, the number of agents per simulation is limited. Each market and asset is represented by an agent and you can define up to 1000 agents . Please see instructions on Backend simulation configuration here .","title":"Setting up a simulation in the User Interface"},{"location":"upload-file-formats/","text":"Files can be uploaded to generate custom energy supply or load profiles. The following file formats are supported: Comma Separated Values (.csv) \u00b6 The separation can be done by comma , or semicolon ; . Two time formats are supported, see below. Power set-points are given in Watts . The software handles any conversions to energy (in kWh). hh:mm \u00b6 Example: INTERVAL;POWER(W): 00:00;10 00:15;10 00:30;10 00:45;10 01:00;10 YYYY-MM-DDThh:mm \u00b6 Example: INTERVAL,POWER(W) 2019-01-01T00:00,10.0 2019-01-01T00:15,10.0 2019-01-01T00:30,10.0 2019-01-01T00:45,10.0 2019-01-01T01:00,10.0 Note: If you upload csv files with date information, the start-date of the simulation should be identical in the csv files and simulation settings .","title":"File Upload Format"},{"location":"upload-file-formats/#comma-separated-values-csv","text":"The separation can be done by comma , or semicolon ; . Two time formats are supported, see below. Power set-points are given in Watts . The software handles any conversions to energy (in kWh).","title":"Comma Separated Values (.csv)"},{"location":"upload-file-formats/#hhmm","text":"Example: INTERVAL;POWER(W): 00:00;10 00:15;10 00:30;10 00:45;10 01:00;10","title":"hh:mm"},{"location":"upload-file-formats/#yyyy-mm-ddthhmm","text":"Example: INTERVAL,POWER(W) 2019-01-01T00:00,10.0 2019-01-01T00:15,10.0 2019-01-01T00:30,10.0 2019-01-01T00:45,10.0 2019-01-01T01:00,10.0 Note: If you upload csv files with date information, the start-date of the simulation should be identical in the csv files and simulation settings .","title":"YYYY-MM-DDThh:mm"},{"location":"version-update/","text":"Grid Singularity energy exchange engine (D3A) Update \u00b6 Please start by opening a terminal and activating the Grid Singularity D3A virtual environment as described in the Installation Instructions. Then type: git pull origin/master fab sync If fab sync does not work on your machine, please try: pip install -e . Grid Singularity API Client Update \u00b6 Please start by opening a terminal and activating the API client virtual environment as described in the API Installation Instructions. Then type: pip uninstall d3a-api-client Press y when prompted. Once the uninstall is complete, type: pip install git+https://github.com/gridsingularity/d3a-api-client.git","title":"Version Updates"},{"location":"version-update/#grid-singularity-energy-exchange-engine-d3a-update","text":"Please start by opening a terminal and activating the Grid Singularity D3A virtual environment as described in the Installation Instructions. Then type: git pull origin/master fab sync If fab sync does not work on your machine, please try: pip install -e .","title":"Grid Singularity energy exchange engine (D3A) Update"},{"location":"version-update/#grid-singularity-api-client-update","text":"Please start by opening a terminal and activating the API client virtual environment as described in the API Installation Instructions. Then type: pip uninstall d3a-api-client Press y when prompted. Once the uninstall is complete, type: pip install git+https://github.com/gridsingularity/d3a-api-client.git","title":"Grid Singularity API Client Update"},{"location":"vision/","text":"The Grid Singularity Energy Exchange Engine (D3A) is developed by Grid Singularity as an interface ( d3a.io ) and open source codebase (see Licensing ) to model, simulate, optimize and (coming soon) download and deploy interconnected, grid-aware energy marketplaces. Grid Singularity has been proclaimed the World Tech Pioneer by the World Economic Forum and is also known as a co-founder of the Energy Web Foundation that gathers leading energy corporations globally co-developing a shared blockchain-based platform. Our team is guided by the following principles: Grid Singularity facilitates a bottom-up market design by connecting aggregators, which in turn connect households and distributed energy assets digitally represented by trading agents, and grid operators through an application interface ( Grid Operator API and Asset API ). The backend code offers the full functionality of the active version of the D3A, while the user friendly User Interface (UI) offers eased access to the majority of features found in the backend. New features are typically developed in the backend first and are made available in the UI after internal testing for usability and accuracy. Our software empowers energy communities. An energy community is a grouping of multiple energy actors: consumers, producers and prosumers (consumers who also produce energy) with the goal to exchange energy locally to improve economic, social and environmental welfare. The European Union defines these communities as citizen energy communities or renewable energy communities (see Energy Communities: a Game Changer for the European Electricity Grid , 2020) and they are also known as energy cooperatives, microgrids, self-consumption communities or community choice aggregators (CCAs) in different markets. Modelling simulation studies carried out by Grid Singularity and German and Dutch energy communities and utilities using real-world data have revealed that the use of Grid Singularity\u2019s Energy Exchange Engine can increase community self-sufficiency and self-consumption by 7.7% and 5.7%, respectively, and reduce energy bills by around 21% , which could be reinvested in additional storage or other distributed energy assets (DERs). Utilization of Grid Singularity\u2019s exchange engine by a grid operator could reduce peak loading and congestion by purchasing grid balancing services and levying flexible grid fees . The initial simulation experiments undertaken by Grid Singularity and German and Dutch energy grid operators revealed 10% reductions in peak loading and congestion, expected to improve with innovation in trading algorithms and grid tariff models. Importantly, Grid Singularity\u2019s energy exchange engine furnishes both prosumers and regular consumers with equitable access to energy trading. Simulations studies, undertaken by using real data from a German energy community EWS Sch\u00f6nau, showed that activating local peer-to-peer trading benefits not just a community endowed in distributed resources but also a neighbouring community devoid of such resources: Week Electricity Bills No intercommunity trade With intercommunity trade Absolute change Relative change November EWS Sch\u00f6nau 787.1 \u20ac 793.7 \u20ac 6.6 \u20ac 0.84 % May -679.5 \u20ac -789.7 \u20ac -110.2 \u20ac -16.22 % November Community without own generation 2068.3 \u20ac 2018.8 \u20ac -49.5 \u20ac -2.39 % May 952.9 \u20ac 865.8 \u20ac -87.1 \u20ac -9.14 % Table: EWS Schonau and consumer community electricity bills with and without inter-community trading for the weeks of November and May To efficiently manage energy within a community while preserving end-user freedom and decentralization, a local energy market (LEM) enabling peer-to-peer and community trading can be established. Grid Singularity\u2019s simulation tool available at d3a.io can be used to configure a grid-aware LEM, leading to future physical deployment. The user can build a \u201cdigital twin\u201d representation of physical energy systems and energy markets (using real-world data) and run complex simulations in order to assess the impact of different actions or assets in the system.","title":"Grid Singularity Vision"},{"location":"vm-installation-instructions/","text":"If the D3A is already installed and updated on your virtual machine you can skip to step 4. Step 1: Windows environment settings (not always required, please try starting with Step 2) \u00b6 Enable Intel Virtualization on your computer in BIOS. Go to your Windows Features setting and disable Windows Hypervisor Platform (or Hyper-V) and enable Virtual Machine Platform. Step 2: Install Virtualbox and Vagrant \u00b6 It is recommended to use Chocolatey as a package management tool for Windows. Open your terminal (cmd.exe) as administrator and install chocolatey by running the following command : @\"%SystemRoot%\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\" -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command \"[System.Net.ServicePointManager]::SecurityProtocol = 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))\" && SET \"PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin\" Install Virtualbox from a Windows console choco install virtualbox Install Vagrant (this is a software wrapper around virtualbox and other supervisors, that allows easy creation, download, and installation of virtual machines. choco install vagrant vagrant plugin install vagrant-disksize Step 3: Install D3A while sharing a folder between guest and host machine via vagrant \u00b6 Create a new-folder that you want to share across guest and host machines. Add the Vagrantfile from D3A repository into your newly created folder. Open a terminal and go into your newly-created folder with: cd <path-to-your-folder> If it is your first time do: vagrant up If vagrant was already running, please delete re-initialize with the following steps first : Delete old vagrant images via : vagrant destroy --force Remove residues of old vagrant boxes via : vagrant box remove ubuntu/<your-box-name> --all --force Step 4: Reload your virtual machine: \u00b6 vagrant reload Step 5: Access your virtual machine terminal to run D3A: \u00b6 vagrant ssh Step 6: Share folder to Windows host by running these three commands: \u00b6 cp -r /home/vagrant/d3a /vagrant/ Share d3a-api-client : cp -r /home/vagrant/d3a-api-client /vagrant/ If you have results you want to export to windows : cd /home/vagrant/d3a-simulation/ zip -r <your-zip-filename>.zip ./<folder-to-be-zipped>/ cp -r <your-zip-filename>.zip /vagrant/ Step 7: Run Grid Singularity D3A simulation \u00b6 Activate the D3A environment: source /home/vagrant/envs/d3a/bin/activate Run simulation with: cd /vagrant/d3a d3a run Step 8: Run the D3A API client in Vagrant \u00b6 Activate the API-client environment: source /home/vagrant/envs/api-client/bin/activate To run your API script, run the following command (template here): python your_api_script.py","title":"Virtual Machine Installation Instructions"},{"location":"vm-installation-instructions/#step-1-windows-environment-settings-not-always-required-please-try-starting-with-step-2","text":"Enable Intel Virtualization on your computer in BIOS. Go to your Windows Features setting and disable Windows Hypervisor Platform (or Hyper-V) and enable Virtual Machine Platform.","title":"Step 1: Windows environment settings (not always required, please try starting with Step 2)"},{"location":"vm-installation-instructions/#step-2-install-virtualbox-and-vagrant","text":"It is recommended to use Chocolatey as a package management tool for Windows. Open your terminal (cmd.exe) as administrator and install chocolatey by running the following command : @\"%SystemRoot%\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\" -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command \"[System.Net.ServicePointManager]::SecurityProtocol = 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))\" && SET \"PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin\" Install Virtualbox from a Windows console choco install virtualbox Install Vagrant (this is a software wrapper around virtualbox and other supervisors, that allows easy creation, download, and installation of virtual machines. choco install vagrant vagrant plugin install vagrant-disksize","title":"Step 2: Install Virtualbox and Vagrant"},{"location":"vm-installation-instructions/#step-3-install-d3a-while-sharing-a-folder-between-guest-and-host-machine-via-vagrant","text":"Create a new-folder that you want to share across guest and host machines. Add the Vagrantfile from D3A repository into your newly created folder. Open a terminal and go into your newly-created folder with: cd <path-to-your-folder> If it is your first time do: vagrant up If vagrant was already running, please delete re-initialize with the following steps first : Delete old vagrant images via : vagrant destroy --force Remove residues of old vagrant boxes via : vagrant box remove ubuntu/<your-box-name> --all --force","title":"Step 3: Install D3A while sharing a folder between guest and host machine via vagrant"},{"location":"vm-installation-instructions/#step-4-reload-your-virtual-machine","text":"vagrant reload","title":"Step 4: Reload your virtual machine:"},{"location":"vm-installation-instructions/#step-5-access-your-virtual-machine-terminal-to-run-d3a","text":"vagrant ssh","title":"Step 5: Access your virtual machine terminal to run D3A:"},{"location":"vm-installation-instructions/#step-6-share-folder-to-windows-host-by-running-these-three-commands","text":"cp -r /home/vagrant/d3a /vagrant/ Share d3a-api-client : cp -r /home/vagrant/d3a-api-client /vagrant/ If you have results you want to export to windows : cd /home/vagrant/d3a-simulation/ zip -r <your-zip-filename>.zip ./<folder-to-be-zipped>/ cp -r <your-zip-filename>.zip /vagrant/","title":"Step 6: Share folder to Windows host by running these three commands:"},{"location":"vm-installation-instructions/#step-7-run-grid-singularity-d3a-simulation","text":"Activate the D3A environment: source /home/vagrant/envs/d3a/bin/activate Run simulation with: cd /vagrant/d3a d3a run","title":"Step 7: Run Grid Singularity D3A simulation"},{"location":"vm-installation-instructions/#step-8-run-the-d3a-api-client-in-vagrant","text":"Activate the API-client environment: source /home/vagrant/envs/api-client/bin/activate To run your API script, run the following command (template here): python your_api_script.py","title":"Step 8: Run the D3A API client in Vagrant"}]}